C51 COMPILER V9.05   GTCPDAT                                                               04/11/2012 16:47:00 PAGE 1   


C51 COMPILER V9.05, COMPILATION OF MODULE GTCPDAT
OBJECT MODULE PLACED IN .\gtcpdat.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\src\mgs2wifi\gtcpdat.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X8020) INC
                    -DIR(..\src\main;..\src\mcpu;..\src\mswdma;..\src\uart0;..\src\mmstimer;..\src\mwif;..\src\madapter;..\src\mtcpip;..\src\
                    -mping;..\src\mpppoe;..\src\si2c;..\src\mdnsc;..\src\mconsole;..\src\mtelnet;..\src\meeprom;..\src\mmac;..\src\mdhcpc;..\
                    -src\mhttp;..\src\mgs2wifi;..\src\mhsuart;..\src\msmtpc;..\src\web_page;..\src\mdhcps;..\src\mdebug;..\src\counter) DEFIN
                    -E(RuntimeCodeAt32KH) VARBANKING DEBUG PRINT(.\gtcpdat.lst) OBJECT(.\gtcpdat.obj)

line level    source

   1          
   2          /* INCLUDE FILE DECLARATIONS */
   3          #include "adapter.h"
   4          #include "gs2w.h"
   5          #include "gconfig.h"
   6          #include "gtcpdat.h"
   7          #include "tcpip.h"
   8          #include "mstimer.h"
   9          #include "stoe.h"
  10          #include "uart0.h"
  11          #include "hsuart.h"
  12          #include "hsuart2.h"
  13          #include "printd.h"
  14          #include "counter.h"
  15          
  16          #include <string.h>
  17          
  18          /* NAMING CONSTANT DECLARATIONS */
  19          #define GTCPDAT_MAX_CONNS                               1
  20          #define GTCPDAT_NO_NEW_CONN                             0xFF
  21          
  22          #define GTCPDAT_STATE_FREE                              0
  23          #define GTCPDAT_STATE_WAIT                              1
  24          #define GTCPDAT_STATE_CONNECTED                 2
  25          
  26          #define GTCPDAT_DATA_INDICATOR                  0x32
  27          #define GTCPDAT_FLOW_CONTROL_INDICATOR  0x33
  28          
  29          #define GTCPDAT_MAIN_CONNECT_TIME       (3 * 60 * (1000/SWTIMER_INTERVAL))   /* 3 minutes */
  30          
  31          /* GLOBAL VARIABLES DECLARATIONS */
  32          
  33          /* LOCAL VARIABLES DECLARATIONS */
  34          static GTCPDAT_CONN gtcpdat_Conns[GTCPDAT_MAX_CONNS];
  35          static U8_T gtcpdat_InterAppId;
  36          static U16_T gtcpdat_EthernetTxTimer;
  37          static U8_T gtcpdat_TcpClient;
  38          static U32_T elapse, time;
  39          
  40          #if GS2W_ENABLE_FLOW_CONTROL                    
              static U8_T txBuf[6];
              #endif
  43          
  44          /* LOCAL SUBPROGRAM DECLARATIONS */
  45          #if GS2W_ENABLE_FLOW_CONTROL                    
              static void gtcpdat_HandleFlowControlPacket(U8_T XDATA* pData, U16_T length, U8_T id);
              static void gtcpdat_SetFlowControl(U8_T fCtrl);
              #endif
  49          
  50          static void gtcpdat_MaintainConnection(U8_T id);
  51          static void gtcpdat_GetDataFromUr(U8_T id);
C51 COMPILER V9.05   GTCPDAT                                                               04/11/2012 16:47:00 PAGE 2   

  52          static void gtcpdat_SendData(U8_T);
  53          static U8_T gtcpdat_CheckAllConnStatusIdle(void);
  54          
  55          static U32_T gtcpdat_LastConnectTime; //zwh.add 20120302
  56          
  57          /*
  58           * ----------------------------------------------------------------------------
  59           * Function Name: GTCPDAT_GetRandomPortNum
  60           * Purpose: 
  61           * Params:
  62           * Returns:
  63           * Note:
  64           * ----------------------------------------------------------------------------
  65           */
  66          U16_T GTCPDAT_GetRandomPortNum(void)
  67          {
  68   1          U16_T port;
  69   1      
  70   1          port = (U16_T)SWTIMER_Tick();
  71   1      
  72   1          if (port < 5000)
  73   1              port += 5000;
  74   1      
  75   1          return port;
  76   1      } /* End of GTCPDAT_GetRandomPortNum() */
  77          
  78          /*
  79           * ----------------------------------------------------------------------------
  80           * Function Name: GTCPDAT_Task
  81           * Purpose: 
  82           * Params:
  83           * Returns:
  84           * Note:
  85           * ----------------------------------------------------------------------------
  86           */
  87          void GTCPDAT_Task(void)
  88          {
  89   1          U8_T i;
  90   1      
  91   1          for (i = 0; i < GTCPDAT_MAX_CONNS; i++)
  92   1          {
  93   2              switch (gtcpdat_Conns[i].State)
  94   2              {
  95   3                  case GTCPDAT_STATE_FREE:
  96   3                      if (gtcpdat_TcpClient == 1)
  97   3                      {
  98   4                          gtcpdat_Conns[i].Ip = GCONFIG_GetClientDestIP();
  99   4                          /* get destination ip */
 100   4                          if (gtcpdat_Conns[i].Ip == 0)
 101   4                              break;
 102   4      
 103   4                                              if ((SWTIMER_Tick()-gtcpdat_LastConnectTime) < 20)               //zwh.add 20120302
 104   4                                                  break;                                                                                               //zwh.add 20120302
 105   4      
 106   4                          gtcpdat_Conns[i].State = GTCPDAT_STATE_WAIT;
 107   4                          gtcpdat_Conns[i].Timer = SWTIMER_Tick();
 108   4                          gtcpdat_Conns[i].Port = GCONFIG_GetClientDestPort();
 109   4                          gtcpdat_Conns[i].TcpSocket = TCPIP_TcpNew(gtcpdat_InterAppId,
 110   4                                                                    i,
 111   4                                                                    gtcpdat_Conns[i].Ip,
 112   4                                                                    GTCPDAT_GetRandomPortNum(),
 113   4                                                                    gtcpdat_Conns[i].Port);
C51 COMPILER V9.05   GTCPDAT                                                               04/11/2012 16:47:00 PAGE 3   

 114   4                                              gtcpdat_LastConnectTime = gtcpdat_Conns[i].Timer;
 115   4                          TCPIP_TcpConnect(gtcpdat_Conns[i].TcpSocket);
 116   4                          GS2W_SetTaskState(GS2W_STATE_TCP_DATA_PROCESS);
 117   4      
 118   4                                              COUNTER_INC_CONNECT_TRY;        //zwh.add 20120312
 119   4      //                    printd("Make a TCP connection with host ip %bu %bu %bu %bu at port %u\n\r",
 120   4      //                          (U8_T) ((gtcpdat_Conns[i].Ip >> 24) & 0x000000FF), (U8_T) ((gtcpdat_Conns[i].I
             -p >> 16) & 0x000000FF), 
 121   4      //                          (U8_T) ((gtcpdat_Conns[i].Ip >> 8) & 0x000000FF), (U8_T) (gtcpdat_Conns[i].Ip 
             -& 0x000000FF),
 122   4      //                          gtcpdat_Conns[i].Port);
 123   4      //zwh.del above 20120312
 124   4                      }
 125   3                      break;
 126   3                  case GTCPDAT_STATE_CONNECTED:
 127   3                      {
 128   4      #if GS2W_ENABLE_FLOW_CONTROL
              
                              U8_T  modemStatus, modemCtrl;
              
                              /* Flow control header: type    length   payload */
                              /*                      ------  -------  ------- */
                              /*                      1 byte  2 bytes   any    */
                              /* length = length of payload                    */
                              if (gtcpdat_Conns[i].LastTxPktAck == 1)
                              {
              
                                  modemStatus = HSUR2_GetModemStatus(TRUE);
                                  modemCtrl = (HSUR2_GetModemControl() & 0x3);
              
                                  if (gtcpdat_Conns[i].FlowControlModemStatus != modemStatus 
                                      || modemCtrl != gtcpdat_Conns[i].FlowControlModemCtrl)
                                  {
                                     gtcpdat_Conns[i].FlowControlModemStatus = modemStatus;
                                     gtcpdat_Conns[i].FlowControlModemCtrl = modemCtrl;
                                     txBuf[0] = GTCPDAT_FLOW_CONTROL_INDICATOR;
                                     txBuf[1] = 0;
                                     txBuf[2] = 3;
                                     txBuf[3] = MODEM_STATUS_CHANGE;
                                     txBuf[4] = modemStatus;
                                     txBuf[5] = modemCtrl;
                                     gtcpdat_Conns[i].LastTxPktAck = 0;
                                     TCPIP_TcpSend(gtcpdat_Conns[i].TcpSocket, &txBuf[0], 6, TCPIP_SEND_NOT_FINAL);
                                  }
                              }
              
                              if (gtcpdat_Conns[i].TxDatLen == 0)
                              {
                                  gtcpdat_Conns[i].TxBuf[gtcpdat_Conns[i].TxDatLen++] = GTCPDAT_DATA_INDICATOR; // TCP d
             -ata packet indicator
                                  gtcpdat_Conns[i].TxDatLen += 2; /* reserved for length */
                              }
              
                              if (gtcpdat_Conns[i].FlowControlXonRx == TRUE)
                              {
              #endif
 167   4                              gtcpdat_GetDataFromUr(i);
 168   4                          gtcpdat_SendData(i);
 169   4      #if GS2W_ENABLE_FLOW_CONTROL
                              } // FlowControlXonRx
              #endif
 172   4                      gtcpdat_MaintainConnection(i);
C51 COMPILER V9.05   GTCPDAT                                                               04/11/2012 16:47:00 PAGE 4   

 173   4                      }
 174   3                      break;
 175   3                  default:
 176   3                      break;
 177   3              }
 178   2          }
 179   1      } /* End of GTCPDAT_Task() */
 180          
 181          /*
 182           * ----------------------------------------------------------------------------
 183           * Function Name: gtcpdat_MaintainConnection()
 184           * Purpose: 
 185           * Params:
 186           * Returns:
 187           * Note:
 188           * ----------------------------------------------------------------------------
 189           */
 190          static void gtcpdat_MaintainConnection(U8_T id)
 191          {
 192   1          time = SWTIMER_Tick();
 193   1      
 194   1          if (time >= gtcpdat_Conns[id].Timer)
 195   1              elapse = time - gtcpdat_Conns[id].Timer;
 196   1          else
 197   1              elapse = (0xFFFFFFFF - gtcpdat_Conns[id].Timer) + time;
 198   1      
 199   1          if (elapse >= GTCPDAT_MAIN_CONNECT_TIME)
 200   1          {
 201   2              if ((STOE_GetIPAddr() & STOE_GetSubnetMask()) != (gtcpdat_Conns[id].Ip & STOE_GetSubnetMask()))
 202   2                  ETH_SendArpRequest(STOE_GetGateway());
 203   2              else
 204   2                  ETH_SendArpRequest(gtcpdat_Conns[id].Ip);
 205   2              gtcpdat_Conns[id].Timer = time;
 206   2          }
 207   1      } /* End of gtcpdat_MaintainConnection() */
 208          
 209          /*
 210           * ----------------------------------------------------------------------------
 211           * Function Name: gtcpdat_SendData()
 212           * Purpose: 
 213           * Params:
 214           * Returns:
 215           * Note:
 216           * ----------------------------------------------------------------------------
 217           */
 218          static void gtcpdat_SendData(U8_T id)
 219          {
 220   1          GTCPDAT_CONN *tcpConn = &gtcpdat_Conns[id];
 221   1      
 222   1      #if GS2W_ENABLE_FLOW_CONTROL
                  if (tcpConn->LastTxPktAck == 1 && tcpConn->TxDatLen > 3)
              #else
 225   1          if (tcpConn->LastTxPktAck == 1 && tcpConn->TxDatLen > 0)
 226   1      #endif
 227   1          {
 228   2              if (tcpConn->TxDatLen >= GTCPDAT_MAX_TCP_DATA_LEN)
 229   2              {
 230   3                  tcpConn->LastTxPktAck = 0;
 231   3      #if GS2W_ENABLE_FLOW_CONTROL
                          /* Fill in the length of payload */
                          tcpConn->TxBuf[1] = (U8_T)((GTCPDAT_MAX_TCP_DATA_LEN-3) >> 8);
                          tcpConn->TxBuf[2] = (U8_T)((GTCPDAT_MAX_TCP_DATA_LEN-3) & 0x00FF);
C51 COMPILER V9.05   GTCPDAT                                                               04/11/2012 16:47:00 PAGE 5   

                          tcpConn->TxSentLen = GTCPDAT_MAX_TCP_DATA_LEN;
              #else
 237   3                  tcpConn->TxSentLen = tcpConn->TxDatLen;
 238   3      #endif
 239   3                              printd("send to tcp 111, len = %u\r\n", tcpConn->TxSentLen);
 240   3                  TCPIP_TcpSend(tcpConn->TcpSocket, &tcpConn->TxBuf[0], tcpConn->TxSentLen, TCPIP_SEND_NOT_FINAL
             -);           
 241   3                  tcpConn->TxWaitTime = 0;
 242   3                  
 243   3              }
 244   2              else
 245   2              {
 246   3                  time = SWTIMER_Tick();
 247   3      
 248   3                  if (tcpConn->TxWaitTime == 0)
 249   3                  {
 250   4                      tcpConn->TxWaitTime = time;
 251   4                  }
 252   3                  else
 253   3                  {
 254   4                      if (time >= tcpConn->TxWaitTime)
 255   4                          elapse = time - tcpConn->TxWaitTime;
 256   4                      else
 257   4                          elapse = (0xFFFFFFFF - tcpConn->TxWaitTime) + time;
 258   4      
 259   4                      if (((elapse * SWTIMER_INTERVAL) >= gtcpdat_EthernetTxTimer))
 260   4                      {
 261   5                          tcpConn->LastTxPktAck = 0;
 262   5      #if GS2W_ENABLE_FLOW_CONTROL
                                   /* Fill in the length of payload */
                                  tcpConn->TxBuf[1] = (U8_T)((tcpConn->TxDatLen-3) >> 8);
                                  tcpConn->TxBuf[2] = (U8_T)((tcpConn->TxDatLen-3) & 0x00FF);
              #endif
 267   5                                      printd("send to tcp 222, len = %u\r\n", tcpConn->TxSentLen);
 268   5                          TCPIP_TcpSend(tcpConn->TcpSocket, &tcpConn->TxBuf[0], tcpConn->TxDatLen, TCPIP_SEND_NO
             -T_FINAL);        
 269   5                          tcpConn->TxWaitTime = 0;
 270   5                          tcpConn->TxSentLen = tcpConn->TxDatLen;
 271   5                      }
 272   4                  }
 273   3              }
 274   2          }
 275   1      } /* End of gtcpdat_SendData() */
 276          
 277          /*
 278           * ----------------------------------------------------------------------------
 279           * Function Name: gtcpdat_GetDataFromUr()
 280           * Purpose: 
 281           * Params:
 282           * Returns:
 283           * Note:
 284           * ----------------------------------------------------------------------------
 285           */
 286          static void gtcpdat_GetDataFromUr(U8_T id)
 287          {
 288   1          U8_T *pUpBuf;
 289   1          U16_T availCount, index;
 290   1          GTCPDAT_CONN *tcpConn = &gtcpdat_Conns[id];
 291   1      
 292   1          availCount = HSUR2_GetRxDmaAvailCount();
 293   1          if (availCount == 0 || tcpConn->TxDatLen >= GTCPDAT_TX_BUF_SIZE)
 294   1              return;
C51 COMPILER V9.05   GTCPDAT                                                               04/11/2012 16:47:00 PAGE 6   

 295   1      
 296   1          pUpBuf = &tcpConn->TxBuf[tcpConn->TxDatLen];
 297   1      
 298   1          if ((availCount+tcpConn->TxDatLen) >= GTCPDAT_TX_BUF_SIZE)
 299   1              availCount = GTCPDAT_TX_BUF_SIZE - tcpConn->TxDatLen;
 300   1      
 301   1          HSUR2_CopyUartToApp(pUpBuf, availCount);
 302   1          tcpConn->TxDatLen += availCount;
 303   1          tcpConn->UrRxBytes += availCount;
 304   1      
 305   1          if (availCount > 16)
 306   1              {
 307   2                      printd("uart recv [%u]: %bx %bx %bx %bx %bx %bx %bx %bx ... %bx %bx %bx %bx %bx %bx %bx %bx\r\n"
 308   2                              availCount, pUpBuf[0], pUpBuf[1], pUpBuf[2], pUpBuf[3], pUpBuf[4], pUpBuf[5], pUpBuf[6], pUpBuf[7],
*** ERROR C141 IN LINE 308 OF ..\src\mgs2wifi\gtcpdat.c: syntax error near 'availCount'
 309   2                                                      pUpBuf[availCount-8], pUpBuf[availCount-7], pUpBuf[availCount-6], pUpBuf[availCount-5], 
 310   2                                                      pUpBuf[availCount-4], pUpBuf[availCount-3], pUpBuf[availCount-2], pUpBuf[availCount-1]);
*** ERROR C141 IN LINE 310 OF ..\src\mgs2wifi\gtcpdat.c: syntax error near ')'
 311   2      
 312   2              }
 313   1              else
 314   1              {
 315   2                printd("uart recv [%u
*** ERROR C103 IN LINE 315 OF ..\src\mgs2wifi\gtcpdat.c: '<string>': unclosed string
*** ERROR C305 IN LINE 315 OF ..\src\mgs2wifi\gtcpdat.c: unterminated string/char const
 316   2                for 
*** ERROR C141 IN LINE 316 OF ..\src\mgs2wifi\gtcpdat.c: syntax error near 'for'
 317   2              }       
 318   2      
 319   2      
 320   2      
 321   2      
 322   2      } /* End of gtcpdat_GetDataFromUr() */
 323   2      
 324   2      /*
 325   2       * ----------------------------------------------------------------------------
 326   2       * Function Name: GTCPDAT_Init()
 327   2       * Purpose: Initialization
 328   2       * Params:
 329   2       * Returns:
 330   2       * Note:
 331   2       * ----------------------------------------------------------------------------
 332   2       */
 333   2      void GTCPDAT_Init(U16_T localPort)
 334   2      {
 335   2              U8_T    i;
 336   2      
 337   2              gtcpdat_TcpClient = 0;
 338   2      
 339   2              for (i = 0; i < GTCPDAT_MAX_CONNS; i++)
*** ERROR C202 IN LINE 339 OF ..\src\mgs2wifi\gtcpdat.c: 'i': undefined identifier
 340   2          {
 341   3                      gtcpdat_Conns[i].State = GTCPDAT_STATE_FREE;
*** ERROR C202 IN LINE 341 OF ..\src\mgs2wifi\gtcpdat.c: 'i': undefined identifier
 342   3              gtcpdat_Conns[i].UrRxBytes = 0;
*** ERROR C202 IN LINE 342 OF ..\src\mgs2wifi\gtcpdat.c: 'i': undefined identifier
 343   3              gtcpdat_Conns[i].UrTxBytes = 0;
*** ERROR C202 IN LINE 343 OF ..\src\mgs2wifi\gtcpdat.c: 'i': undefined identifier
 344   3              gtcpdat_Conns[i].TxDatLen = 0;
*** ERROR C202 IN LINE 344 OF ..\src\mgs2wifi\gtcpdat.c: 'i': undefined identifier
 345   3              gtcpdat_Conns[i].TxSentLen = 0;
*** ERROR C202 IN LINE 345 OF ..\src\mgs2wifi\gtcpdat.c: 'i': undefined identifier
C51 COMPILER V9.05   GTCPDAT                                                               04/11/2012 16:47:00 PAGE 7   

 346   3              gtcpdat_Conns[i].LastTxPktAck = 0;
*** ERROR C202 IN LINE 346 OF ..\src\mgs2wifi\gtcpdat.c: 'i': undefined identifier
 347   3      #if GS2W_ENABLE_FLOW_CONTROL                    
                      gtcpdat_Conns[i].FlowControlXonRx = TRUE;
                      gtcpdat_Conns[i].FlowControlModemStatus = HSUR2_GetModemStatus(TRUE);
                      gtcpdat_Conns[i].FlowControlModemCtrl = (HSUR2_GetModemControl() & 0x3);
              #endif
 352   3          }
 353   2      
 354   2              gtcpdat_InterAppId = TCPIP_Bind(GTCPDAT_NewConn, GTCPDAT_Event, GTCPDAT_Receive);
 355   2              
 356   2              if ((GCONFIG_GetNetwork() & GCONFIG_NETWORK_CLIENT) != GCONFIG_NETWORK_CLIENT)
 357   2              {       
 358   3                      /* unicast packet */
 359   3                      TCPIP_TcpListen(localPort, gtcpdat_InterAppId);
*** ERROR C202 IN LINE 359 OF ..\src\mgs2wifi\gtcpdat.c: 'localPort': undefined identifier
 360   3                      
 361   3                      printd("TCP data server init ok.\n\r");
 362   3              }
 363   2              else
 364   2              {
 365   3                      gtcpdat_TcpClient = 1;
 366   3              
 367   3                      printd("TCP data client init ok.\n\r"); 
 368   3              }
 369   2              
 370   2      
 371   2              gtcpdat_EthernetTxTimer = GCONFIG_GetEthernetTxTimer();
 372   2              gtcpdat_LastConnectTime = 0; //zwh.add 20120302
 373   2      
 374   2      } /* End of GTCPDAT_Init() */
 375   1      
 376   1      /*
 377   1       * ----------------------------------------------------------------------------
 378   1       * Function Name: GTCPDAT_NewConn
 379   1       * Purpose: 
 380   1       * Params:
 381   1       * Returns:
 382   1       * Note:
 383   1       * ----------------------------------------------------------------------------
 384   1       */
 385   1      U8_T GTCPDAT_NewConn(U32_T XDATA* pip, U16_T remotePort, U8_T socket)
*** ERROR C141 IN LINE 385 OF ..\src\mgs2wifi\gtcpdat.c: syntax error near 'U8_T'
 386   1      {
 387   2              U8_T    i;
 388   2      
 389   2              COUNTER_INC_CONNECT_TRY;           //zwh.add 20120302
 390   2              for (i = 0; i < GTCPDAT_MAX_CONNS; i++)
 391   2              {
 392   3                      if (gtcpdat_Conns[i].State == GTCPDAT_STATE_FREE)
 393   3                      {
 394   4                              gtcpdat_Conns[i].State = GTCPDAT_STATE_WAIT;
 395   4                              gtcpdat_Conns[i].Timer = SWTIMER_Tick();
 396   4                              gtcpdat_Conns[i].Ip = *pip;
 397   4                              gtcpdat_Conns[i].Port = remotePort;
 398   4                              gtcpdat_Conns[i].TcpSocket = socket;
 399   4                  gtcpdat_Conns[i].TxDatLen = 0;
 400   4                  gtcpdat_Conns[i].TxSentLen = 0;
 401   4                  gtcpdat_Conns[i].LastTxPktAck = 1;
 402   4                      //      printd("New TCP connection: id=%bu, remotePort=%u, socket=%bu\n\r", i, remotePort, socket);                     
 403   4                              return i;
 404   4                      }
C51 COMPILER V9.05   GTCPDAT                                                               04/11/2012 16:47:00 PAGE 8   

 405   3              }
 406   2              COUNTER_INC_CONNECT_FAILED;     //zwh.add 20120302
 407   2              return GTCPDAT_NO_NEW_CONN;
 408   2      
 409   2      } /* End of GTCPDAT_NewConn() */
 410   1      
 411   1      /*
 412   1       * ----------------------------------------------------------------------------
 413   1       * Function Name: GTCPDAT_Event
 414   1       * Purpose: 
 415   1       * Params:
 416   1       * Returns:
 417   1       * Note:
 418   1       * ----------------------------------------------------------------------------
 419   1       */
 420   1      void GTCPDAT_Event(U8_T id, U8_T event)
 421   1      {
 422   2          GTCPDAT_CONN *tcpConn = &gtcpdat_Conns[id];
 423   2      
 424   2              if (event == TCPIP_CONNECT_ACTIVE)
 425   2              {
 426   3                      if (gtcpdat_Conns[id].State == GTCPDAT_STATE_WAIT)
 427   3                      {
 428   4                              gtcpdat_Conns[id].State = GTCPDAT_STATE_CONNECTED;
 429   4                              GS2W_SetTaskState(GS2W_STATE_TCP_DATA_PROCESS);
 430   4                  /* Enable keep-alive */
 431   4                  TCPIP_TcpKeepAlive(gtcpdat_Conns[id].TcpSocket, TCPIP_KEEPALIVE_ON);
 432   4                              gtcpdat_Conns[id].LastTxPktAck = 1;
 433   4                              gtcpdat_Conns[id].TxDatLen = 0;
 434   4                              gtcpdat_Conns[id].TxWaitTime = 0;
 435   4                              gtcpdat_Conns[id].TxSentLen = 0;
 436   4      
 437   4                              COUNTER_INC_CONNECT_SUCCESS;    //zwh.add 20120302
 438   4                      }
 439   3              }
 440   2              else if (event == TCPIP_CONNECT_CANCEL)
 441   2              {
 442   3                      if (gtcpdat_Conns[id].State == GTCPDAT_STATE_CONNECTED)
 443   3                      {
 444   4                              gtcpdat_Conns[id].State = GTCPDAT_STATE_FREE;
 445   4                              GS2W_SetTaskState(GS2W_STATE_IDLE);     
 446   4      
 447   4                              gtcpdat_Conns[id].Timer = SWTIMER_Tick();       //zwh.add 20120302
 448   4                              COUNTER_INC_CONNECT_CLOSED;                                     //zwh.add 20120302
 449   4                      }
 450   3                      else if (gtcpdat_Conns[id].State == GTCPDAT_STATE_WAIT)
 451   3                      {
 452   4                              gtcpdat_Conns[id].State = GTCPDAT_STATE_FREE;
 453   4                              GS2W_SetTaskState(GS2W_STATE_IDLE);     
 454   4      
 455   4                              gtcpdat_Conns[id].Timer = SWTIMER_Tick();       //zwh.add 20120302
 456   4                              COUNTER_INC_CONNECT_FAILED;                                     //zwh.add 20120302
 457   4                      }
 458   3              }
 459   2              else if (event == TCPIP_CONNECT_XMIT_COMPLETE)
 460   2              {
 461   3                      tcpConn->LastTxPktAck = 1;
 462   3              if ( tcpConn->TxSentLen > 0)
 463   3              {
 464   4                  tcpConn->TxDatLen -= tcpConn->TxSentLen;
 465   4      #if GS2W_ENABLE_FLOW_CONTROL
                          if (tcpConn->TxDatLen > 0)
C51 COMPILER V9.05   GTCPDAT                                                               04/11/2012 16:47:00 PAGE 9   

                          {
                              tcpConn->TxBuf[0] = GTCPDAT_DATA_INDICATOR;
                              /* reserved the length field */
                              memcpy(&tcpConn->TxBuf[3], &tcpConn->TxBuf[tcpConn->TxSentLen], tcpConn->TxDatLen);
                              tcpConn->TxDatLen += 3;
                              gtcpdat_GetDataFromUr(id);
                          }
              #else
 475   4                  if (tcpConn->TxDatLen > 0)
 476   4                      memcpy(&tcpConn->TxBuf[0], &tcpConn->TxBuf[tcpConn->TxSentLen], tcpConn->TxDatLen);
 477   4                  gtcpdat_GetDataFromUr(id);
 478   4      #endif
 479   4                  tcpConn->TxSentLen = 0;
 480   4              }
 481   3              }
 482   2      } /* End of GTCPDAT_Event() */
 483   1      
 484   1      /*
 485   1       * ----------------------------------------------------------------------------
 486   1       * Function Name: GTCPDAT_Receive
 487   1       * Purpose: 
 488   1       * Params:
 489   1       * Returns:
 490   1       * Note:
 491   1       * ----------------------------------------------------------------------------
 492   1       */
 493   1      void GTCPDAT_Receive(U8_T XDATA* pData, U16_T length, U8_T id)
 494   1      {
 495   2              if (gtcpdat_Conns[id].State == GTCPDAT_STATE_CONNECTED)
 496   2              {
 497   3                      if (length <= GTCPDAT_MAX_TCP_RCV_DATA_LEN) // Is valid length
 498   3                      {
 499   4      #if GS2W_ENABLE_FLOW_CONTROL
              MoreTcpData:
                                      if (length <= 6 && *pData == GTCPDAT_FLOW_CONTROL_INDICATOR)
                                      {
                                              gtcpdat_HandleFlowControlPacket(pData, length, id);
                                      }
                                      else if (length > 3 && *pData == GTCPDAT_DATA_INDICATOR) 
                                      {
                              U16_T dataLen = (*(pData+1) << 8) + *(pData+2) + 3;
              
                              if (dataLen > length) 
                                  dataLen = length;
              
                                              HSUR2_XmitOutEnq((pData + 3), (dataLen - 3));
                                              gtcpdat_Conns[id].UrTxBytes += (dataLen - 3);
                              
                              length -= dataLen;
                              if (length > 0)
                              {
                                  /* point to the next packet header */
                                  pData += dataLen;
                                  goto MoreTcpData;
                              }
                                      }
              #else
 524   4                              HSUR2_XmitOutEnq(pData, length);
 525   4                              gtcpdat_Conns[id].UrTxBytes += length;
 526   4      #endif
 527   4                      }
 528   3              }       
C51 COMPILER V9.05   GTCPDAT                                                               04/11/2012 16:47:00 PAGE 10  

 529   2      } /* End of GTCPDAT_Receive() */
 530   1      
 531   1      #if GS2W_ENABLE_FLOW_CONTROL                    
              /*
               * ----------------------------------------------------------------------------
               * Function Name: gtcpdat_HandleFlowControlPacket
               * Purpose: 
               * Params:
               * Returns:
               * Note:
               * ----------------------------------------------------------------------------
               */
              void gtcpdat_HandleFlowControlPacket(U8_T XDATA* pData, U16_T length, U8_T id)
              {
                      U8_T command = *(pData + 3);
                      U8_T dat1;
                      U8_T dat2;
              
                      if (length >= 5)
                      {
                              dat1 = *(pData + 4);
              
                              if (length == 6)
                                      dat2 = *(pData + 5);
                      }
              
                      switch (command)
                      {
                              case IOCTL_SERIAL_GET_DTRRTS:
                          if (gtcpdat_Conns[id].LastTxPktAck == 1)
                          {
                              gtcpdat_Conns[id].LastTxPktAck = 0;
                              txBuf[0] = GTCPDAT_FLOW_CONTROL_INDICATOR;
                              txBuf[1] = 0;
                              txBuf[2] = 2;
                              txBuf[3] = IOCTL_SERIAL_GET_DTRRTS_REPLY;
                              txBuf[4] = HSUR2_GetModemControl();
                              TCPIP_TcpSend(gtcpdat_Conns[id].TcpSocket, &txBuf[0], 5, TCPIP_SEND_NOT_FINAL);
                          }
                                      break;
                              case IOCTL_SERIAL_GET_MODEM_CONTROL:
                                      if (gtcpdat_Conns[id].LastTxPktAck == 1)
                          {
                              gtcpdat_Conns[id].LastTxPktAck = 0;
                              txBuf[0] = GTCPDAT_FLOW_CONTROL_INDICATOR;
                              txBuf[1] = 0;
                              txBuf[2] = 2;
                              txBuf[3] = IOCTL_SERIAL_GET_MODEM_CONTROL_REPLY;
                              txBuf[4] = HSUR2_GetModemControl();
                              TCPIP_TcpSend(gtcpdat_Conns[id].TcpSocket, &txBuf[0], 5, TCPIP_SEND_NOT_FINAL);
                          }
                                      break;
                              case IOCTL_SERIAL_GET_MODEM_STATUS:
                                      if (gtcpdat_Conns[id].LastTxPktAck == 1)
                          {
                              gtcpdat_Conns[id].LastTxPktAck = 0;
                              txBuf[0] = GTCPDAT_FLOW_CONTROL_INDICATOR;
                              txBuf[1] = 0;
                              txBuf[2] = 2;
                              txBuf[3] = IOCTL_SERIAL_GET_MODEM_STATUS_REPLY;
                              txBuf[4] = HSUR2_GetModemStatus(TRUE);
                              TCPIP_TcpSend(gtcpdat_Conns[id].TcpSocket, &txBuf[0], 5, TCPIP_SEND_NOT_FINAL);
C51 COMPILER V9.05   GTCPDAT                                                               04/11/2012 16:47:00 PAGE 11  

                          }
                                      break;
                              case IOCTL_SERIAL_CLR_DTR:
                                      HSUR2_ClearDTR();
                                      break;
                              case IOCTL_SERIAL_CLR_RTS:
                                      HSUR2_ClearRTS();               
                                      break;
                              case IOCTL_SERIAL_SET_DTR:
                                      HSUR2_SetDTR();
                                      break;
                              case IOCTL_SERIAL_SET_RTS:
                                      HSUR2_SetRTS();
                                      break;
                              case IOCTL_SERIAL_SET_BAUD_RATE:                        
                          HSUR2_SetupPort(GCONFIG_GetBaudRate(dat1), dat2);
                                      break;
                              case IOCTL_SERIAL_SET_BREAK_OFF:
                                      dat1 = HSUR2_GetLineControl();
                                      HSUR2_SetLineControl(dat1 & 0xBF); // bit 6 - break control bit (1:on, 0:off)
                                      break;
                              case IOCTL_SERIAL_SET_BREAK_ON:
                                      dat1 = HSUR2_GetLineControl();
                                      HSUR2_SetLineControl(dat1 | 0x40); // bit 6 - break control bit (1:on, 0:off)
                                      break;
                              case IOCTL_SERIAL_SET_FIFO_CONTROL:
                                      HSUR2_SetFifoControl(dat1);
                                      break;
                              case IOCTL_SERIAL_SET_LINE_CONTROL:
                                      HSUR2_SetLineControl(dat1);
                                      break;
                              case IOCTL_SERIAL_SET_MODEM_CONTROL:
                                      HSUR2_SetModemControl(dat1);
                                      break;
                              case IOCTL_SERIAL_SET_XOFF:
                                      gtcpdat_Conns[id].FlowControlXonRx = FALSE;
                                      break;
                              case IOCTL_SERIAL_SET_XON:
                                      gtcpdat_Conns[id].FlowControlXonRx = TRUE;
                                      break;
                      case IOCTL_SERIAL_SET_HANDFLOW:
                          gtcpdat_SetFlowControl(dat1);
                                      break;
                              case IOCTL_SERIAL_XOFF_COUNTER:
                                      //...
                                      break;
              
                              default:
                                      printd("Unknown flow control command!\n\r");
                                      break;
                      }
              } /* End of gtcpdat_HandleFlowControlPacket() */
              
              /*
               *--------------------------------------------------------------------------------
               * void gtcpdat_SetFlowControl(U8_T)
               * Purpose: 
               * Params : fCtrl: the flow control to be set.
               * Returns: None.
               * Note   : None.
               *--------------------------------------------------------------------------------
               */
C51 COMPILER V9.05   GTCPDAT                                                               04/11/2012 16:47:00 PAGE 12  

              static void gtcpdat_SetFlowControl(U8_T fCtrl)
              {
                  switch (fCtrl)
                  {
                      case SERIAL_HANDFLOW_NONE:
                          HSUR2_AutoCtsRtsFlowCtrl(0);
                          HSUR2_AutoSoftwareFlowCtrl(0, 0, 0, 0, 0);
                          break;
                      case SERIAL_HANDFLOW_HW:
                          HSUR2_AutoCtsRtsFlowCtrl(1);
                          break;
                      case SERIAL_HANDFLOW_XON_XOFF:
                          HSUR2_AutoSoftwareFlowCtrl(1, (HSAFCSR_ASFCE_ENB), ASCII_XON, ASCII_XOFF, 0);
                          break;
                      default:
                          break;
                  }
              }
              #endif
 672   1      
 673   1      /*
 674   1       * ----------------------------------------------------------------------------
 675   1       * Function Name: GTCPDAT_GetTxBytes
 676   1       * Purpose: 
 677   1       * Params:
 678   1       * Returns:
 679   1       * Note:
 680   1       * ----------------------------------------------------------------------------
 681   1       */
 682   1      U32_T GTCPDAT_GetTxBytes(U8_T id)
 683   1      {
 684   1          if (id < GTCPDAT_MAX_CONNS)
 685   1              return gtcpdat_Conns[id].UrTxBytes;
 686   1      
 687   1          return 0;
 688   1      } /* End of GTCPDAT_GetTxBytes() */
 689          
 690          /*
 691           * ----------------------------------------------------------------------------
 692           * Function Name: GTCPDAT_GetRxBytes
 693           * Purpose: 
 694           * Params:
 695           * Returns:
 696           * Note:
 697           * ----------------------------------------------------------------------------
 698           */
 699          U32_T GTCPDAT_GetRxBytes(U8_T id)
 700          {
 701   1          if (id < GTCPDAT_MAX_CONNS)
 702   1              return gtcpdat_Conns[id].UrRxBytes;
 703   1      
 704   1          return 0;
 705   1      } /* End of GTCPDAT_GetRxBytes() */
 706          
 707          /*
 708           * ----------------------------------------------------------------------------
 709           * Function Name: GTCPDAT_GetTcpTxReady
 710           * Purpose: 
 711           * Params:
 712           * Returns:
 713           * Note:
 714           * ----------------------------------------------------------------------------
C51 COMPILER V9.05   GTCPDAT                                                               04/11/2012 16:47:00 PAGE 13  

 715           */
 716          U8_T GTCPDAT_GetTcpTxReady(U8_T id)
 717          {
 718   1          if (id < GTCPDAT_MAX_CONNS)
 719   1              return gtcpdat_Conns[id].LastTxPktAck;
 720   1      
 721   1          return 0;
 722   1      } /* End of GTCPDAT_GetTcpTxReady() */
 723          
 724          /*
 725           * ----------------------------------------------------------------------------
 726           * Function Name: gtcpdat_CheckAllConnStatusIdle
 727           * Purpose: 
 728           * Params:
 729           * Returns:
 730           * Note:
 731           * ----------------------------------------------------------------------------
 732           */
 733          static U8_T gtcpdat_CheckAllConnStatusIdle(void)
 734          {
 735   1          U8_T id;
 736   1      
 737   1          for (id = 0; id < GTCPDAT_MAX_CONNS; id++)
 738   1          {
 739   2              if (gtcpdat_Conns[id].State != GTCPDAT_STATE_FREE)
 740   2                  return 0;
 741   2          }
 742   1      
 743   1          return 1;
 744   1      } /* End of gtcpdat_CheckAllConnStatusIdle() */
 745          
 746          /*
 747           * ----------------------------------------------------------------------------
 748           * Function Name: GTCPDAT_ConnClose
 749           * Purpose: 
 750           * Params:
 751           * Returns:
 752           * Note:
 753           * ----------------------------------------------------------------------------
 754           */
 755          void GTCPDAT_ConnClose(U32_T remoteIp, U16_T port)
 756          {
 757   1          U8_T id;
 758   1      
 759   1          for (id = 0; id < GTCPDAT_MAX_CONNS; id++)
 760   1          {
 761   2              if (gtcpdat_Conns[id].State == GTCPDAT_STATE_CONNECTED)
 762   2              {
 763   3                  if (gtcpdat_Conns[id].Ip == remoteIp && gtcpdat_Conns[id].Port == port)
 764   3                  {
 765   4                                  gtcpdat_Conns[id].State = GTCPDAT_STATE_FREE;
 766   4                      TCPIP_TcpClose(gtcpdat_Conns[id].TcpSocket);
 767   4                      if (gtcpdat_CheckAllConnStatusIdle())
 768   4                          GS2W_SetTaskState(GS2W_STATE_IDLE);
 769   4                  }
 770   3              }
 771   2          }
 772   1      
 773   1      } /* End of GTCPDAT_ConnClose() */
 774          
 775          /* End of gtcpdat.c */

C51 COMPILATION COMPLETE.  0 WARNING(S),  14 ERROR(S)
