C51 COMPILER V9.05   DHCPS                                                                 03/02/2012 01:21:43 PAGE 1   


C51 COMPILER V9.05, COMPILATION OF MODULE DHCPS
OBJECT MODULE PLACED IN .\dhcps.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\src\mdhcps\dhcps.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X8020) INCDIR(
                    -..\src\main;..\src\mcpu;..\src\mswdma;..\src\uart0;..\src\mmstimer;..\src\mwif;..\src\madapter;..\src\mtcpip;..\src\mpin
                    -g;..\src\mpppoe;..\src\si2c;..\src\mdnsc;..\src\mconsole;..\src\mtelnet;..\src\meeprom;..\src\mmac;..\src\mdhcpc;..\src\
                    -mhttp;..\src\mgs2wifi;..\src\mhsuart;..\src\msmtpc;..\src\web_page;..\src\mdhcps;..\src\mdebug;..\src\counter) DEFINE(Ru
                    -ntimeCodeAt32KH) VARBANKING DEBUG PRINT(.\dhcps.lst) OBJECT(.\dhcps.obj)

line level    source

   1          
   2          
   3          /* INCLUDE FILE DECLARATIONS */
   4          #include <string.h>
   5          #include "main.h"
   6          #include "dhcps.h"
   7          #include "adapter.h"
   8          #include "tcpip.h"
   9          #include "uip.h"
  10          #include "mstimer.h"
  11          #include "dma.h"
  12          #include "stoe.h"
  13          
  14          #if (INCLUDE_DHCP_SERVER)
  15          /* NAMING CONSTANT DECLARATIONS */
  16          /* GLOBAL VARIABLES DECLARATIONS */
  17          U8_T DHCPS_EnableFlag = 0xFF;
  18          U32_T DHCPS_IpPoolStartAddr = 0;
  19          U32_T DHCPS_IpPoolEndAddr = 0;
  20          U32_T DHCPS_SubnetMask = 0;
  21          U32_T DHCPS_Router = 0;
  22          U32_T DHCPS_LeaseTime = 0;
  23          
  24          /* STATIC VARIABLE DECLARATIONS */
  25          static DHCPS_CONN     dhcps_Conn;
  26          static DHCPS_CONNINFO dhcps_ConnsInfo[DHCPS_MAX_STA_CONNS];
  27          static DHCPS_POOL         dhcps_IpPoolTable[DHCPS_MAX_IP_POOL_NUM];
  28          static DHCPS_HEADER       dhcps_Buffer;
  29          static U8_T               dhcps_AppIfId;
  30          static U8_T               dhcps_CurrConnId;
  31          static U16_T          dhcps_RcvPktLength;
  32          static U16_T          dhcps_RcvPktLeftLength;
  33          static DHCPS_HEADER   *dhcps_PktHeaderPtr;
  34          static U8_T *dhcps_pOpt;
  35          static U8_T dhcps_StartIpOffset=0;
  36          static U16_T dhcps_MaxIpPool=0;
  37          static U32_T dhcps_LastTimeTick = 0;
  38          static U8_T dhcps_Init=0;
  39          static U32_T dhcps_DnsServer = 0;
  40          
  41          /* LOCAL SUBPROGRAM DECLARATIONS */
  42          static void dhcps_SendPkt(U8_T pktType);
  43          static void dhcps_ReceiveMessage(void);
  44          static U8_T dhcps_FindConnInfoIndex(U8_T* pMacAddr);
  45          static U8_T *dhcps_GetOption(U8_T *optMsg, U8_T msgCode, U8_T *vLen, U16_T);
  46          static U8_T dhcps_FindIpPoolByIpAddr(U32_T ipAddr);
  47          static U8_T dhcps_FindIpPoolByMacAddr(U8_T* pMacAddr);
  48          static U8_T dhcps_CreateNewElementToIpPool(U32_T ipAddr, U8_T* pMacAddr);
  49          
  50          /*
  51           *--------------------------------------------------------------------------------
C51 COMPILER V9.05   DHCPS                                                                 03/02/2012 01:21:43 PAGE 2   

  52           * Function Name: DHCPS_Init
  53           * Purpose :
  54           * Params  :
  55           * Returns :
  56           * Note    :
  57           *--------------------------------------------------------------------------------
  58           */
  59          BOOL DHCPS_Init(U32_T startIp, U32_T endIp, U32_T netmask, U32_T gateway, U16_T lease, U8_T status)
  60          {
  61   1              U8_T index;
  62   1      
  63   1          if (dhcps_Init)
  64   1              return TRUE;
  65   1      
  66   1          dhcps_Init = 1;
  67   1          dhcps_Conn.State = DHCPS_STATE_IDLE;
  68   1          for (index = 0; index < DHCPS_MAX_STA_CONNS; index++)
  69   1              dhcps_ConnsInfo[index].State = DHCPS_STATE_IDLE;
  70   1      
  71   1          /* Initialize DHCP Server IP Pool Table */
  72   1          for (index = 0; index < DHCPS_MAX_IP_POOL_NUM; index++) 
  73   1          {
  74   2              dhcps_IpPoolTable[index].Occupy = 0;
  75   2          }
  76   1      
  77   1          dhcps_AppIfId = TCPIP_Bind(DHCPS_NewConnHandle, DHCPS_EventHandle, DHCPS_ReceiveHandle);
  78   1          TCPIP_UdpListen(DHCPS_SERVER_PORT, dhcps_AppIfId); /* Enable DHCP Server Listen Port */
  79   1      
  80   1          DHCPS_IpPoolStartAddr = startIp;
  81   1          DHCPS_IpPoolEndAddr = endIp;
  82   1          DHCPS_SubnetMask = netmask;
  83   1          DHCPS_Router = gateway;
  84   1          DHCPS_LeaseTime = lease;
  85   1      
  86   1          dhcps_MaxIpPool = DHCPS_IpPoolEndAddr - DHCPS_IpPoolStartAddr + 1;
  87   1          if (dhcps_MaxIpPool > DHCPS_MAX_IP_POOL_NUM)
  88   1              dhcps_MaxIpPool = DHCPS_MAX_IP_POOL_NUM;
  89   1              
  90   1          DHCPS_EnableFlag = status;        
  91   1      
  92   1              return TRUE;
  93   1      
  94   1      } /* End of DHCPS_Init() */
  95          
  96          /*
  97           *--------------------------------------------------------------------------------
  98           * Function Name: DHCPS_GetServerSettings
  99           * Purpose :
 100           * Params  :
 101           * Returns :
 102           * Note    :
 103           *--------------------------------------------------------------------------------
 104           */
 105          void DHCPS_GetServerSettings(U32_T *pStartIp, U32_T *pEndIp, U32_T *pNetmask, U32_T *pGateway, U16_T *pLea
             -se)
 106          {
 107   1          if (!pStartIp || !pEndIp || !pNetmask || !pGateway || !pLease)
 108   1              return;
 109   1      
 110   1          *pStartIp = DHCPS_IpPoolStartAddr;
 111   1          *pEndIp = DHCPS_IpPoolEndAddr;
 112   1          *pNetmask = DHCPS_SubnetMask;
C51 COMPILER V9.05   DHCPS                                                                 03/02/2012 01:21:43 PAGE 3   

 113   1          *pGateway = DHCPS_Router;
 114   1          *pLease = DHCPS_LeaseTime;
 115   1          
 116   1      } /* End of DHCPS_GetServerSettings() */
 117          
 118          /*
 119           *--------------------------------------------------------------------------------
 120           * Function Name: DHCPS_SetServerSettings
 121           * Purpose :
 122           * Params  :
 123           * Returns :
 124           * Note    :
 125           *--------------------------------------------------------------------------------
 126           */
 127          void DHCPS_SetServerSettings(U32_T startIp, U32_T endIp, U32_T netmask, U32_T gateway, U16_T lease)
 128          {
 129   1          if (!dhcps_Init)
 130   1              return;
 131   1      
 132   1          DHCPS_IpPoolStartAddr = startIp;
 133   1          DHCPS_IpPoolEndAddr = endIp; 
 134   1          DHCPS_SubnetMask = netmask;
 135   1          DHCPS_Router = gateway;
 136   1          DHCPS_LeaseTime = lease;
 137   1      
 138   1          dhcps_MaxIpPool = DHCPS_IpPoolEndAddr - DHCPS_IpPoolStartAddr + 1;
 139   1          if (dhcps_MaxIpPool > DHCPS_MAX_IP_POOL_NUM)
 140   1              dhcps_MaxIpPool = DHCPS_MAX_IP_POOL_NUM;
 141   1          
 142   1      } /* End of DHCPS_SetServerSettings() */
 143          
 144          /*
 145           *--------------------------------------------------------------------------------
 146           * Function Name: DHCPS_SetServerStatus
 147           * Purpose :
 148           * Params  :
 149           * Returns :
 150           * Note    :
 151           *--------------------------------------------------------------------------------
 152           */
 153          void DHCPS_SetServerStatus(U8_T status)
 154          {
 155   1          DHCPS_EnableFlag = status;
 156   1      } /* End of DHCPS_SetServerStatus() */
 157          
 158          /*
 159           *--------------------------------------------------------------------------------
 160           * Function Name: DHCPS_GetServerStatus
 161           * Purpose :
 162           * Params  :
 163           * Returns :
 164           * Note    :
 165           *--------------------------------------------------------------------------------
 166           */
 167          U8_T DHCPS_GetServerStatus(void)
 168          {
 169   1          return DHCPS_EnableFlag ;
 170   1      } /* End of DHCPS_GetServerStatus() */
 171          
 172          /*
 173           *--------------------------------------------------------------------------------
 174           * Function Name: DHCPS_SetDnsServer
C51 COMPILER V9.05   DHCPS                                                                 03/02/2012 01:21:43 PAGE 4   

 175           * Purpose :
 176           * Params  :
 177           * Returns :
 178           * Note    :
 179           *--------------------------------------------------------------------------------
 180           */
 181          void DHCPS_SetDnsServer(U32_T dnsSrv)
 182          {
 183   1          dhcps_DnsServer = dnsSrv;
 184   1      } /* End of DHCPS_SetDnsServer() */
 185          
 186          /*
 187           * ----------------------------------------------------------------------------
 188           * Function Name: DHCPS_NewConnHandle
 189           * Purpose: 
 190           * Params:
 191           * Returns:
 192           * Note:
 193           * ----------------------------------------------------------------------------
 194           */
 195          U8_T DHCPS_NewConnHandle(U32_T XDATA* pip, U16_T remotePort, U8_T socket)
 196          {
 197   1              if (!DHCPS_EnableFlag || DHCPS_CLIENT_PORT != remotePort) /* frame not from DHCP client. */
 198   1                      return TCPIP_NO_NEW_CONN;
 199   1      
 200   1              if (dhcps_Conn.State == DHCPS_STATE_IDLE)
 201   1              {
 202   2                      dhcps_Conn.State = DHCPS_STATE_ACTIVE;
 203   2                      dhcps_Conn.Ip = *pip;
 204   2                      dhcps_Conn.SocketId = socket;
 205   2      
 206   2                      return 0;
 207   2              }
 208   1      
 209   1              return TCPIP_NO_NEW_CONN;
 210   1      } /* End of DHCPS_NewConnHandle() */
 211          
 212          /*
 213           * ----------------------------------------------------------------------------
 214           * void DHCPS_EventHandle(U8_T connId, U8_T event)
 215           * Purpose: 
 216           * Params:
 217           * Returns:
 218           * Note:
 219           * ----------------------------------------------------------------------------
 220           */
 221          void DHCPS_EventHandle(U8_T connId, U8_T event)
 222          {
 223   1              if (!DHCPS_EnableFlag || connId != 0)
 224   1                      return;
 225   1      
 226   1              if (event == TCPIP_CONNECT_CANCEL)
 227   1              {
 228   2                      dhcps_Conn.State = DHCPS_STATE_IDLE;
 229   2              }
 230   1      } /* End of DHCPS_EventHandle() */
 231          
 232          /*
 233           * ----------------------------------------------------------------------------
 234           * void DHCPS_ReceiveHandle(U8_T XDATA* pData, U16_T length, U8_T connId)
 235           * Purpose: 
 236           * Params:
C51 COMPILER V9.05   DHCPS                                                                 03/02/2012 01:21:43 PAGE 5   

 237           * Returns:
 238           * Note:
 239           * ----------------------------------------------------------------------------
 240           */
 241          void DHCPS_ReceiveHandle(U8_T XDATA *pData, U16_T length, U8_T connId)
 242          {
 243   1          if (!DHCPS_EnableFlag)
 244   1              return;
 245   1      
 246   1              if ((connId != 0) || (dhcps_Conn.State == DHCPS_STATE_IDLE)) /* connection has not be created */
 247   1              {
 248   2                      TCPIP_UdpClose(dhcps_Conn.SocketId);
 249   2                      return;
 250   2              }
 251   1      
 252   1              dhcps_RcvPktLength = length;
 253   1              dhcps_RcvPktLeftLength = length;
 254   1              dhcps_PktHeaderPtr = (DHCPS_HEADER*)pData;
 255   1      
 256   1              dhcps_ReceiveMessage();
 257   1          TCPIP_UdpClose(dhcps_Conn.SocketId);
 258   1          dhcps_Conn.State = DHCPS_STATE_IDLE;
 259   1      
 260   1      } /* End of DHCPS_ReceiveHandle() */
 261          
 262          /*
 263           *--------------------------------------------------------------------------------
 264           * Function Name: dhcps_ReceiveMessage
 265           * Purpose :
 266           * Params  :
 267           * Returns :
 268           * Note    :
 269           *--------------------------------------------------------------------------------
 270           */
 271          void dhcps_ReceiveMessage(void)
 272          {
 273   1              DHCPS_HEADER *pDhcpMsg;
 274   1              U8_T         *optMsg, ipPoolIndex, dhcpMsgType = 0;
 275   1              U8_T         index, rcvChAddr[6], foundInIpPool = 0;
 276   1              U32_T        requestIp = 0;
 277   1      
 278   1              pDhcpMsg = dhcps_PktHeaderPtr; /* DHCP payload pointer */
 279   1      
 280   1              /* calculate the options item length */
 281   1              dhcps_RcvPktLeftLength -= DHCPS_OFFSET_OPTIONS;
 282   1              dhcps_pOpt = pDhcpMsg->Options;
 283   1      
 284   1              if (pDhcpMsg->Op == DHCP_C_TO_S)
 285   1              {
 286   2                      for (index = 0 ; index < DHCPS_MAC_ADDRESS_LEN; index++)
 287   2                              rcvChAddr[index] = pDhcpMsg->ChAddr[index];
 288   2      
 289   2                      /* check the received MAC address within ChAddr, except 00-00-00-00-00-00 & FF-FF-FF-FF-FF-FF */
 290   2                      if ((rcvChAddr[0]==0 && rcvChAddr[1]==0 && rcvChAddr[2]==0 && rcvChAddr[3]==0 &&
 291   2                              rcvChAddr[4]==0 && rcvChAddr[5]==0)||(rcvChAddr[0]==0xFF && rcvChAddr[1]==0xFF &&
 292   2                              rcvChAddr[2]==0xFF && rcvChAddr[3]==0xFF && rcvChAddr[4]==0xFF && rcvChAddr[5]==0xFF))
 293   2                      {
 294   3                              return;
 295   3                      }
 296   2      
 297   2                      dhcps_CurrConnId = dhcps_FindConnInfoIndex(rcvChAddr);
 298   2                      if (dhcps_CurrConnId == 0xFF)
C51 COMPILER V9.05   DHCPS                                                                 03/02/2012 01:21:43 PAGE 6   

 299   2              {
 300   3                              return;
 301   3              }
 302   2      
 303   2                      dhcps_ConnsInfo[dhcps_CurrConnId].Timer = DHCPS_CONNECTION_TIMEOUT;
 304   2                      if (dhcps_ConnsInfo[dhcps_CurrConnId].State == DHCPS_STATE_ACTIVE)
 305   2                      {
 306   3                              dhcps_ConnsInfo[dhcps_CurrConnId].Xid = pDhcpMsg->Xid;
 307   3                      }
 308   2                      else /* DHCPS_OFFER_STATE */
 309   2                      {
 310   3                              if (dhcps_ConnsInfo[dhcps_CurrConnId].Xid != pDhcpMsg->Xid)
 311   3                              {
 312   4                                      dhcps_ConnsInfo[dhcps_CurrConnId].Xid = pDhcpMsg->Xid;
 313   4                                      dhcps_ConnsInfo[dhcps_CurrConnId].State = DHCPS_STATE_ACTIVE;
 314   4                              }
 315   3                      }
 316   2      
 317   2                      if ((*(dhcps_pOpt + 0) == 0x63) && (*(dhcps_pOpt + 1) == 0x82) &&
 318   2                              (*(dhcps_pOpt + 2) == 0x53) && (*(dhcps_pOpt + 3) == 0x63))
 319   2                      {
 320   3                              dhcps_pOpt += 4;
 321   3                              dhcps_RcvPktLeftLength -= 4;
 322   3      
 323   3                              index = 0;
 324   3                              optMsg = dhcps_GetOption(dhcps_pOpt, DHCPS_OPTION_MSG_TYPE, &index, dhcps_RcvPktLeftLength);
 325   3                              if (optMsg && index == 1)
 326   3                                      dhcpMsgType = *optMsg;
 327   3      
 328   3                              if ((dhcps_ConnsInfo[dhcps_CurrConnId].State == DHCPS_STATE_ACTIVE) && (dhcpMsgType != DHCPS_DISCOVER))
 329   3                              {
 330   4                                      if (dhcpMsgType == DHCPS_REQUEST)
 331   4                                      {
 332   5                          dhcps_ConnsInfo[dhcps_CurrConnId].State = DHCPS_STATE_OFFER;
 333   5                                      }
 334   4                                      else
 335   4                                      {
 336   5                                              return;
 337   5                                      }
 338   4                              }
 339   3                  else if ((dhcps_ConnsInfo[dhcps_CurrConnId].State == DHCPS_STATE_OFFER) && (dhcpMsgType != DHC
             -PS_REQUEST))
 340   3                              {
 341   4                                      if (dhcpMsgType == DHCPS_DISCOVER)
 342   4                                      {
 343   5                                              dhcps_ConnsInfo[dhcps_CurrConnId].State = DHCPS_STATE_ACTIVE;
 344   5                                      }
 345   4                                      else if (dhcpMsgType == DHCPS_DECLINE || dhcpMsgType == DHCPS_RELEASE)
 346   4                                      {
 347   5                                              ipPoolIndex = dhcps_FindIpPoolByMacAddr(rcvChAddr);
 348   5                                              if (ipPoolIndex < dhcps_MaxIpPool)
 349   5                                              {
 350   6                                                      dhcps_IpPoolTable[ipPoolIndex].IpAddr = 0xFFFFFFFF;
 351   6                                                      dhcps_IpPoolTable[ipPoolIndex].MacAddr[0] = 0xFF;
 352   6                              dhcps_IpPoolTable[ipPoolIndex].Lease = 0;
 353   6                              dhcps_IpPoolTable[ipPoolIndex].Occupy = 0;
 354   6                                              }
 355   5                                              return;
 356   5                                      }
 357   4                                      else
 358   4                      {
 359   5                                              return;
C51 COMPILER V9.05   DHCPS                                                                 03/02/2012 01:21:43 PAGE 7   

 360   5                      }
 361   4                              }
 362   3      
 363   3                              index = 0;
 364   3                              optMsg = dhcps_GetOption(dhcps_pOpt, DHCPS_OPTION_REQ_IPADDR, &index, dhcps_RcvPktLeftLength);
 365   3                              if ((pDhcpMsg->CiAddr) || (optMsg && index == DHCPS_IP_ADDRESS_LEN))
 366   3                              {
 367   4                                      /* check the ip address requested by dhcp client */
 368   4                      if (pDhcpMsg->CiAddr)
 369   4                          requestIp = pDhcpMsg->CiAddr;
 370   4                      else
 371   4                                          requestIp = *(U32_T*)optMsg;
 372   4      
 373   4                                      if (((requestIp & DHCPS_SubnetMask) == (DHCPS_IpPoolStartAddr & DHCPS_SubnetMask)) &&
 374   4                                              (requestIp >= DHCPS_IpPoolStartAddr) && (requestIp <= DHCPS_IpPoolEndAddr))
 375   4                                      {
 376   5                           /* find index of ip pool by ip address */
 377   5                                              ipPoolIndex = dhcps_FindIpPoolByIpAddr(requestIp);
 378   5                                              if (ipPoolIndex < dhcps_MaxIpPool) /* had found in ip pool */
 379   5                                              {
 380   6                              if (!memcmp(rcvChAddr, dhcps_IpPoolTable[ipPoolIndex].MacAddr, 6))
 381   6                                                      {
 382   7                                                              foundInIpPool = 1;
 383   7                                                      }
 384   6                                                      else
 385   6                                                      {
 386   7                                  /* request the ip address but different host */
 387   7                                                              requestIp = 0;
 388   7                                                              ipPoolIndex = dhcps_FindIpPoolByMacAddr(rcvChAddr);
 389   7                                                              if (ipPoolIndex < dhcps_MaxIpPool)
 390   7                                                                      foundInIpPool = 1;
 391   7                                                      }
 392   6                                              }
 393   5                                              else
 394   5                                              {
 395   6                                                      ipPoolIndex = dhcps_FindIpPoolByMacAddr(rcvChAddr);
 396   6                                                      if (ipPoolIndex < dhcps_MaxIpPool)
 397   6                                                      {
 398   7                                                              requestIp = 0;
 399   7                                                              foundInIpPool = 1;
 400   7                                                      }
 401   6                                              }
 402   5                                      }
 403   4                                      else
 404   4                                      {
 405   5                          if (dhcpMsgType == DHCPS_REQUEST)
 406   5                          {
 407   6                              dhcps_SendPkt(DHCPS_NAK);
 408   6                              return;
 409   6                          }
 410   5                                              requestIp = 0;
 411   5                          /* Check mac address existed in IP Pool table */
 412   5                          ipPoolIndex = dhcps_FindIpPoolByMacAddr(rcvChAddr);
 413   5                          if (ipPoolIndex < dhcps_MaxIpPool)
 414   5                              foundInIpPool = 1;
 415   5                                      }
 416   4                              }
 417   3                              else
 418   3                              {
 419   4                                      ipPoolIndex = dhcps_FindIpPoolByMacAddr(rcvChAddr);
 420   4                                      if (ipPoolIndex < dhcps_MaxIpPool)
 421   4                                              foundInIpPool = 1;
C51 COMPILER V9.05   DHCPS                                                                 03/02/2012 01:21:43 PAGE 8   

 422   4                              }
 423   3      
 424   3                              if (!foundInIpPool)
 425   3                              {
 426   4                                      ipPoolIndex = dhcps_CreateNewElementToIpPool(requestIp, rcvChAddr); /* add a new element to IP pool*/
 427   4                                      if (ipPoolIndex >= dhcps_MaxIpPool) /* new item created failed, no resource */
 428   4                      {
 429   5                                              return;
 430   5                      }
 431   4                              }
 432   3                  else
 433   3                  {
 434   4                      dhcps_IpPoolTable[ipPoolIndex].Lease = DHCPS_LeaseTime * 60 * SWTIMER_COUNT_SECOND;
 435   4                  }
 436   3      
 437   3                              dhcps_ConnsInfo[dhcps_CurrConnId].IpPoolIndex = ipPoolIndex;
 438   3      
 439   3                              if (dhcps_ConnsInfo[dhcps_CurrConnId].State == DHCPS_STATE_ACTIVE)
 440   3                              {
 441   4                                      dhcps_SendPkt(DHCPS_OFFER);
 442   4                                      dhcps_ConnsInfo[dhcps_CurrConnId].State = DHCPS_STATE_OFFER;
 443   4                              }
 444   3                              else /* DHCPS_OFFER_STATE */
 445   3                              {
 446   4                                      dhcps_SendPkt(DHCPS_ACK);
 447   4                              }
 448   3                      }
 449   2              }
 450   1      } /* End of dhcps_ReceiveMessage() */
 451          
 452          /*
 453           *--------------------------------------------------------------------------------
 454           * Function Name: dhcps_FindConnInfoIndex
 455           * Purpose :
 456           * Params  :
 457           * Returns :
 458           * Note    :
 459           *--------------------------------------------------------------------------------
 460           */
 461          U8_T dhcps_FindConnInfoIndex(U8_T* pMacAddr)
 462          {
 463   1              U8_T index;
 464   1      
 465   1              for (index = 0; index < DHCPS_MAX_STA_CONNS; index++)
 466   1              {
 467   2                      if (dhcps_ConnsInfo[index].State == DHCPS_STATE_IDLE)
 468   2                              continue;
 469   2      
 470   2              if (!memcmp((char *)dhcps_ConnsInfo[index].ChMacAddr, (char *)pMacAddr, DHCPS_MAC_ADDRESS_LEN))
 471   2                  return index;
 472   2              }
 473   1      
 474   1              /* not found in table */
 475   1              for (index = 0; index < DHCPS_MAX_STA_CONNS; index++)
 476   1              {
 477   2                      if (dhcps_ConnsInfo[index].State == DHCPS_STATE_IDLE)
 478   2                      {
 479   3                              dhcps_ConnsInfo[index].State = DHCPS_STATE_ACTIVE;
 480   3                  memcpy((char *)dhcps_ConnsInfo[index].ChMacAddr, (char *)pMacAddr, DHCPS_MAC_ADDRESS_LEN);
 481   3                              return index;
 482   3                      }
 483   2              }
C51 COMPILER V9.05   DHCPS                                                                 03/02/2012 01:21:43 PAGE 9   

 484   1      
 485   1              return 0xFF;
 486   1      } /* End of dhcps_FindConnInfoIndex() */
 487          
 488          /*
 489           *--------------------------------------------------------------------------------
 490           * Function Name: U8_T* dhcps_GetOption(void)
 491           * Purpose :
 492           * Params  :
 493           * Returns :
 494           * Note    :
 495           *--------------------------------------------------------------------------------
 496           */
 497          U8_T *dhcps_GetOption(U8_T *optMsg, U8_T msgCode, U8_T *vLen, U16_T maxLen)
 498          {
 499   1              U8_T    len, *optMsgEnd;
 500   1          
 501   1              optMsgEnd = optMsg + maxLen;
 502   1              while(*optMsg != DHCPS_OPTION_END && optMsg <= optMsgEnd) /* first to parse the msg type */
 503   1              {
 504   2                      if (*optMsg == msgCode)
 505   2                      {
 506   3                              *vLen = *(optMsg + 1);
 507   3                              optMsg += 2;
 508   3                              return optMsg;
 509   3                      }
 510   2                      else
 511   2                      {
 512   3                              len = *(optMsg + 1);
 513   3                              optMsg += (len + 2);
 514   3                      }
 515   2              }
 516   1      
 517   1              return 0;
 518   1      } /* End of dhcps_GetOption() */
 519          
 520          /*
 521           *--------------------------------------------------------------------------------
 522           * Function Name: dhcps_SendPkt
 523           * Purpose :
 524           * Params  :
 525           * Returns :
 526           * Note    :
 527           *--------------------------------------------------------------------------------
 528           */
 529          void dhcps_SendPkt(U8_T pktType)
 530          {
 531   1              DHCPS_HEADER*   pDhcpMsg;
 532   1              U8_T XDATA*             pMacAddr = MAC_GetMacAddr();
 533   1              U8_T XDATA*             pRcvBuf = TCPIP_GetRcvBuffer();
 534   1              U16_T                   length = DHCPS_OFFSET_OPTIONS;
 535   1              U16_T                   headerLen, tmpShort, totalLen;
 536   1      
 537   1              uip_udpip_hdr XDATA*    pUdpHeader;
 538   1      
 539   1              pDhcpMsg = &dhcps_Buffer;
 540   1              DMA_Grant((U8_T*)&dhcps_Buffer, (U8_T*)dhcps_PktHeaderPtr, dhcps_RcvPktLength);
 541   1      
 542   1              pDhcpMsg->Op = DHCP_S_TO_C;
 543   1              pDhcpMsg->CiAddr = 0;
 544   1          if (DHCPS_NAK != pktType)
 545   1              pDhcpMsg->YiAddr = dhcps_IpPoolTable[dhcps_ConnsInfo[dhcps_CurrConnId].IpPoolIndex].IpAddr;
C51 COMPILER V9.05   DHCPS                                                                 03/02/2012 01:21:43 PAGE 10  

 546   1      
 547   1              /* Add magic cookie bytes */
 548   1              dhcps_pOpt = &pDhcpMsg->Options;
 549   1              *(dhcps_pOpt + 0) = 0x63;
 550   1              *(dhcps_pOpt + 1) = 0x82;
 551   1              *(dhcps_pOpt + 2) = 0x53;
 552   1              *(dhcps_pOpt + 3) = 0x63;
 553   1              dhcps_pOpt += 4;
 554   1              length += 4;
 555   1      
 556   1              /* Add DHCPS_OPTION_MSG_TYPE options */
 557   1              *(dhcps_pOpt + 0) = DHCPS_OPTION_MSG_TYPE;
 558   1              *(dhcps_pOpt + 1) = 1; /* length */
 559   1              *(dhcps_pOpt + 2) = pktType;
 560   1              dhcps_pOpt += 3;
 561   1              length += 3;
 562   1      
 563   1              /* Add DHCPS_OPTION_SERVER_ID option */
 564   1              *(dhcps_pOpt + 0) = DHCPS_OPTION_SERVER_ID;
 565   1              *(dhcps_pOpt + 1) = 4; /* length */
 566   1              *((U32_T*)(dhcps_pOpt + 2)) = STOE_GetIPAddr();
 567   1              dhcps_pOpt += 6;
 568   1              length += 6;
 569   1      
 570   1          if (DHCPS_NAK != pktType)
 571   1          {
 572   2              /* Add DHCPS_OPTION_LEASE_TIME options */
 573   2                  *(dhcps_pOpt + 0) = DHCPS_OPTION_LEASE_TIME;
 574   2                  *(dhcps_pOpt + 1) = 4; /* length */
 575   2                  *((U32_T*)(dhcps_pOpt + 2)) = ((U32_T)DHCPS_LeaseTime * 60); /* 1 day */
 576   2                  dhcps_pOpt += 6;
 577   2                  length += 6;
 578   2      
 579   2              /* Add DHCPS_OPTION_SUBNET_MASK option */
 580   2              *(dhcps_pOpt + 0) = DHCPS_OPTION_SUBNET_MASK;
 581   2              *(dhcps_pOpt + 1) = 4; /* length */
 582   2              *((U32_T*)(dhcps_pOpt + 2)) = DHCPS_SubnetMask;
 583   2              dhcps_pOpt += 6;
 584   2              length += 6;
 585   2      
 586   2              /* Add DHCPS_OPTION_ROUTER option */
 587   2              *(dhcps_pOpt + 0) = DHCPS_OPTION_ROUTER;
 588   2              *(dhcps_pOpt + 1) = 4; /* length */
 589   2              *((U32_T*)(dhcps_pOpt + 2)) = DHCPS_Router;
 590   2              dhcps_pOpt += 6;
 591   2              length += 6;
 592   2      
 593   2              /* Add DHCPS_OPTION_DNS_SERVER option */
 594   2              *(dhcps_pOpt + 0) = DHCPS_OPTION_DNS_SERVER;
 595   2              *(dhcps_pOpt + 1) = 4; /* length */
 596   2              *((U32_T*)(dhcps_pOpt + 2)) = dhcps_DnsServer;
 597   2              dhcps_pOpt += 6;
 598   2              length += 6;
 599   2          }
 600   1      
 601   1              /* Add DHCPS_OPTION_END option */
 602   1              *(dhcps_pOpt + 0) = DHCPS_OPTION_END;
 603   1              length++;
 604   1      
 605   1              headerLen = (U16_T)dhcps_PktHeaderPtr - (U16_T)pRcvBuf;
 606   1              totalLen = length + headerLen;
 607   1      
C51 COMPILER V9.05   DHCPS                                                                 03/02/2012 01:21:43 PAGE 11  

 608   1      #if STOE_TRANSPARENT
 609   1              pRcvBuf[0] = 0xFF;
 610   1              pRcvBuf[1] = 0xFF;
 611   1              pRcvBuf[2] = 0xFF;
 612   1              pRcvBuf[3] = 0xFF;
 613   1              pRcvBuf[4] = 0xFF;
 614   1              pRcvBuf[5] = 0xFF;
 615   1              pRcvBuf[DHCPS_MAC_ADDRESS_LEN] = pMacAddr[0];
 616   1              pRcvBuf[DHCPS_MAC_ADDRESS_LEN +1] = pMacAddr[1];
 617   1              pRcvBuf[DHCPS_MAC_ADDRESS_LEN +2] = pMacAddr[2];
 618   1              pRcvBuf[DHCPS_MAC_ADDRESS_LEN +3] = pMacAddr[3];
 619   1              pRcvBuf[DHCPS_MAC_ADDRESS_LEN +4] = pMacAddr[4];
 620   1              pRcvBuf[DHCPS_MAC_ADDRESS_LEN +5] = pMacAddr[5];
 621   1      
 622   1              /* ip header */
 623   1              pUdpHeader = (uip_udpip_hdr XDATA*)(pRcvBuf + ETH_HEADER_LEN);
 624   1              tmpShort = totalLen - ETH_HEADER_LEN;
 625   1      #else
                      /* ip header */
                      pUdpHeader = (uip_udpip_hdr XDATA*)pRcvBuf;
                      tmpShort = totalLen;
              #endif
 630   1      
 631   1              pUdpHeader->len[0] = (U8_T)(tmpShort >> 8);
 632   1              pUdpHeader->len[1] = (U8_T)tmpShort;
 633   1              pUdpHeader->ipchksum = 0;
 634   1              pUdpHeader->destipaddr[0] = 0xFFFF;
 635   1              pUdpHeader->destipaddr[1] = 0xFFFF;
 636   1      
 637   1              uip_gethostaddr(pUdpHeader->srcipaddr);
 638   1      
 639   1              /* udp header */
 640   1              tmpShort = pUdpHeader->srcport;
 641   1              pUdpHeader->srcport = pUdpHeader->destport;
 642   1              pUdpHeader->destport = tmpShort;
 643   1              pUdpHeader->udplen = length + 8;
 644   1              pUdpHeader->udpchksum = 0;
 645   1      
 646   1              TCPIP_SetXmitLength(totalLen);
 647   1      
 648   1              uip_appdata = (U8_T*)&dhcps_Buffer;
 649   1      
 650   1              ETH_Send(headerLen);
 651   1              uip_slen = 0;
 652   1      
 653   1      } /* End of dhcps_SendPkt() */
 654          
 655          /*
 656           *--------------------------------------------------------------------------------
 657           * Function Name: dhcps_FindIpPoolByIpAddr
 658           * Purpose :
 659           * Params  :
 660           * Returns :
 661           * Note    :
 662           *--------------------------------------------------------------------------------
 663           */
 664          U8_T dhcps_FindIpPoolByIpAddr(U32_T ipAddr)
 665          {
 666   1              U8_T    index;
 667   1      
 668   1              for (index = 0; index < dhcps_MaxIpPool; index++)
 669   1              {
C51 COMPILER V9.05   DHCPS                                                                 03/02/2012 01:21:43 PAGE 12  

 670   2                      if (dhcps_IpPoolTable[index].Occupy != 0 && (dhcps_IpPoolTable[index].IpAddr == ipAddr))
 671   2                              return index;
 672   2              }
 673   1         
 674   1              return 0xFF;
 675   1      } /* End of dhcps_FindIpPoolByIpAddr() */
 676          
 677          /*
 678           *--------------------------------------------------------------------------------
 679           * Function Name: dhcps_FindIpPoolByMacAddr
 680           * Purpose :
 681           * Params  :
 682           * Returns :
 683           * Note    :
 684           *--------------------------------------------------------------------------------
 685           */
 686          U8_T dhcps_FindIpPoolByMacAddr(U8_T* pMacAddr)
 687          {
 688   1              U8_T index;
 689   1      
 690   1              for (index = 0; index < dhcps_MaxIpPool; index++)
 691   1              {
 692   2                      if (dhcps_IpPoolTable[index].Occupy != 0 &&
 693   2                  !memcmp((char *)dhcps_IpPoolTable[index].MacAddr, (char *)pMacAddr, DHCPS_MAC_ADDRESS_LEN))
 694   2                  return index;
 695   2              }
 696   1      
 697   1              return 0xFF;
 698   1      } /* End of dhcps_FindIpPoolByMacAddr() */
 699          
 700          /*
 701           *--------------------------------------------------------------------------------
 702           * Function Name: dhcps_CreateNewElementToIpPool
 703           * Purpose :
 704           * Params  :
 705           * Returns :
 706           * Note    :
 707           *--------------------------------------------------------------------------------
 708           */
 709          U8_T dhcps_CreateNewElementToIpPool(U32_T ipAddr, U8_T* pMacAddr)
 710          {
 711   1          U8_T index, wrapCnt;
 712   1      
 713   1          wrapCnt = 0;
 714   1              for (index = 0; index < dhcps_MaxIpPool; index++)
 715   1              {
 716   2                      if (dhcps_IpPoolTable[index].Occupy == 0)
 717   2                      {
 718   3                              if (ipAddr != 0)
 719   3                              {
 720   4                                      dhcps_IpPoolTable[index].IpAddr = ipAddr;
 721   4                              }
 722   3                              else
 723   3                              {
 724   4                      do 
 725   4                      {
 726   5                                          dhcps_IpPoolTable[index].IpAddr = DHCPS_IpPoolStartAddr + dhcps_StartIpOffset++;
 727   5                          /* skip xxx.xxx.xxx.0 and xxx.xxx.xxx.255 */
 728   5                          if (!(dhcps_IpPoolTable[index].IpAddr & 0x000000FF))
 729   5                          {
 730   6                              dhcps_IpPoolTable[index].IpAddr = DHCPS_IpPoolStartAddr + dhcps_StartIpOffset++;
 731   6                          }
C51 COMPILER V9.05   DHCPS                                                                 03/02/2012 01:21:43 PAGE 13  

 732   5                          else if ((dhcps_IpPoolTable[index].IpAddr & 0x000000FF) == 0x000000FF)
 733   5                          {
 734   6                             dhcps_StartIpOffset += 2;
 735   6                             dhcps_IpPoolTable[index].IpAddr = DHCPS_IpPoolStartAddr + dhcps_StartIpOffset;
 736   6                          }
 737   5                          /* Wrapped */
 738   5                          if (dhcps_StartIpOffset >= dhcps_MaxIpPool)
 739   5                          {
 740   6                              wrapCnt++;
 741   6                              dhcps_StartIpOffset = 0;
 742   6                          }
 743   5      
 744   5                      } while (wrapCnt < 2 && dhcps_FindIpPoolByIpAddr(dhcps_IpPoolTable[index].IpAddr) != 0xFF)
             -;
 745   4                              }
 746   3      
 747   3                  dhcps_IpPoolTable[index].Lease = DHCPS_LeaseTime * 60 * SWTIMER_COUNT_SECOND;
 748   3                              dhcps_IpPoolTable[index].Occupy = 1;
 749   3                  memcpy(dhcps_IpPoolTable[index].MacAddr, pMacAddr, DHCPS_MAC_ADDRESS_LEN);
 750   3      
 751   3                              return index;
 752   3                      }
 753   2              }
 754   1      
 755   1              return 0xFF;
 756   1      } /* End of dhcps_CreateNewElementToIpPool() */
 757          
 758          /*
 759           *--------------------------------------------------------------------------------
 760           * Function Name: DHCPS_StateCheck
 761           * Purpose :
 762           * Params  :
 763           * Returns :
 764           * Note    :
 765           *--------------------------------------------------------------------------------
 766           */
 767          void DHCPS_ConnsCheck(void)
 768          {
 769   1              U8_T    index;
 770   1              U32_T   elapse, timeoutTick;
 771   1      
 772   1              if (!dhcps_Init || !DHCPS_EnableFlag)
 773   1          {
 774   2              dhcps_LastTimeTick = SWTIMER_Tick();
 775   2                      return;
 776   2          }
 777   1      
 778   1          timeoutTick = SWTIMER_Tick();
 779   1          if (timeoutTick >= dhcps_LastTimeTick)
 780   1              elapse = timeoutTick - dhcps_LastTimeTick;
 781   1          else
 782   1              elapse = (0xFFFFFFFF - dhcps_LastTimeTick) + timeoutTick;
 783   1      
 784   1          dhcps_LastTimeTick = timeoutTick;
 785   1      
 786   1              for (index = 0; index < DHCPS_MAX_STA_CONNS; index++)
 787   1              {
 788   2                      if (dhcps_ConnsInfo[index].State == DHCPS_STATE_IDLE)
 789   2                              continue;
 790   2      
 791   2                      if (elapse > dhcps_ConnsInfo[index].Timer)
 792   2              {
C51 COMPILER V9.05   DHCPS                                                                 03/02/2012 01:21:43 PAGE 14  

 793   3                  dhcps_ConnsInfo[index].Timer = 0;
 794   3                              dhcps_ConnsInfo[index].State = DHCPS_STATE_IDLE;
 795   3              }
 796   2              else
 797   2              {
 798   3                  dhcps_ConnsInfo[index].Timer -= elapse;
 799   3              }
 800   2              }
 801   1      
 802   1          /* mantain the allocated IP table */
 803   1              for (index = 0; index < dhcps_MaxIpPool; index++)
 804   1              {
 805   2                      if (dhcps_IpPoolTable[index].Occupy != 0)
 806   2                      {
 807   3                  if (elapse > dhcps_IpPoolTable[index].Lease)
 808   3                  {
 809   4                      dhcps_IpPoolTable[index].Lease = 0;
 810   4                                  dhcps_IpPoolTable[index].Occupy = 0;
 811   4                  }
 812   3                  else
 813   3                      dhcps_IpPoolTable[index].Lease -= elapse;
 814   3                      }
 815   2              }
 816   1      
 817   1      } /* End of DHCPS_StateCheck() */
 818          
 819          #endif /* INCLUDE_DHCP_SERVER */
 820          
 821          /* End of dhcpc.c */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6573    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   1011     135
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
