C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 1   


C51 COMPILER V9.05, COMPILATION OF MODULE MWIOCTL
OBJECT MODULE PLACED IN .\mwioctl.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\src\mwif\mwioctl.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X8020) INCDIR(
                    -..\src\main;..\src\mcpu;..\src\mswdma;..\src\uart0;..\src\mmstimer;..\src\mwif;..\src\madapter;..\src\mtcpip;..\src\mpin
                    -g;..\src\mpppoe;..\src\si2c;..\src\mdnsc;..\src\mconsole;..\src\mtelnet;..\src\meeprom;..\src\mmac;..\src\mdhcpc;..\src\
                    -mhttp;..\src\mgs2wifi;..\src\mhsuart;..\src\msmtpc;..\src\web_page;..\src\mdhcps;..\src\mdebug;..\src\counter) DEFINE(Ru
                    -ntimeCodeAt32KH) VARBANKING DEBUG PRINT(.\mwioctl.lst) OBJECT(.\mwioctl.obj)

line level    source

   1          /*
   2           ******************************************************************************
   3           *     Copyright (c) 2010       ASIX Electronic Corporation      All rights reserved.
   4           *
   5           *     This is unpublished proprietary source code of ASIX Electronic Corporation
   6           *
   7           *     The copyright notice above does not evidence any actual or intended
   8           *     publication of such source code.
   9           ******************************************************************************
  10           */
  11          /*=============================================================================
  12           * Module Name: wioctl.c
  13           * Purpose:
  14           * Author:
  15           * Date:
  16           * Notes:
  17           * $Log: wioctl.c,v $
  18           *=============================================================================
  19           */
  20          
  21          /* INCLUDE FILE DECLARATIONS */
  22          #include "ax22000.h"
  23          #include "mwioctl.h"
  24          #include <string.h>
  25          #if IO_CPU_TYPE /***** Begin of IO_CPU_TYPE, Below are for MCPU use *****/
  26          #include "uart0.h"
  27          #include "printd.h"
  28          #include "mcpu.h"
  29          #include "stoe.h"
  30          #else                   /***** Middle of IO_CPU_TYPE, Below are for WCPU use *****/
              #include <stdio.h>
              #include "uart.h"
              #include "wcpu.h"
              #include "mac.h"
              #include "hw.h"
              #include "pcib.h"
              #include "mgr.h"
              #include "wifi.h"
              #include "wpsave.h"
              #include "supplicant.h"
              #include "delay.h"
              #endif                  /***** End of IO_CPU_TYPE macro *****/
  43          
  44          #if IO_CPU_TYPE
  45            #if (MAC_ARBIT_MODE & MAC_ARBIT_WIFI)
  46              #define IO_SHOWCMD                                          0       // show the command detail byte by byte
  47          
  48                  #include "mwifapp.h"
  49            #else
                  #define IO_SHOWCMD                                          0       // always 0  
                #endif
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 2   

  52          #else /* for WiFi CPU */
                  #define IO_SHOWCMD                                          0
              #endif
  55          
  56          /* GLOBAL VARIABLES DECLARATIONS */
  57          U8_T XDATA      IO_RxBuf[MAX_IO_RX_BUFFER_SIZE] = {0};
  58          U16_T XDATA     IO_RxHead;
  59          U16_T XDATA     IO_RxTail;
  60          //U8_T XDATA    IO_CmdFlag = 0;
  61          
  62          #if IO_CPU_TYPE /***** Begin of IO_CPU_TYPE, Below are for MCPU use *****/
  63            #if (MAC_ARBIT_MODE & MAC_ARBIT_WIFI)
  64          U8_T XDATA      IO_WifiRFEnable = 0;
  65          U8_T XDATA      IO_WifiBasebandMode = 1; /* 802.11b+g mode*/
  66          U8_T XDATA      IO_WifiNetworkMode = 1; /* 802.11 ad hoc mode */
  67          U8_T const FAR  IO_WiFiSupportedCh[] =
  68          {0/*auto*/,1,2,3,4,5,6,7,8,9,10,11,36,40,44,48,149,153,157,161,165};
  69          U8_T XDATA      IO_WiFiSupportedChBufSize = sizeof (IO_WiFiSupportedCh);
  70          U8_T XDATA      IO_WifiChannel = 11; /* channel = 11 */
  71          U8_T XDATA      IO_WiFiSsid[33] = {'A','X','2','2','0','x','x',' ','D','e','m','o',' ','F','i','r','m','w','a',
             -'r','e'};
  72          U8_T XDATA      IO_WifiSsidLen = 21;
  73          U8_T XDATA      IO_WiFiTxRate = 0; /* auto */
  74          U8_T const FAR  IO_WiFiSupportTxRate[] =
  75          {0/*auto*/,2/*1M*/,4/*2M*/,11/*5.5M*/,22/*11M*/,12/*6M*/,18,24,36,48,72,96,108};
  76          U8_T XDATA      IO_WiFiTxPowerLevel = 0; /* default 100% */
  77          U8_T XDATA      IO_GBProtection = 0; /* auto */
  78          U8_T XDATA      IO_PreambleMode = 0; /* auto */
  79          U16_T XDATA     IO_BcnInterval = 100; /* 100 ms */
  80          U16_T XDATA     IO_RtsThreshold = 2432; /* bytes */
  81          U8_T XDATA      IO_AutoPowerCtrl = 1; /* on */
  82          SISRVY_T XDATA  IO_SiteSurveyTable[20]; /* max num = 20 */
  83          U8_T XDATA      IO_FoundBssNum = 0;
  84          U8_T XDATA      IO_JbssIndex = 0xff;
  85          U8_T XDATA      IO_SiteSurveyStatusFlag = 0; /*0:nothing, 1:to start sisrvy, 1:had finish*/
  86          U8_T XDATA      IO_EncryptMode = 0; /* 0:disable, 1:wep64, 2:wep128, 3:tkip, 4:aes */
  87          U8_T XDATA      IO_WepKeyIndex = 0;
  88          U8_T XDATA      IO_WepKeyLength = 0; /* 0:64 bits, 1:128 bits*/
  89          U8_T XDATA      IO_Wep64Key[4][5] = {0x12,0x34,0x56,0x78,0x90, 0x09,0x87,0x65,0x43,0x21,
  90          0xA1,0xB2,0xC3,0xD4,0xE5,0x01, 0x23,0x45,0x67,0x89};
  91          U8_T XDATA      IO_Wep128Key[4][13] = {
  92          0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
  93          0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a,
  94          0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
  95          0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34};
  96          U8_T XDATA      IO_PreShareKey[64] = {'1','2','3','4','5','6','7','8'};
  97          U8_T XDATA      IO_PreShareKeyLen = 8;
  98            #endif /* (MAC_ARBIT_MODE & MAC_ARBIT_WIFI) */
  99          #else                   /***** Middle of IO_CPU_TYPE, Below are for WCPU use *****/
              U8_T XDATA      IO_SiteSurveyFromMcpu = 0;
              U8_T XDATA      IO_ScanFromMcpu = 0;
              #endif                  /***** End of IO_CPU_TYPE macro *****/
 103          
 104          /* LOCAL VARIABLES DECLARATIONS */
 105          static U8_T     XDATA   io_TxBuf[MAX_IO_TX_BUFFER_SIZE] = {0};
 106          
 107          /************************************************************/
 108          /* LOCAL SUBPROGRAM DECLARATIONS */
 109          #if IO_CPU_TYPE /***** Begin of IO_CPU_TYPE, Below are for MCPU use *****/
 110            #if (MAC_ARBIT_MODE & MAC_ARBIT_WIFI)
 111          static void io_ScanReportAck(void);
 112          static void io_SensitivityTestReportACK(void);
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 3   

 113          static void io_WlanDebug1Resp(void);
 114            #endif /* (MAC_ARBIT_MODE & MAC_ARBIT_WIFI) */
 115          #else                   /***** Middle of IO_CPU_TYPE, Below are for WCPU use *****/
              static void io_ResetAck(void);
              static void io_ScanAck(void);
              static void io_SiteSurveyAck(void);
              static void io_JoinBssAck(void);
              static void io_SsidAckRW(U8_T type, U8_T len, U8_T XDATA* pReg);
              static void io_OperateModeAckRW(U8_T type, U8_T value);
              static void io_ChannelAckRW(U8_T type, U8_T value);
              static void io_NetworkModeAckRW(U8_T type, U8_T value);
              static void io_SetMulticastMacAck(void);
              static void io_WiFiMacAckRW(U8_T type, U8_T XDATA* pReg);
              static void io_RadioOnOffAck(U8_T state);
              static void io_BgProtectionRespRW(U8_T rw, U8_T state);
              static void io_EncryptionAckRW(U8_T type, U8_T value);
              static void io_OpenSysAckRW(U8_T type, U8_T value);
              static void io_Wep64KeyAckRW(U8_T type, U8_T XDATA* pReg);
              static void io_Wep128KeyAckRW(U8_T type, U8_T XDATA* pReg);
              static void io_WepKeyIndexKeyRW(U8_T type, U8_T value);
              static void io_TkipAesAckRW(U8_T type, U8_T len, U8_T XDATA* pReg);
              static void io_FragmentThresholdAckRW(U8_T type, U8_T XDATA* pValue);
              static void io_RtsIntervalAckRW(U8_T type, U8_T XDATA* pValue);
              static void io_PreambleAckRW(U8_T type, U8_T value);
              static void io_TxGainRW(U8_T rw, U8_T txGain);
              static void io_BeaconIntervalAckRW(U8_T type, U8_T* pValue);
              static void io_CountryRegionAckRW(U8_T type, U16_T value);
              static void io_AtimIntervalAckRW(U8_T type, U8_T XDATA* pValue);
              static void io_TxDataRateRW(U8_T rw, U8_T txRate);
              static void io_AutoPowerCtrlRW(U8_T rw, U8_T state);
              static void io_AutoPowerCtrlDetailW(void);
              static void io_RoamingRW(U8_T rw, U8_T state);
              static void io_WifiMultimediaSetRW(U8_T rw, U8_T value);
              static void io_ListenIntervalRW(U8_T rw, U16_T value);
              static void io_MinContentionWindowRW(U8_T rw, U16_T value);
              static void io_MaxContentionWindowRW(U8_T rw, U16_T value);
              static void io_ShowRssiResp(U8_T rssi);
              static void io_PayloadLenAddInWifiRW(U8_T rw, U8_T value);
              static void io_RetainLlcInWifiRW(U8_T rw, U8_T value);
              static void io_2LlcInWiFiVlanPacketRW(U8_T rw, U8_T value);
              static void io_TrafficProfileRW(U8_T rw, U8_T state);
              static void io_TxDefaultPowerLevelRW(U8_T rw, U8_T level);
              static void io_QueuePrioritySetRW(U8_T rw, U8_T priority);
              static void io_SelfCtsRW(U8_T rw, U8_T value);
              static void io_BssidR(U8_T *bssid);
              static void io_WifiIpR(U8_T *wifiIp);
              static void io_WifiDriverVerR(U8_T *pVer);
              #if MASS_PRODUCTION
              static void io_ContinuousTxAck(U8_T mode);
              static void io_SensitivityTestAck(U8_T *ptr);
              static void io_SensitivityTestReportAck(void);
              #endif
              static U8_T io_SfrIO(U8_T rw, U8_T index, U8_T XDATA* pValue);
              static void io_SfrAckRW(U8_T type, U8_T value);
              static void io_WcpuIndirectAckRW(U8_T type, U8_T len, U8_T XDATA* pReg);
              static void io_MiibIndirectAckRW(U8_T type, U8_T len, U8_T XDATA* pReg);
              static void io_PcibIndirectRegAckRW(U8_T type, U8_T len, U8_T XDATA* pReg);
              static void io_PciConfigAckRW(U8_T type, U8_T XDATA* pReg);
              static void io_WiFiRegAckRW(U8_T type, U8_T XDATA* pValue);
              static void io_WlanPktFilterAckRW(U8_T rw, U8_T type, U16_T subtype, U8_T XDATA* pBssid);
              static void io_SynthesizerSetAck(void);
              static void io_RetryAckRW(U8_T type, U8_T value);
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 4   

              static void io_Gpio0RW(U8_T rw, U8_T value);
              static void io_Gpio1RW(U8_T rw, U8_T value);
              static void io_Gpio2RW(U8_T rw, U8_T value);
              static void io_Gpio3RW(U8_T rw, U8_T value);
              static U8_T io_WifiRegIO(U8_T rw, U16_T index, U32_T XDATA* pValue);
              #endif                  /***** End of IO_CPU_TYPE macro *****/
 181          #if IO_SHOWCMD
              static void io_ShowCmd(U8_T TxRx, U8_T XDATA* pReg);
              #endif
 184          
 185          /*
 186           * ----------------------------------------------------------------------------
 187           * Function Name: IO_Init
 188           * Purpose: To initiate "MCPU / WCPU interface" module
 189           * Params: none
 190           * Returns: none
 191           * Note: none
 192           * ----------------------------------------------------------------------------
 193           */
 194          void IO_Init(void)
 195          {
 196   1              IO_RxHead = 0;
 197   1              IO_RxTail = 0;
 198   1      #if MWIF_TASK_HOOKUP
 199   1          MWIFAPP_TaskInit();
 200   1      #endif
 201   1      }
 202          
 203          /*
 204           * ----------------------------------------------------------------------------
 205           * Function Name: IO_CmdError
 206           * Purpose: To send a error message to MCPU when MCPU sent a wrong command
 207           * Params: none
 208           * Returns: none
 209           * Note: none
 210           * ----------------------------------------------------------------------------
 211           */
 212          void IO_CmdError(void)
 213          {
 214   1      #if (!IO_CPU_TYPE || (MAC_ARBIT_MODE & MAC_ARBIT_WIFI))
 215   1              MWIF_Send(IO_ERROR_COMMAND, NULL, 0);
 216   1      #endif
 217   1      }       /* End of IO_CmdError */
 218          
 219          /************************************************************************/
 220          #if IO_CPU_TYPE /***** Begin of IO_CPU_TYPE, Below are for MCPU use *****/
 221            #if (MAC_ARBIT_MODE & MAC_ARBIT_WIFI)
 222          /*
 223           * ----------------------------------------------------------------------------
 224           * Function Name: IO_CmdParsing
 225           * Purpose: To parse the command it gets and do the reaction
 226           * Params: none
 227           * Returns: 0x00 - IO_COMMAND_DONE
 228           *          0xFF - IO_COMMAND_ERROR
 229           * Note: none
 230           * ----------------------------------------------------------------------------
 231           */
 232          U8_T IO_CmdParsing(U8_T* pbuf)
 233          {
 234   1              U8_T XDATA      i, temp;
 235   1      
 236   1              if ((pbuf[0] + pbuf[1]) != 0xFF)
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 5   

 237   1                      return IO_COMMAND_ERROR;
 238   1              {
 239   2                      switch (pbuf[0])
 240   2                      {
 241   3                      case IO_MCPU_WCPU_READY:
 242   3                              MCPU_WcpuReady = 1;
 243   3                              IO_NoticeWcpu(IO_MCPU_WCPU_READY_ACK, NULL, 0);
 244   3                              printd ("Rcv WCPU Ready Command.\n");
 245   3                              break;
 246   3                      case IO_MCPU_WCPU_READY_ACK:
 247   3                              MCPU_WcpuReady = 1;
 248   3                              printd ("Rcv MCPU Ready ACK Command.\n");
 249   3                              break;
 250   3                      case IO_WCPU_RESET_ACK:
 251   3                              printd ("Rcv WCPU Reset ACK Command.\n");
 252   3                              // need to add reset wcpu function.........
 253   3                              break;
 254   3                      case IO_MCPU_WCPU_CONNECT:
 255   3                              STOE_ConnectState |= STOE_WIRELESS_LINK;
 256   3                              IO_NoticeWcpu(IO_MCPU_WCPU_CONNECT_ACK, NULL, 0);
 257   3                              printd ("Rcv WiFi Connect Command.\n");
 258   3      
 259   3                              MWIFAPP_TaskIOWiFiConnect();
 260   3                              break;
 261   3                      case IO_MCPU_WCPU_DISCONNECT:
 262   3                              STOE_ConnectState &= ~STOE_WIRELESS_LINK;
 263   3                              temp = 1;
 264   3                              IO_NoticeWcpu(IO_MCPU_WCPU_DISCONNECT_RESP, &temp, 1);
 265   3                              printd ("Rcv WiFi Disconnect Command.\n");
 266   3                              break;
 267   3                      case IO_SCAN_ACK:
 268   3                              if (pbuf[2])
 269   3                                      return IO_COMMAND_ERROR;
 270   3                              break;
 271   3                      case IO_SCAN_REPORT:
 272   3                              if (!pbuf[2])
 273   3                                      return IO_COMMAND_ERROR;
 274   3                              if (pbuf[3] == 1)
 275   3                              {
 276   4                                      printd ("Start a new IBSS\n\r");
 277   4                              }
 278   3                              else if (pbuf[3] == 2)
 279   3                              {
 280   4                                      printd ("Rescan\n\r");
 281   4                              }
 282   3                              else if (pbuf[3] == 3)
 283   3                              {
 284   4                                      printd ("BSS is found:");
 285   4                                      for (i = 0; i < 72; i++)
 286   4                                      {
 287   5                                              if ((i%16) == 0)
 288   5                                              {
 289   6                                                      printd ("\n\r%2bx ", pbuf[i + 4]);
 290   6                                              }
 291   5                                              else
 292   5                                              {
 293   6                                                      printd ("%2bx ", pbuf[i + 4]);
 294   6                                              }
 295   5                                      }
 296   4                                      printd ("\n\r");
 297   4                              }
 298   3                              else
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 6   

 299   3                              {
 300   4                                      return IO_COMMAND_ERROR;
 301   4                              }
 302   3                              io_ScanReportAck();
 303   3                              break;
 304   3                      case IO_SITE_SURVEY_ACK:
 305   3                              if (pbuf[2])
 306   3                                      return IO_COMMAND_ERROR;
 307   3                              break;
 308   3                      case IO_SITE_SURVEY_REPORT:
 309   3                              if (!pbuf[2])
 310   3                                      return IO_COMMAND_ERROR;
 311   3                              if (pbuf[2] == 1)
 312   3                              {
 313   4                                      if (pbuf[3] == 0)
 314   4                                              printd ("\n\rIt can not find any BSS.\n\r");
 315   4                                      else
 316   4                                              return IO_COMMAND_ERROR;
 317   4                              }
 318   3                              else
 319   3                              {
 320   4                                      U8_T XDATA*             point;
 321   4      
 322   4                                      if (pbuf[2] < 11)
 323   4                                      {
 324   5                                              return IO_COMMAND_ERROR;
 325   5                                      }
 326   4      
 327   4                                      if (pbuf[3] == 0)
 328   4                                      {
 329   5                                              printd ("\nid BSSID             SSID                             TYPE CH  RSSI SECURITY\n\r");
 330   5                                      }
 331   4                                      printd ("\r%02bx %02bx-%02bx-%02bx-%02bx-%02bx-%02bx ", pbuf[3], pbuf[4], pbuf[5],
 332   4                                                      pbuf[6], pbuf[7], pbuf[8], pbuf[9]);
 333   4                                      temp = pbuf[2] - 12;
 334   4      
 335   4                                      IO_FoundBssNum = pbuf[3];
 336   4                                      point = IO_SiteSurveyTable[IO_FoundBssNum].Bssid;
 337   4                                      point[0] = pbuf[4];
 338   4                                      point[1] = pbuf[5];
 339   4                                      point[2] = pbuf[6];
 340   4                                      point[3] = pbuf[7];
 341   4                                      point[4] = pbuf[8];
 342   4                                      point[5] = pbuf[9];
 343   4      
 344   4                                      IO_SiteSurveyTable[IO_FoundBssNum].SsidLen = temp;
 345   4                                      point = IO_SiteSurveyTable[IO_FoundBssNum].Ssid;
 346   4                                      
 347   4                                      if (pbuf[15])
 348   4                                      {
 349   5                                              for (i = 0; i < temp; i++)
 350   5                                              {
 351   6                                                      printd ("%c", pbuf[15 + i]);
 352   6                                                      point[i] = pbuf[15 + i];
 353   6                                              }
 354   5                                              
 355   5                                              temp = 33 - temp;
 356   5                                              for (i = 0; i < temp; i++)
 357   5                                              {
 358   6                                                      printd (" ");
 359   6                                              }
 360   5                                      }
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 7   

 361   4                                      else
 362   4                                      {
 363   5                                              printd ("                                 ");
 364   5                                      }
 365   4      
 366   4                                      if (pbuf[10])
 367   4                                      {
 368   5                                              printd ("ap   %03bu %02bx   %s\n\r", pbuf[11], pbuf[12], pbuf[13] ? "yes":"no");
 369   5                                      }
 370   4                                      else
 371   4                                      {
 372   5                                              printd ("sta  %03bu %02bx   %s\n\r", pbuf[11], pbuf[12], pbuf[13] ? "yes":"no");
 373   5                                      }
 374   4      
 375   4                                      IO_SiteSurveyTable[IO_FoundBssNum].InfraMode = pbuf[10];
 376   4                                      IO_SiteSurveyTable[IO_FoundBssNum].Channel = pbuf[11];
 377   4                                      IO_SiteSurveyTable[IO_FoundBssNum].Rssi = pbuf[12];
 378   4                                      IO_SiteSurveyTable[IO_FoundBssNum].SecurFlag = pbuf[13];
 379   4                                      IO_FoundBssNum++;
 380   4      
 381   4                                      IO_SiteSurveyReportAck();
 382   4      
 383   4                                      if (pbuf[14])
 384   4                                      {
 385   5                                              IO_SiteSurveyStatusFlag = 2;
 386   5                                      }
 387   4                              }
 388   3                              break;
 389   3                      case IO_JOIN_BSS_ACK:
 390   3                              if (pbuf[2])
 391   3                                      return IO_COMMAND_ERROR;
 392   3                              printd ("\r BSS joined              \n\r");
 393   3                              break;
 394   3                      case IO_SSID_READ_RESP:
 395   3                              if (pbuf[2] > 32)
 396   3                                      return IO_COMMAND_ERROR;
 397   3                              printd ("\r Read SSID: ");
 398   3                              for (temp = 3; temp < (pbuf[2] + 3); temp++)
 399   3                              {
 400   4                                      printd ("%c", pbuf[temp]);
 401   4                              }
 402   3                              if (temp < 15)
 403   3                                      printd ("          \n\r");
 404   3                              else
 405   3                                      printd ("\n\r");
 406   3                              break;
 407   3                      case IO_SSID_WRITE_ACK:
 408   3                              if (pbuf[2])
 409   3                                      return IO_COMMAND_ERROR;
 410   3                              break;
 411   3                      case IO_OPERATE_MODE_RESP:
 412   3                              if (pbuf[3] == IO_COMMAND_WRITE)
 413   3                              {
 414   4                                      if (pbuf[2] != 1)
 415   4                                              return IO_COMMAND_ERROR;
 416   4      
 417   4                                      IO_SiteSurveyStatusFlag = 1;
 418   4                              }
 419   3                              else if (!pbuf[3])
 420   3                              {
 421   4                                      if (pbuf[2] != 2)
 422   4                                              return IO_COMMAND_ERROR;
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 8   

 423   4                                      printd ("\r Read Baseband Mode: %bd", pbuf[4]);
 424   4                                      switch (pbuf[4])
 425   4                                      {
 426   5                                              case 1:
 427   5                                                      printd (" (802.11b/g mixed mode)\n\r");
 428   5                                                      break;
 429   5                                              case 2:
 430   5                                                      printd (" (Pure 802.11g mode)\n\r");
 431   5                                                      break;
 432   5                                              case 3:
 433   5                                                      printd (" (Pure 802.11b mode)\n\r");
 434   5                                                      break;
 435   5                                              case 4:
 436   5                                                      printd (" (Pure 802.11a mode)\n\r");
 437   5                                                      break;
 438   5                                              default:
 439   5                                                      printd ("\n Not the correct baseband Mode!\n\r");
 440   5                                                      return IO_COMMAND_ERROR;
 441   5                                      }
 442   4                              }
 443   3                              else
 444   3                                      return IO_COMMAND_ERROR;
 445   3                              break;
 446   3                      case IO_CHANNEL_RESP:
 447   3                              if (pbuf[3] == IO_COMMAND_WRITE)
 448   3                              {
 449   4                                      if (pbuf[2] != 1)
 450   4                                              return IO_COMMAND_ERROR;
 451   4                              }
 452   3                              else if (!pbuf[3])
 453   3                              {
 454   4                                      if (pbuf[2] != 2)
 455   4                                              return IO_COMMAND_ERROR;
 456   4                                      printd ("\r Read Current Channel: %bu\n\r", pbuf[4]);
 457   4      
 458   4                                      MWIFAPP_TaskIOReadChannel(pbuf);
 459   4                              }
 460   3                              else
 461   3                                      return IO_COMMAND_ERROR;
 462   3                              break;
 463   3                      case IO_NETWORK_MODE_RESP:
 464   3                              if (pbuf[3] == IO_COMMAND_WRITE)
 465   3                              {
 466   4                                      if (pbuf[2] != 1)
 467   4                                              return IO_COMMAND_ERROR;
 468   4                              }
 469   3                              else if (!pbuf[3])
 470   3                              {
 471   4                                      if (pbuf[2] != 2)
 472   4                                              return IO_COMMAND_ERROR;
 473   4                                      printd ("\r Read Network Type: %bu    \n\r", pbuf[4]);
 474   4                              }
 475   3                              else
 476   3                                      return IO_COMMAND_ERROR;
 477   3                              break;
 478   3                      case IO_MULTICAST_SET_ACK:
 479   3                              if (pbuf[2])
 480   3                                      return IO_COMMAND_ERROR;
 481   3                              break;
 482   3                      case IO_WIFI_MAC_ADDR_SET_RESP: // 0xB6
 483   3                              if (pbuf[3] == IO_COMMAND_WRITE)
 484   3                              {
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 9   

 485   4                                      if (pbuf[2] != 1)
 486   4                                              return IO_COMMAND_ERROR;
 487   4                              }
 488   3                              else if (!pbuf[3])
 489   3                              {
 490   4                                      if (pbuf[2] != 7)
 491   4                                              return IO_COMMAND_ERROR;
 492   4                                      printd ("\r Read WiFi MAC address: ");
 493   4                                      for (temp = 4; temp < 10; temp++)
 494   4                                              printd (" %02bx", pbuf[temp]);
 495   4                                      printd ("\n\r");
 496   4      
 497   4                                  MWIFAPP_TaskIOWiFiMacAddrSet(pbuf);
 498   4                              }
 499   3                              break;
 500   3                      case IO_WIFI_RADIO_ON_OFF_ACK:
 501   3                              if (pbuf[3] == 0)
 502   3                              {
 503   4                                      IO_WifiRFEnable = 0;
 504   4                                      printd("\r Disable RF.                       \n");
 505   4                              }
 506   3                              else if (pbuf[3] == 1)
 507   3                              {
 508   4                                      IO_WifiRFEnable = 1;
 509   4                                      printd("\r Enble RF.                         \n");
 510   4                              }
 511   3                              else if (pbuf[3] == 2)
 512   3                                      printd("\r RF is enabling now.               \n");
 513   3                              else if (pbuf[3] == 3)
 514   3                                      printd("\r RF is disabling now.              \n");
 515   3                              break;
 516   3                      case IO_WIFI_B_G_PROTECTION_RESP:
 517   3                              if (pbuf[3] == IO_COMMAND_WRITE)
 518   3                              {
 519   4                                      if (pbuf[2] != 1)
 520   4                                              return IO_COMMAND_ERROR;
 521   4                              }
 522   3                              else if (!pbuf[3])
 523   3                              {
 524   4                                      if (pbuf[2] != 2)
 525   4                                              return IO_COMMAND_ERROR;
 526   4                                      printd ("\r BG Protection: %s", pbuf[4] ? "auto" : "off");
 527   4                              }
 528   3                              else
 529   3                              {
 530   4                                      return IO_COMMAND_ERROR;
 531   4                              }
 532   3                              break;
 533   3                      case IO_ENCRYPTION_TYPE_RESP:
 534   3                              if (pbuf[3] == IO_COMMAND_WRITE)
 535   3                              {
 536   4                                      if (pbuf[2] != 1)
 537   4                                              return IO_COMMAND_ERROR;
 538   4                              }
 539   3                              else if (!pbuf[3])
 540   3                              {
 541   4                                      if (pbuf[2] != 2)
 542   4                                              return IO_COMMAND_ERROR;
 543   4      
 544   4                                      /* do not know encryption type, be used in web,site survey,jbss case */
 545   4                                      if (IO_EncryptMode == 5)
 546   4                                      {
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 10  

 547   5                                              switch (pbuf[4])
 548   5                                              {
 549   6                                              case 0: /* No encrypt */
 550   6                                                      IO_EncryptMode = 0;
 551   6                                                      break;
 552   6                                              case 1: /* WEP64 */
 553   6                                                      IO_EncryptMode = 1;
 554   6                                                      break;
 555   6                                              case 2: /* TKIP */
 556   6                                                      IO_EncryptMode = 3;
 557   6                                                      break;
 558   6                                              case 4: /* WPA/WPA2 */
 559   6                                                      IO_EncryptMode = 4;
 560   6                                                      break;
 561   6                                              case 5: /* WEP128 */
 562   6                                                      IO_EncryptMode = 2;
 563   6                                                      break;
 564   6                                              default:
 565   6                                                      return IO_COMMAND_ERROR;
 566   6                                              }
 567   5      
 568   5                                              MWIFAPP_TaskIOReadEncryptType();
 569   5                                      }
 570   4                                      else
 571   4                                      {
 572   5                                              printd ("\r Read Encryption Type: %bd", pbuf[4]);
 573   5                                              switch (pbuf[4])
 574   5                                              {
 575   6                                              case 0:
 576   6              
 577   6                                                      IO_EncryptMode = 0;
 578   6                                                      printd (" (No encrypt)\n\r");
 579   6                                                      break;
 580   6                                              case 1:
 581   6                                                      IO_EncryptMode = 1;
 582   6                                                      printd (" (WEP64)\n\r");
 583   6                                                      break;
 584   6                                              case 2:
 585   6                                                      IO_EncryptMode = 3;
 586   6                                                      printd (" (TKIP)\n\r");
 587   6                                                      break;
 588   6                                              case 4:
 589   6                                                      IO_EncryptMode = 4;
 590   6                                                      printd (" (AES)\n\r");
 591   6                                                      break;
 592   6                                              case 5:
 593   6                                                      IO_EncryptMode = 2;
 594   6                                                      printd (" (WEP128)\n\r");
 595   6                                                      break;
 596   6                                              default:
 597   6                                                      printd ("\n Not the correct encryption type!\n\r");
 598   6                                                      return IO_COMMAND_ERROR;
 599   6                                              }
 600   5                                      }
 601   4                              }
 602   3                              else
 603   3                              {
 604   4                                      return IO_COMMAND_ERROR;
 605   4                              }
 606   3                              break;
 607   3                      case IO_OPEN_SYSTEM_RESP:
 608   3                              if (pbuf[3] == IO_COMMAND_WRITE)
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 11  

 609   3                              {
 610   4                                      if (pbuf[2] != 1)
 611   4                                              return IO_COMMAND_ERROR;
 612   4                              }
 613   3                              else if (!pbuf[3])
 614   3                              {
 615   4                                      if (pbuf[2] != 2)
 616   4                                              return IO_COMMAND_ERROR;
 617   4                                      printd ("\r Read Authentication Algorithm: %bd", pbuf[4]);
 618   4                                      switch (pbuf[4])
 619   4                                      {
 620   5                                              case 0:
 621   5                                                      printd (" (Open system)\n\r");
 622   5                                                      break;
 623   5                                              case 1:
 624   5                                                      printd (" (Shared key)\n\r");
 625   5                                                      break;
 626   5                                              case 2:
 627   5                                                      printd (" (WPA1WPA2 only)\n\r");
 628   5                                                      break;
 629   5                                              case 3:
 630   5                                                      printd (" (WPA1WPA2 mixed)\n\r");
 631   5                                                      break;
 632   5                                              default:
 633   5                                                      printd ("\n Not the correct Authentication Algorithm!\n\r");
 634   5                                                      return IO_COMMAND_ERROR;
 635   5                                      }
 636   4                              }
 637   3                              else
 638   3                              {
 639   4                                      return IO_COMMAND_ERROR;
 640   4                              }
 641   3                              break;
 642   3                      case IO_WEP64_KEY_READ_RESP:
 643   3                              if (pbuf[2] != 5)
 644   3                                      return IO_COMMAND_ERROR;
 645   3                              printd ("\r");
 646   3                              for (temp = 3; temp < (pbuf[2] + 3); temp++)
 647   3                              {
 648   4                                      printd (" %02bx", pbuf[temp]);
 649   4                              }
 650   3                              printd ("               \n\r");
 651   3                              break;
 652   3                      case IO_WEP64_KEY_WRITE_ACK:
 653   3                              if (pbuf[2])
 654   3                                      return IO_COMMAND_ERROR;
 655   3                              break;
 656   3                      case IO_WEP128_KEY_READ_RESP:
 657   3                              if (pbuf[2] != 13)
 658   3                                      return IO_COMMAND_ERROR;
 659   3                              printd ("\r");
 660   3                              for (temp = 3; temp < (pbuf[2] + 3); temp++)
 661   3                              {
 662   4                                      printd (" %02bx", pbuf[temp]);
 663   4                              }
 664   3                              printd ("\n\r");
 665   3                              break;
 666   3                      case IO_WEP128_KEY_WRITE_ACK:
 667   3                              if (pbuf[2])
 668   3                                      return IO_COMMAND_ERROR;
 669   3                              break;
 670   3                      case IO_WEP_KEY_INDEX_RESP:
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 12  

 671   3                              if (pbuf[3] == IO_COMMAND_WRITE)
 672   3                              {
 673   4                                      if (pbuf[2] != 1)
 674   4                                              return IO_COMMAND_ERROR;
 675   4                              }
 676   3                              else if (!pbuf[3])
 677   3                              {
 678   4                                      if (pbuf[2] != 2)
 679   4                                              return IO_COMMAND_ERROR;
 680   4                                      printd("\r Read Key index: %bd          \n\r", pbuf[4]);
 681   4                              }
 682   3                              else
 683   3                                      return IO_COMMAND_ERROR;
 684   3                              break;
 685   3                      case IO_TKIP_AES_PASSPHASE_STRING_READ_RESP:
 686   3                              if (!pbuf[2] || pbuf[2] > 64)
 687   3                                      return IO_COMMAND_ERROR;
 688   3                              printd ("\r Read tkip aes Passphrase: ");
 689   3                              for (temp = 3; temp < (pbuf[2] + 3); temp++)
 690   3                              {
 691   4                                      printd ("%c", pbuf[temp]);
 692   4                              }
 693   3                              printd ("\n\r");
 694   3                              break;
 695   3                      case IO_TKIP_AES_PASSPHASE_STRING_WRITE_ACK:
 696   3                              if (pbuf[2])
 697   3                                      return IO_COMMAND_ERROR;
 698   3                              break;
 699   3                      case IO_ERROR_COMMAND:  // 0x0B
 700   3                              if (pbuf[2])
 701   3                                      return IO_COMMAND_ERROR;
 702   3                              printd("Drop bad command\n\r");
 703   3                              break;
 704   3                      case IO_FRAGMENT_THRESHOLD_READ_RESP:
 705   3                              if (pbuf[2] != 2)
 706   3                                      return IO_COMMAND_ERROR;
 707   3                              printd ("\r Read Fragment threshold: %u\n", *((U16_T XDATA*)&pbuf[3]));
 708   3                              break;
 709   3                      case IO_FRAGMENT_THRESHOLD_WRITE_ACK:
 710   3                              if (pbuf[2])
 711   3                                      return IO_COMMAND_ERROR;
 712   3                              break;
 713   3                      case IO_RTS_THRESHOLD_READ_RESP:
 714   3                              if (pbuf[2] != 2)
 715   3                                      return IO_COMMAND_ERROR;
 716   3                              printd ("\r Read RTS threshold: %u\n", *((U16_T XDATA*)&pbuf[3]));
 717   3                              break;
 718   3                      case IO_RTS_THRESHOLD_WRITE_ACK:
 719   3                              if (pbuf[2])
 720   3                                      return IO_COMMAND_ERROR;
 721   3                              break;
 722   3                      case IO_PREAMBLE_RESP:
 723   3                              if (pbuf[3] == IO_COMMAND_WRITE)
 724   3                              {
 725   4                                      if (pbuf[2] != 1)
 726   4                                              return IO_COMMAND_ERROR;
 727   4                              }
 728   3                              else if (!pbuf[3])
 729   3                              {
 730   4                                      if (pbuf[2] != 2)
 731   4                                              return IO_COMMAND_ERROR;
 732   4                                      printd ("\r Read Preamble mode: %bd", pbuf[4] >> 5);
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 13  

 733   4                                      switch (pbuf[4])
 734   4                                      {
 735   5                                      case 0:
 736   5                                              printd (" (Long)\n\r");
 737   5                                              break;
 738   5                                      case BIT5:
 739   5                                              printd (" (Short)\n\r");
 740   5                                              break;
 741   5                                      default:
 742   5                                              printd ("\n Not the correct mode!\n\r");
 743   5                                              return IO_COMMAND_ERROR;
 744   5                                      }
 745   4                              }
 746   3                              else
 747   3                                      return IO_COMMAND_ERROR;
 748   3                              break;
 749   3                      case IO_TX_POWER_LEVEL_READ_RESP:
 750   3                              if (pbuf[2] != 1)
 751   3                                      return IO_COMMAND_ERROR;
 752   3                              printd ("\r Read Tx power gain: 0x%02bx\n\r", pbuf[3]);
 753   3                              break;
 754   3                      case IO_TX_POWER_LEVEL_WRITE_ACK:
 755   3                              if (pbuf[2])
 756   3                                      return IO_COMMAND_ERROR;
 757   3                              break;
 758   3                      case IO_BEACON_INTERVAL_READ_RESP:
 759   3                              if (pbuf[2] != 2)
 760   3                                      return IO_COMMAND_ERROR;
 761   3                              IO_BcnInterval = *((U16_T XDATA*)&pbuf[3]);
 762   3                              printd ("\r Read Beacon Interval: %u ms\n\r", IO_BcnInterval);
 763   3      
 764   3                              MWIFAPP_TaskIOReadBeaconInterval();
 765   3      
 766   3                              break;
 767   3                      case IO_BEACON_INTERVAL_WRITE_ACK:
 768   3                              if (pbuf[2])
 769   3                                      return IO_COMMAND_ERROR;
 770   3                              break;
 771   3                      case IO_COUNTRY_REGION_RESP:
 772   3                              if (pbuf[3] == IO_COMMAND_WRITE)
 773   3                              {
 774   4                                      if (pbuf[2] != 1)
 775   4                                              return IO_COMMAND_ERROR;
 776   4                              }
 777   3                              else if (!pbuf[3])
 778   3                              {
 779   4                                      if (pbuf[2] != 3)
 780   4                                              return IO_COMMAND_ERROR;
 781   4                                      printd ("\r Read Country Region: 0x%02bX%02bX", pbuf[4], pbuf[5]);
 782   4                                      switch (*((U16_T XDATA *)(&pbuf[4])))
 783   4                                      {
 784   5                                      case 0x0010:
 785   5                                              printd (" (USA)\n\r");
 786   5                                              break;
 787   5                                      case 0x0020:
 788   5                                              printd (" (Canada)\n\r");
 789   5                                              break;
 790   5                                      case 0x0030:
 791   5                                              printd (" (Most of Europe1)\n\r");
 792   5                                              break;
 793   5                                      case 0x0083:
 794   5                                              printd (" (Most of Europe2)\n\r");
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 14  

 795   5                                              break;
 796   5                                      case 0x0031:
 797   5                                              printd (" (Spain)\n\r");
 798   5                                              break;
 799   5                                      case 0x0032:
 800   5                                              printd (" (France1)\n\r");
 801   5                                              break;
 802   5                                      case 0x0084:
 803   5                                              printd (" (France2)\n\r");
 804   5                                              break;
 805   5                                      case 0x0040:
 806   5                                              printd (" (Japan1)\n\r");
 807   5                                              break;
 808   5                                      case 0x0041:
 809   5                                              printd (" (Japan2)\n\r");
 810   5                                              break;
 811   5                                      case 0x0049:
 812   5                                              printd (" (Japan3)\n\r");
 813   5                                              break;
 814   5                                      case 0x0043:
 815   5                                              printd (" (China)\n\r");
 816   5                                              break;
 817   5                                      case 0x0048:
 818   5                                              printd (" (Taiwan)\n\r");
 819   5                                              break;
 820   5                                      case 0x0000:
 821   5                                              printd (" (All areas)\n\r");
 822   5                                              break;
 823   5                                      default:
 824   5                                              printd ("\n Not the correct Country Region number!\n\r");
 825   5                                              break;
 826   5                                      }
 827   4                              }
 828   3                              else
 829   3                              {
 830   4                                      return IO_COMMAND_ERROR;
 831   4                              }
 832   3                              break;
 833   3                      case IO_ATIM_INTERVAL_READ_RESP:
 834   3                              if (pbuf[2] != 2)
 835   3                                      return IO_COMMAND_ERROR;
 836   3                              printd ("\r Read ATIM Windows: %u ms\n\r", *((U16_T XDATA*)&pbuf[3]));
 837   3                              break;
 838   3                      case IO_ATIM_INTERVAL_WRITE_ACK:
 839   3                              if (pbuf[2])
 840   3                                      return IO_COMMAND_ERROR;
 841   3                              break;
 842   3                      case IO_TX_DATA_RATE_RESP:
 843   3                              if (pbuf[3] == IO_COMMAND_WRITE)        // write
 844   3                              {
 845   4                                      if (pbuf[2] != 1)
 846   4                                              return IO_COMMAND_ERROR;
 847   4                              }
 848   3                              else if (!pbuf[3])
 849   3                              {
 850   4                                      if (pbuf[2] != 2)
 851   4                                              return IO_COMMAND_ERROR;
 852   4                                      printd ("\r Read current Tx data rate: %2bx", pbuf[4]);
 853   4                                      switch (pbuf[4])
 854   4                                      {
 855   5                                      case 0:
 856   5                                              printd (" (Auto)\n\r");
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 15  

 857   5                                              break;
 858   5                                      case 0x02:
 859   5                                              printd (" (1M)\n\r");
 860   5                                              break;
 861   5                                      case 0x04:
 862   5                                              printd (" (2M)\n\r");
 863   5                                              break;
 864   5                                      case 0x0B:
 865   5                                              printd (" (5.5M)\n\r");
 866   5                                              break;
 867   5                                      case 0x0C:
 868   5                                              printd (" (6M)\n\r");
 869   5                                              break;
 870   5                                      case 0x12:
 871   5                                              printd (" (9M)\n\r");
 872   5                                              break;
 873   5                                      case 0x16:
 874   5                                              printd (" (11M)\n\r");
 875   5                                              break;
 876   5                                      case 0x18:
 877   5                                              printd (" (12M)\n\r");
 878   5                                              break;
 879   5                                      case 0x24:
 880   5                                              printd (" (18M)\n\r");
 881   5                                              break;
 882   5                                      case 0x30:
 883   5                                              printd (" (24M)\n\r");
 884   5                                              break;
 885   5                                      case 0x48:
 886   5                                              printd (" (36M)\n\r");
 887   5                                              break;
 888   5                                      case 0x60:
 889   5                                              printd (" (48M)\n\r");
 890   5                                              break;
 891   5                                      case 0x6C:
 892   5                                              printd (" (54M)\n\r");
 893   5                                              break;
 894   5                                      default:
 895   5                                              printd ("\n Not the correct Tx data rate!\n\r");
 896   5                                              break;
 897   5                                      }
 898   4                              }
 899   3                              else
 900   3                                      return IO_COMMAND_ERROR;
 901   3                              break;
 902   3                      case IO_AUTO_POWER_CONTROL_RESP:
 903   3                              if (pbuf[3] == IO_COMMAND_WRITE)
 904   3                              {
 905   4                                      if (pbuf[2] != 1)
 906   4                                              return IO_COMMAND_ERROR;
 907   4                                      printd ("successfully!!\n\r");
 908   4                              }
 909   3                              else if (!pbuf[3])
 910   3                              {
 911   4                                      if (pbuf[2] != 2)
 912   4                                              return IO_COMMAND_ERROR;
 913   4                                      if (pbuf[4])
 914   4                                      {
 915   5                                              printd("Enable auto power control.\n\r");
 916   5                                      }
 917   4                                      else
 918   4                                      {
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 16  

 919   5                                              printd("Disable auto power control.\n\r");
 920   5                                      }
 921   4                              }
 922   3                              else
 923   3                                      return IO_COMMAND_ERROR;
 924   3                              break;
 925   3                      case IO_WIFI_ROAMING_RESP:
 926   3                              if (pbuf[3] == IO_COMMAND_WRITE)
 927   3                              {
 928   4                                      if (pbuf[2] != 1)
 929   4                                              return IO_COMMAND_ERROR;
 930   4                              }
 931   3                              else if (!pbuf[3])
 932   3                              {
 933   4                                      if (pbuf[2] != 2)
 934   4                                              return IO_COMMAND_ERROR;
 935   4                                      if (pbuf[4])
 936   4                                      {
 937   5                                              printd("Enable roaming.\n\r");
 938   5                                      }
 939   4                                      else
 940   4                                      {
 941   5                                              printd("Disable roaming.\n\r");
 942   5                                      }
 943   4                              }
 944   3                              else
 945   3                                      return IO_COMMAND_ERROR;
 946   3                              break;
 947   3                      case IO_WIFI_MULTIMEDIA_SET_RESP:
 948   3                              if (pbuf[3] == IO_COMMAND_WRITE)
 949   3                              {
 950   4                                      if (pbuf[2] != 1)
 951   4                                              return IO_COMMAND_ERROR;
 952   4                              }
 953   3                              else if (!pbuf[3])
 954   3                              {
 955   4                                      if (pbuf[2] != 2)
 956   4                                              return IO_COMMAND_ERROR;
 957   4                                      if (pbuf[4])
 958   4                                      {
 959   5                                              printd("Enable WMM.\n\r");
 960   5                                      }
 961   4                                      else
 962   4                                      {
 963   5                                              printd("Disable WMM.\n\r");
 964   5                                      }
 965   4                              }
 966   3                              else
 967   3                                      return IO_COMMAND_ERROR;
 968   3                              break;
 969   3                      case IO_LISTEN_INTERVAL_RESP:
 970   3                              if (pbuf[3] == IO_COMMAND_WRITE)
 971   3                              {
 972   4                                      if (pbuf[2] != 1)
 973   4                                              return IO_COMMAND_ERROR;
 974   4                              }
 975   3                              else if (!pbuf[3])
 976   3                              {
 977   4                                      if (pbuf[2] != 3)
 978   4                                              return IO_COMMAND_ERROR;
 979   4                                      printd("Listen Interval: %d.\n\r", *((U16_T*)&pbuf[4]));
 980   4                              }
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 17  

 981   3                              else
 982   3                                      return IO_COMMAND_ERROR;
 983   3                              break;
 984   3                      case IO_MINIMUM_CONTENTION_WINDOW:
 985   3                              if (pbuf[3] == IO_COMMAND_WRITE)
 986   3                              {
 987   4                                      if (pbuf[2] != 1)
 988   4                                              return IO_COMMAND_ERROR;
 989   4                              }
 990   3                              else if (!pbuf[3])
 991   3                              {
 992   4                                      if (pbuf[2] != 3)
 993   4                                              return IO_COMMAND_ERROR;
 994   4                                      printd("Minimum contention window: %d.\n\r", *((U16_T*)&pbuf[4]));
 995   4                              }
 996   3                              else
 997   3                                      return IO_COMMAND_ERROR;
 998   3                              break;
 999   3                      case IO_MAXIMUM_CONTENTION_WINDOW:
1000   3                              if (pbuf[3] == IO_COMMAND_WRITE)
1001   3                              {
1002   4                                      if (pbuf[2] != 1)
1003   4                                              return IO_COMMAND_ERROR;
1004   4                              }
1005   3                              else if (!pbuf[3])
1006   3                              {
1007   4                                      if (pbuf[2] != 3)
1008   4                                              return IO_COMMAND_ERROR;
1009   4                                      printd("Maximum contention window: %d.\n\r", *((U16_T*)&pbuf[4]));
1010   4                              }
1011   3                              else
1012   3                                      return IO_COMMAND_ERROR;
1013   3                              break;
1014   3                      case IO_SHOW_RSSI_RESP:
1015   3                              if (pbuf[2] != 1)
1016   3                                      return IO_COMMAND_ERROR;
1017   3                              printd ("\r Read RSSI value: %bx    \n\r", pbuf[3]);
1018   3                              break;
1019   3                      case IO_PAYLOAD_LENGTH_ATTACH_IN_WIFI_PACKET_RESP:
1020   3                              if (pbuf[3] == IO_COMMAND_WRITE)
1021   3                              {
1022   4                                      if (pbuf[2] != 1)
1023   4                                              return IO_COMMAND_ERROR;
1024   4                              }
1025   3                              else if (!pbuf[3])
1026   3                              {
1027   4                                      if (pbuf[2] != 2)
1028   4                                              return IO_COMMAND_ERROR;
1029   4                                      if (pbuf[4])
1030   4                                      {
1031   5                                              printd("Attach payload length in WiFi packet.\n\r");
1032   5                                      }
1033   4                                      else
1034   4                                      {
1035   5                                              printd("Don't attach payload length in WiFi packet.\n\r");
1036   5                                      }
1037   4                              }
1038   3                              else
1039   3                                      return IO_COMMAND_ERROR;
1040   3                              break;
1041   3                      case IO_RETAIN_LLC_IN_WIFI_PACKET_RESP:
1042   3                              if (pbuf[3] == IO_COMMAND_WRITE)
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 18  

1043   3                              {
1044   4                                      if (pbuf[2] != 1)
1045   4                                              return IO_COMMAND_ERROR;
1046   4                              }
1047   3                              else if (!pbuf[3])
1048   3                              {
1049   4                                      if (pbuf[2] != 2)
1050   4                                              return IO_COMMAND_ERROR;
1051   4                                      if (pbuf[4])
1052   4                                      {
1053   5                                              printd("Retain LLC in WiFi packet.\n\r");
1054   5                                      }
1055   4                                      else
1056   4                                      {
1057   5                                              printd("Don't retain LLC in WiFi packet.\n\r");
1058   5                                      }
1059   4                              }
1060   3                              else
1061   3                                      return IO_COMMAND_ERROR;
1062   3                              break;
1063   3                      case IO_2_LLC_IN_WIFI_VLAN_PACKET_RESP:
1064   3                              if (pbuf[3] == IO_COMMAND_WRITE)
1065   3                              {
1066   4                                      if (pbuf[2] != 1)
1067   4                                              return IO_COMMAND_ERROR;
1068   4                              }
1069   3                              else if (!pbuf[3])
1070   3                              {
1071   4                                      if (pbuf[2] != 2)
1072   4                                              return IO_COMMAND_ERROR;
1073   4                                      if (pbuf[4])
1074   4                                      {
1075   5                                              printd("Add 2 LLC in WiFi VLAN packet.\n\r");
1076   5                                      }
1077   4                                      else
1078   4                                      {
1079   5                                              printd("Don't add 2 LLC in WiFi VLAN packet.\n\r");
1080   5                                      }
1081   4                              }
1082   3                              else
1083   3                                      return IO_COMMAND_ERROR;
1084   3                              break;
1085   3                      case IO_TRAFFIC_PROFILE_RESP:
1086   3                              if (pbuf[3] == IO_COMMAND_WRITE)
1087   3                              {
1088   4                                      if (pbuf[2] != 1)
1089   4                                              return IO_COMMAND_ERROR;
1090   4                                      printd("Set traffic profile successful!\n\r");
1091   4                              }
1092   3                              else if (!pbuf[3])
1093   3                              {
1094   4                                      if (pbuf[2] != 2)
1095   4                                              return IO_COMMAND_ERROR;
1096   4                                      switch (pbuf[4])
1097   4                                      {
1098   5                                              case 0:
1099   5                                                      printd("Traffic profile is VOICE.\n\r");
1100   5                                                      break;
1101   5                                              case 1:
1102   5                                                      printd("Traffic profile is VIDEO.\n\r");
1103   5                                                      break;
1104   5                                              case 2:
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 19  

1105   5                                                      printd("Traffic profile is BEST_EFFORT.\n\r");
1106   5                                                      break;
1107   5                                              case 3:
1108   5                                                      printd("Traffic profile is BACK_GROUND.\n\r");
1109   5                                                      break;
1110   5                                              case 4:
1111   5                                                      printd("Traffic profile is DEFAULT.\n\r");
1112   5                                                      break;
1113   5                                              default:
1114   5                                                      printd("Incorrect profile number !!\n\r");
1115   5                                                      break;
1116   5                                      }
1117   4                              }
1118   3                              break;
1119   3                      case IO_TX_DEFAULT_POWER_LEVEL_RESP:
1120   3                              if (pbuf[3] == IO_COMMAND_WRITE)
1121   3                              {
1122   4                                      if (pbuf[2] != 2)
1123   4                                              return IO_COMMAND_ERROR;
1124   4                                      if (pbuf[4] == 0)
1125   4                                      {
1126   5                                              printd("Current power level: 100%%\n\r");
1127   5                                      }
1128   4                                      else if (pbuf[4] == 1)
1129   4                                      {
1130   5                                              printd("Current power level: 50%%\n\r");
1131   5                                      }
1132   4                                      else if (pbuf[4] == 2)
1133   4                                      {
1134   5                                              printd("Current power level: 25%%\n\r");
1135   5                                      }
1136   4                                      else if (pbuf[4] == 3)
1137   4                                      {
1138   5                                              printd("Current power level: 12.5%%\n\r");
1139   5                                      }
1140   4                                      else if (pbuf[4] == 4)
1141   4                                      {
1142   5                                              printd("Current power level: 6.25%%\n\r");
1143   5                                      }
1144   4                                      else if (pbuf[4] == 0xff)
1145   4                                      {
1146   5                                              printd("Power level is the same!!\n\r");
1147   5                                      }
1148   4                                      else
1149   4                                      {
1150   5                                              printd("Not the correct Power level!!\n\r");
1151   5                                              return IO_COMMAND_ERROR;
1152   5                                      }
1153   4                              }
1154   3                              else if (!pbuf[3])
1155   3                              {
1156   4                                      if (pbuf[2] != 2)
1157   4                                              return IO_COMMAND_ERROR;
1158   4                                      if (pbuf[4] == 0)
1159   4                                      {
1160   5                                              printd("Current power level: 100%%\n\r");
1161   5                                      }
1162   4                                      else if (pbuf[4] == 1)
1163   4                                      {
1164   5                                              printd("Current power level: 50%%\n\r");
1165   5                                      }
1166   4                                      else if (pbuf[4] == 2)
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 20  

1167   4                                      {
1168   5                                              printd("Current power level: 25%%\n\r");
1169   5                                      }
1170   4                                      else if (pbuf[4] == 3)
1171   4                                      {
1172   5                                              printd("Current power level: 12.5%%\n\r");
1173   5                                      }
1174   4                                      else if (pbuf[4] == 4)
1175   4                                      {
1176   5                                              printd("Current power level: 6.25%%\n\r");
1177   5                                      }
1178   4                                      else
1179   4                                      {
1180   5                                              printd("Not the correct Power level!!\n\r");
1181   5                                              return IO_COMMAND_ERROR;
1182   5                                      }
1183   4                              }
1184   3                              else
1185   3                                      return IO_COMMAND_ERROR;
1186   3                              break;
1187   3                      case IO_QUEUE_PRIORITY_SET_RESP:
1188   3                              break;
1189   3                      case IO_SELF_CTS_RESP:
1190   3                              if (pbuf[3] == IO_COMMAND_WRITE)
1191   3                              {
1192   4                                      if (pbuf[2] != 1)
1193   4                                              return IO_COMMAND_ERROR;
1194   4                                      printd ("Success to set!!\r\n");
1195   4                              }
1196   3                              else if (!pbuf[3])
1197   3                              {
1198   4                                      if (pbuf[2] != 2)
1199   4                                              return IO_COMMAND_ERROR;
1200   4                                      if (pbuf[4] == 0)
1201   4                                      {
1202   5                                              printd ("Self-CTS disabled in OFDM\r\n");
1203   5                                      }
1204   4                                      else if (pbuf[4] == 1)
1205   4                                      {
1206   5                                              printd ("Self-CTS enable in OFDM\r\n");
1207   5                                      }
1208   4                              }
1209   3                              else
1210   3                                      return IO_COMMAND_ERROR;
1211   3                              break;
1212   3                      case IO_BSSID_RESP:
1213   3                              if (pbuf[3] == IO_COMMAND_READ)
1214   3                              {
1215   4                                      if (pbuf[2] != 7)
1216   4                                              return IO_COMMAND_ERROR;
1217   4                                      
1218   4                                      if ((pbuf[4] == 0) && (pbuf[5] == 0) && (pbuf[6] == 0) && (pbuf[7] == 0) && (pbuf[8] == 0) && (pbuf[9]
             - == 0))
1219   4                                      {
1220   5                                              printd ("BSSID: 00 00 00 00 00 00, wireless does not connect.\r\n");
1221   5                                      }
1222   4                                      else
1223   4                                      {
1224   5                                              printd ("BSSID: %02bX %02bX %02bX %02bX %02bX %02bX\r\n", pbuf[4], pbuf[5], pbuf[6], pbuf[7], pbuf[8]
             -, pbuf[9]);
1225   5                                      }
1226   4                              }
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 21  

1227   3                              else
1228   3                                      return IO_COMMAND_ERROR;
1229   3                              break;
1230   3                      case IO_WIFI_IP_READ_RESP:
1231   3                              if (pbuf[2] != 4)
1232   3                                      return IO_COMMAND_ERROR;
1233   3                              printd ("Wifi IP: %02bu.%02bu.%02bu.%02bu\r\n", pbuf[3], pbuf[4], pbuf[5], pbuf[6]);
1234   3                              break;
1235   3                      case IO_WIFI_DRIVER_VER_READ_RESP:
1236   3                              if (pbuf[2] == 0)
1237   3                                      return IO_COMMAND_ERROR;
1238   3                              printd ("WCPU driver version: %s\n\r", &pbuf[3]);
1239   3      
1240   3                  MWIFAPP_TaskIOWiFiDriverVer(pbuf);
1241   3                              break;
1242   3      #if MASS_PRODUCTION
                              case IO_CONTINUOUS_TX_ACK:      // 0xC0
                                      if (pbuf[3] == 0)
                                              printd("\r Stop ct command !!                \n");
                                      else if (pbuf[3] == 1)
                                              printd("\r Launch continuous tx with CCK ... \n");
                                      else if (pbuf[3] == 2)
                                              printd("\r Launch continuous tx with OFDM ...\n");
                                      else if (pbuf[3] == 3)
                                              printd("\r Launch single tone ...            \n");
                                      else if (pbuf[3] == 4)
                                              printd("\r Launch tx suppression ...         \n");
                                      else if (pbuf[3] == 5)
                                              printd("\r Launch burst CCK ...              \n");
                                      break;
                              case IO_SENSITIVITY_TEST_ACK:
                                      if (pbuf[2] == 2)
                                      {
                                              printd("\r Total received frames should be %05u\n", *((U16_T *)&pbuf[3]));
                                              printd("\r Start sensitivity test ...        \n");
                                      }
                                      break;
                              case IO_SENSITIVITY_TEST_REPORT_ACK:
                                      if (pbuf[2])
                                      {
                                              printd("\r");
                                              temp = pbuf[2];
                                              for (i = 0; i < temp; i++)
                                              {
                                                      printd("%c", pbuf[i + 3]);
                                              }
                                              printd("    \n");
                                      }
                                      break;
              #endif
1277   3                      case IO_DBG_WCPU_SFR_READ_RESP:
1278   3                              if (pbuf[2] != 1)
1279   3                                      return IO_COMMAND_ERROR;
1280   3                              printd ("\rvalue = %bx              \n", pbuf[3]);
1281   3                              break;
1282   3                      case IO_DBG_WCPU_SFR_WRITE_ACK:
1283   3                              if (pbuf[2])
1284   3                                      return IO_COMMAND_ERROR;
1285   3                              break;
1286   3                      case IO_DBG_WCPU_SUB_SYS_REG_READ_RESP:
1287   3                              if (pbuf[2] < 1)
1288   3                                      return IO_COMMAND_ERROR;
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 22  

1289   3                              printd ("\r");
1290   3                              for (temp = 3; temp < (3 + pbuf[2]); temp++)
1291   3                              {
1292   4                                      printd (" %02bx", pbuf[temp]);
1293   4                              }
1294   3                              printd ("                       \n");
1295   3                              break;
1296   3                      case IO_DBG_WCPU_SUB_SYS_REG_WRITE_RESP:        // 0xD3
1297   3                              if (pbuf[2])
1298   3                                      return IO_COMMAND_ERROR;
1299   3                              break;
1300   3                      case IO_DBG_WCPU_MIIB_REG_READ_RESP:
1301   3                              if (pbuf[2] < 1)
1302   3                                      return IO_COMMAND_ERROR;
1303   3                              printd ("\r");
1304   3                              for (temp = 3; temp < (3 + pbuf[2]); temp++)
1305   3                              {
1306   4                                      printd (" %02bx", pbuf[temp]);
1307   4                              }
1308   3                              printd ("                         \n");
1309   3                              break;
1310   3                      case IO_DBG_WCPU_MIIB_REG_WRITE_ACK:
1311   3                              if (pbuf[2])
1312   3                                      return IO_COMMAND_ERROR;
1313   3                              break;
1314   3                      case IO_DBG_WCPU_PCIB_REG_READ_RESP:
1315   3                              if (pbuf[2] < 1)
1316   3                                      return IO_COMMAND_ERROR;
1317   3                              printd ("\r");
1318   3                              for (temp = 3; temp < (3 + pbuf[2]); temp++)
1319   3                              {
1320   4                                      printd (" %02bx", pbuf[temp]);
1321   4                              }
1322   3                              printd ("                          \n");
1323   3                              break;
1324   3                      case IO_DBG_WCPU_PCIB_REG_WRITE_ACK:
1325   3                              if (pbuf[2])
1326   3                                      return IO_COMMAND_ERROR;
1327   3                              break;
1328   3                      case IO_DBG_PCI_CONFIGURATION_READ_RESP:        // 0xD8
1329   3                              if (pbuf[2] != 4)
1330   3                                      return IO_COMMAND_ERROR;
1331   3                              printd ("\r");
1332   3                              printd ("%08lx", *((U32_T XDATA*)&pbuf[3]));
1333   3                              printd ("                          \n");
1334   3                              break;
1335   3                      case IO_DBG_PCI_CONFIGURATION_WRITE_ACK:        // 0xD9
1336   3                              if (pbuf[2])
1337   3                                      return IO_COMMAND_ERROR;
1338   3                              break;
1339   3                      case IO_DBG_WIFI_REG_READ_RESP:
1340   3                              if (pbuf[2] != 4)
1341   3                                      return IO_COMMAND_ERROR;
1342   3                              printd ("\r");
1343   3                              printd ("%08lx", *((U32_T XDATA*)&pbuf[3]));
1344   3                              printd ("                          \n");
1345   3                              break;
1346   3                      case IO_DBG_WIFI_REG_WRITE_ACK:
1347   3                              if (pbuf[2])
1348   3                                      return IO_COMMAND_ERROR;
1349   3                              break;
1350   3                      case IO_DBG_WIFI_PACKET_FILTERING_WRITE_ACK:
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 23  

1351   3                              if (pbuf[2])
1352   3                                      return IO_COMMAND_ERROR;
1353   3                              printd("\n Set packet filtering successful!!\n");
1354   3                              break;
1355   3                      case IO_DBG_WIFI_PACKET_FILTERING_READ_RESP:
1356   3                              if (pbuf[2] != 9)
1357   3                                      return IO_COMMAND_ERROR;
1358   3                              if (!(pbuf[3] & 0x07))
1359   3                              {
1360   4                                      printd ("\n No filtering!!!\n");
1361   4                                      break;
1362   4                              }
1363   3                              if (pbuf[3] & BIT0)
1364   3                              {
1365   4                                      printd ("\n Filtering type:\n");
1366   4                                      printd (" 1.Filter management frame.\n");
1367   4                                      if (pbuf[5] & BIT0)
1368   4                                              printd ("\tFilter Association request.\n");
1369   4                                      if (pbuf[5] & BIT1)
1370   4                                              printd ("\tFilter Association response.\n");
1371   4                                      if (pbuf[5] & BIT2)
1372   4                                              printd ("\tFilter Re-associate request.\n");
1373   4                                      if (pbuf[5] & BIT3)
1374   4                                              printd ("\tFilter Re-associate response.\n");
1375   4                                      if (pbuf[5] & BIT4)
1376   4                                              printd ("\tFilter Probe request.\n");
1377   4                                      if (pbuf[5] & BIT5)
1378   4                                              printd ("\tFilter Probe response.\n");
1379   4                                      if (pbuf[5] & BIT6)
1380   4                                              printd ("\tFilter Reserve 1.\n");
1381   4                                      if (pbuf[5] & BIT7)
1382   4                                              printd ("\tFilter Reserve 2.\n");
1383   4                                      if (pbuf[4] & BIT0)
1384   4                                              printd ("\tFilter Beacon.\n");
1385   4                                      if (pbuf[4] & BIT1)
1386   4                                              printd ("\tFilter ATIM.\n");
1387   4                                      if (pbuf[4] & BIT2)
1388   4                                              printd ("\tFilter De-associate.\n");
1389   4                                      if (pbuf[4] & BIT3)
1390   4                                              printd ("\tFilter Authentication.\n");
1391   4                                      if (pbuf[4] & BIT4)
1392   4                                              printd ("\tFilter De-authentication.\n");
1393   4                                      if (pbuf[4] & BIT5)
1394   4                                              printd ("\tFilter Action.\n");
1395   4                                      if (pbuf[4] & BIT6)
1396   4                                              printd ("\tFilter Reserve 3.\n");
1397   4                                      if (pbuf[4] & BIT7)
1398   4                                              printd ("\tFilter Reserve 4.\n");
1399   4                              }
1400   3                              if (pbuf[3] & BIT1)
1401   3                                      printd (" 2.Filter data frame.\n");
1402   3                              if (pbuf[3] & BIT2)
1403   3                                      printd (" 3.Filter broadcast/multicast.\n");
1404   3                              printd (" BSSID to filter:\n\t");
1405   3                              for (temp = 6; temp < 12; temp++)
1406   3                                      printd (" %02bx", pbuf[temp]);
1407   3                              printd ("\n");
1408   3                              break;
1409   3                      case IO_DBG_SYNTHESIZER_SET_ACK:
1410   3                              if (pbuf[2])
1411   3                                      return IO_COMMAND_ERROR;
1412   3                              printd("\r Set synthesizer successful!!\n");
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 24  

1413   3                              break;
1414   3                      case IO_DBG_RETRY_NUMBER_RESP:
1415   3                              if (pbuf[3] == IO_COMMAND_WRITE)
1416   3                              {
1417   4                                      if (pbuf[2] != 1)
1418   4                                              return IO_COMMAND_ERROR;
1419   4                              }
1420   3                              else if (!pbuf[3])
1421   3                              {
1422   4                                      if (pbuf[2] != 2)
1423   4                                              return IO_COMMAND_ERROR;
1424   4                                      printd ("\r Read Max Retry Counter: %bu\n\r", pbuf[4]);
1425   4                              }
1426   3                              else
1427   3                                      return IO_COMMAND_ERROR;
1428   3                              break;
1429   3                      case IO_GPIO_ZERO_RESP:
1430   3                              if (pbuf[3] == IO_COMMAND_WRITE)
1431   3                              {
1432   4                                      if (pbuf[2] != 1)
1433   4                                              return IO_COMMAND_ERROR;
1434   4                              }
1435   3                              else if (!pbuf[3])
1436   3                              {
1437   4                                      if (pbuf[2] != 2)
1438   4                                              return IO_COMMAND_ERROR;
1439   4                                      printd ("P0: %bX\n\r", pbuf[4]);
1440   4                              }
1441   3                              else
1442   3                                      return IO_COMMAND_ERROR;
1443   3                              break;
1444   3                      case IO_GPIO_ONE_RESP:
1445   3                              if (pbuf[3] == IO_COMMAND_WRITE)
1446   3                              {
1447   4                                      if (pbuf[2] != 1)
1448   4                                              return IO_COMMAND_ERROR;
1449   4                              }
1450   3                              else if (!pbuf[3])
1451   3                              {
1452   4                                      if (pbuf[2] != 2)
1453   4                                              return IO_COMMAND_ERROR;
1454   4                                      printd ("P1: %bX\n\r", pbuf[4]);
1455   4                              }
1456   3                              else
1457   3                                      return IO_COMMAND_ERROR;
1458   3                              break;
1459   3                      case IO_GPIO_TWO_RESP:
1460   3                              if (pbuf[3] == IO_COMMAND_WRITE)
1461   3                              {
1462   4                                      if (pbuf[2] != 1)
1463   4                                              return IO_COMMAND_ERROR;
1464   4                              }
1465   3                              else if (!pbuf[3])
1466   3                              {
1467   4                                      if (pbuf[2] != 2)
1468   4                                              return IO_COMMAND_ERROR;
1469   4                                      printd ("P2: %bX\n\r", pbuf[4]);
1470   4                              }
1471   3                              else
1472   3                                      return IO_COMMAND_ERROR;
1473   3                              break;
1474   3                      case IO_GPIO_THREE_RESP:
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 25  

1475   3                              if (pbuf[3] == IO_COMMAND_WRITE)
1476   3                              {
1477   4                                      if (pbuf[2] != 1)
1478   4                                              return IO_COMMAND_ERROR;
1479   4                              }
1480   3                              else if (!pbuf[3])
1481   3                              {
1482   4                                      if (pbuf[2] != 2)
1483   4                                              return IO_COMMAND_ERROR;
1484   4                                      printd ("P3: %bX\n\r", pbuf[4]);
1485   4                              }
1486   3                              else
1487   3                                      return IO_COMMAND_ERROR;
1488   3                              break;
1489   3                      case IO_DBG_AUTO_POWER_CONTROL_RESP:
1490   3                              if (pbuf[3] == IO_COMMAND_WRITE)
1491   3                              {
1492   4                                      if (pbuf[2] != 1)
1493   4                                              return IO_COMMAND_ERROR;
1494   4                                      printd ("successfully.\n\r");
1495   4                              }
1496   3                              else
1497   3                                      return IO_COMMAND_ERROR;
1498   3                              break;
1499   3                      default:
1500   3                              return IO_COMMAND_ERROR;
1501   3                      }
1502   2              }
1503   1      
1504   1              return IO_COMMAND_DONE;
1505   1      }
1506          
1507          void io_WlanDebug1Resp(void)
1508          {
1509   1              MWIF_Send(IO_WLAN_DEBUG1_RESP, NULL, 0);
1510   1      
1511   1      } /* End of IO_WlanDebug1 */
1512          
1513          /*
1514           * ----------------------------------------------------------------------------
1515           * Function Name: IO_NoticeWcpu
1516           * Purpose: To management CPU connect, disconnect, and ready commands
1517           * Params: U8_T  type - The type of the command
1518           *         U8_T* pbuf - The start pointer of the payload buffer
1519           *         U8_T  len  - Length of the payload
1520           * Returns: none
1521           * Note: none
1522           * ----------------------------------------------------------------------------
1523           */
1524          void IO_NoticeWcpu(U8_T type, U8_T* pbuf, U8_T len)
1525          {
1526   1              if (MCPU_WcpuReady || type == IO_MCPU_WCPU_READY)
1527   1              {
1528   2                      MWIF_Send(type, pbuf, len);
1529   2              }
1530   1      
1531   1      } /* End of IO_NoticeWcpu() */
1532          
1533          /*
1534           * ----------------------------------------------------------------------------
1535           * Function Name: IO_Reset
1536           * Purpose: To ask WCPU reset itself
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 26  

1537           * Params: none
1538           * Returns: none
1539           * Note: none
1540           * ----------------------------------------------------------------------------
1541           */
1542          void IO_Reset(void)
1543          {
1544   1              MWIF_Send(IO_WCPU_RESET, NULL, 0);
1545   1      
1546   1      }       /* End of IO_Reset */
1547          
1548          /*
1549           * ----------------------------------------------------------------------------
1550           * Function Name: IO_Scan
1551           * Purpose: To ask WCPU to do scanning
1552           * Params: none
1553           * Returns: none
1554           * Note: none
1555           * ----------------------------------------------------------------------------
1556           */
1557          void IO_Scan(void)
1558          {
1559   1              MWIF_Send(IO_SCAN, NULL, 0);
1560   1      
1561   1      }       /* End of IO_Scan */
1562          
1563          /*
1564           * ----------------------------------------------------------------------------
1565           * Function Name: IO_SiteSurvey
1566           * Purpose: To ask WCPU to do site survey
1567           * Params: none
1568           * Returns: none
1569           * Note: none
1570           * ----------------------------------------------------------------------------
1571           */
1572          void IO_SiteSurvey(void)
1573          {
1574   1              MWIF_Send(IO_SITE_SURVEY, NULL, 0);
1575   1      
1576   1      }       /* End of IO_SiteSurvey */
1577          
1578          /*
1579           * ----------------------------------------------------------------------------
1580           * Function Name: IO_JoinBss
1581           * Purpose: To ask WCPU to join the BSS
1582           * Params: U8_T value - The index of the BSS
1583           * Returns: none
1584           * Note: none
1585           * ----------------------------------------------------------------------------
1586           */
1587          void IO_JoinBss(U8_T value)
1588          {
1589   1              MWIF_Send(IO_JOIN_BSS, &value, 1);
1590   1      
1591   1              MWIFAPP_TaskIOJoinBss(value);
1592   1      
1593   1      }       /* End of IO_JoinBss */
1594          
1595          /*
1596           * ----------------------------------------------------------------------------
1597           * Function Name: IO_SsidRW
1598           * Purpose: To ask WCPU to write SSID string or get the SSID string from WCPU
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 27  

1599           * Params: U8_T  type - 0: read command 1: write command
1600           *         U8_T  len - The length of SSID string
1601           *         U8_T* pReg - Start pointer of the buffer to save SSID string
1602           * Returns: none
1603           * Note: none
1604           * ----------------------------------------------------------------------------
1605           */
1606          void IO_SsidRW(U8_T type, U8_T len, U8_T XDATA* pReg)
1607          {
1608   1              if (type == IO_COMMAND_WRITE)
1609   1              {
1610   2                      MWIF_Send(IO_SSID_WRITE, pReg, len);
1611   2              }
1612   1              else
1613   1              {
1614   2                      MWIF_Send(IO_SSID_READ, NULL, 0);
1615   2              }
1616   1      }       /* End of IO_SsidRW */
1617          
1618          /*
1619           * ----------------------------------------------------------------------------
1620           * Function Name: IO_OperateModeRW
1621           * Purpose: To ask WCPU to set operation mode or get operation mode from WCPU
1622           * Params: U8_T type - 0: read command 1: write command
1623           *         U8_T value - the mode to operate
1624           * Returns: none
1625           * Note: none
1626           * ----------------------------------------------------------------------------
1627           */
1628          void IO_OperateModeRW(U8_T type, U8_T value)
1629          {
1630   1              U8_T    len;
1631   1      
1632   1              if (type == IO_COMMAND_WRITE)
1633   1              {
1634   2                      len = 2;
1635   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
1636   2                      io_TxBuf[1] = value;
1637   2              }
1638   1              else
1639   1              {
1640   2                      len = 1;
1641   2                      io_TxBuf[0] = IO_COMMAND_READ;
1642   2              }
1643   1      
1644   1              MWIF_Send(IO_OPERATE_MODE, io_TxBuf, len);
1645   1              
1646   1      }       /* End of IO_OperateModeRW */
1647          
1648          /*
1649           * ----------------------------------------------------------------------------
1650           * Function Name: IO_ChannelRW
1651           * Purpose: To ask WCPU to set channel number or get channel number from WCPU
1652           * Params: U8_T type - 0: read command 1: write command
1653           *         U8_T value - The channel number
1654           * Returns: none
1655           * Note: none
1656           * ----------------------------------------------------------------------------
1657           */
1658          void IO_ChannelRW(U8_T type, U8_T value)
1659          {
1660   1              U8_T    len;
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 28  

1661   1      
1662   1              if (type == IO_COMMAND_WRITE)
1663   1              {
1664   2                      len = 2;
1665   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
1666   2                      io_TxBuf[1] = value;
1667   2              }
1668   1              else
1669   1              {
1670   2                      len = 1;
1671   2                      io_TxBuf[0] = IO_COMMAND_READ;
1672   2              }
1673   1      
1674   1              MWIF_Send(IO_CHANNEL, io_TxBuf, len);
1675   1              
1676   1      }       /* End of IO_ChannelRW */
1677          
1678          /*
1679           * ----------------------------------------------------------------------------
1680           * Function Name: IO_NetworkModeRW
1681           * Purpose: To ask WCPU to set network mode or get network mode from WCPU
1682           * Params: U8_T type - 0: read command 1: write command
1683           *         U8_T value - the mode of network
1684           * Returns: none
1685           * Note: none
1686           * ----------------------------------------------------------------------------
1687           */
1688          void IO_NetworkModeRW(U8_T type, U8_T value)
1689          {
1690   1              U8_T    len;
1691   1      
1692   1              if (type == IO_COMMAND_WRITE)
1693   1              {
1694   2                      len = 2;
1695   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
1696   2                      io_TxBuf[1] = value;
1697   2              }
1698   1              else
1699   1              {
1700   2                      len = 1;
1701   2                      io_TxBuf[0] = IO_COMMAND_READ;
1702   2              }
1703   1      
1704   1              MWIF_Send(IO_NETWORK_MODE, io_TxBuf, len);
1705   1              
1706   1      }       /* End of IO_NetworkModeRW */
1707          
1708          /*
1709           * ----------------------------------------------------------------------------
1710           * Function Name: IO_SetMulticastMac
1711           * Purpose: To ask WCPU to set multicast MAC support or get Tx data rate from WCPU
1712           * Params: U8_T  rw - 0: read command 1: write command
1713           *         U8_T* pMulticastMac - Start pointer of the buffer to save the multicast
1714           *                               MAC setting
1715           * Returns: none
1716           * Note: none
1717           * ----------------------------------------------------------------------------
1718           */
1719          void IO_SetMulticastMac(U8_T XDATA* pMulticastMac)
1720          {
1721   1              MWIF_Send(IO_MULTICAST_SET, pMulticastMac, 6);
1722   1              
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 29  

1723   1      }       /* End of IO_SetMulticastMac */
1724          
1725          /*
1726           * ----------------------------------------------------------------------------
1727           * Function Name: IO_WiFiMacRW
1728           * Purpose: To ask WCPU to set WiFi MAC address or get WiFi MAC address from WCPU
1729           * Params: U8_T  type - 0: read command 1: write command
1730           *         U8_T* pReg - Start pointer of the buffer to WiFi MAC address
1731           * Returns: none
1732           * Note: none
1733           * ----------------------------------------------------------------------------
1734           */
1735          void IO_WiFiMacRW(U8_T type, U8_T XDATA* pReg)
1736          {
1737   1              U8_T    len;
1738   1                      
1739   1              if (type == IO_COMMAND_WRITE)
1740   1              {
1741   2                      len = 7;
1742   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
1743   2                      memcpy(&io_TxBuf[1], pReg, 6);
1744   2              }
1745   1              else
1746   1              {
1747   2                      len = 1;
1748   2                      io_TxBuf[0] = IO_COMMAND_READ;
1749   2              }
1750   1      
1751   1              MWIF_Send(IO_WIFI_MAC_ADDR_SET, io_TxBuf, len);
1752   1              
1753   1      }       /* End of IO_WiFiMacRW */
1754          
1755          /*
1756           * ----------------------------------------------------------------------------
1757           * Function Name: IO_RadioOnOff
1758           * Purpose: To ask WCPU to enable or disable the RF or read the state
1759           * Params: U8_T state - 0: disable RF, 1: enable RF
1760           * Returns: none
1761           * Note: none
1762           * ----------------------------------------------------------------------------
1763           */
1764          U8_T IO_RadioOnOff(U8_T state)
1765          {       
1766   1              MWIF_Send(IO_WIFI_RADIO_ON_OFF, &state, 1);
1767   1      
1768   1              return 0;
1769   1      
1770   1      }       /* End of IO_RadioOnOff */
1771          
1772          /*
1773           * ----------------------------------------------------------------------------
1774           * Function Name: IO_BgProtection
1775           * Purpose: To ask WCPU to set the mode of bg protection
1776           * Params: U8_T state - xxxxx
1777           * Returns: none
1778           * Note: none
1779           * ----------------------------------------------------------------------------
1780           */
1781          void IO_BgProtectionRW(U8_T type, U8_T state)
1782          {
1783   1              U8_T    len;
1784   1              
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 30  

1785   1              if (type == IO_COMMAND_WRITE)
1786   1              {
1787   2                      len = 2;
1788   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
1789   2                      io_TxBuf[1] = state;
1790   2              }
1791   1              else
1792   1              {
1793   2                      len = 1;
1794   2                      io_TxBuf[0] = IO_COMMAND_READ;
1795   2              }
1796   1      
1797   1              MWIF_Send(IO_WIFI_B_G_PROTECTION, io_TxBuf, len);
1798   1      
1799   1      }       /* End of IO_BgProtection */
1800          
1801          /*
1802           * ----------------------------------------------------------------------------
1803           * Function Name: IO_EncryptionRW
1804           * Purpose: To ask WCPU to set encryption status or get encryption status from WCPU
1805           * Params: U8_T type - 0: read command 1: write command
1806           *         U8_T value - 0: disable encryption 1: enable encryption
1807           * Returns: none
1808           * Note: none
1809           * ----------------------------------------------------------------------------
1810           */
1811          void IO_EncryptionRW(U8_T type, U8_T value)
1812          {
1813   1              U8_T    len;
1814   1      
1815   1              if (type == IO_COMMAND_WRITE)
1816   1              {
1817   2                      len = 2;
1818   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
1819   2                      io_TxBuf[1] = value;
1820   2              }
1821   1              else
1822   1              {
1823   2                      len = 1;
1824   2                      io_TxBuf[0] = IO_COMMAND_READ;
1825   2              }
1826   1      
1827   1              MWIF_Send(IO_ENCRYPTION_TYPE, io_TxBuf, len);
1828   1              
1829   1      }       /* End of IO_EncryptionRW */
1830          
1831          /*
1832           * ----------------------------------------------------------------------------
1833           * Function Name: IO_OpenSysRW
1834           * Purpose: To ask WCPU to enable/disable open system or get the status of
1835           *          open system from WCPU
1836           * Params: U8_T type - 0: read command 1: write command
1837           *         U8_T value - enable/disable open system
1838           * Returns: none
1839           * Note: none
1840           * ----------------------------------------------------------------------------
1841           */
1842          void IO_OpenSysRW(U8_T type, U8_T value)
1843          {
1844   1              U8_T    len;
1845   1      
1846   1              if (type == IO_COMMAND_WRITE)
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 31  

1847   1              {
1848   2                      len = 2;
1849   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
1850   2                      io_TxBuf[1] = value;
1851   2              }
1852   1              else
1853   1              {
1854   2                      len = 1;
1855   2                      io_TxBuf[0] = IO_COMMAND_READ;
1856   2              }
1857   1      
1858   1              MWIF_Send(IO_OPEN_SYSTEM, io_TxBuf, len);
1859   1              
1860   1      }       /* End of IO_OpenSysRW */
1861          
1862          /*
1863           * ----------------------------------------------------------------------------
1864           * Function Name: IO_Wep64KeyRW
1865           * Purpose: To ask WCPU to write WEP64 key or get the WEP64 key from WCPU
1866           * Params: U8_T  type - 0: read command 1: write command
1867           *         U8_T  index - The index of WEP64 key
1868           *         U8_T* pReg - Start pointer of the buffer to save WEP64 key
1869           * Returns: none
1870           * Note: none
1871           * ----------------------------------------------------------------------------
1872           */
1873          void IO_Wep64KeyRW(U8_T type, U8_T index, U8_T XDATA* pReg)
1874          {
1875   1              io_TxBuf[0] = index;
1876   1              
1877   1              if (type == IO_COMMAND_WRITE)
1878   1              {
1879   2                      memcpy(&io_TxBuf[1], pReg, 5);
1880   2      
1881   2                      MWIF_Send(IO_WEP64_KEY_WRITE, io_TxBuf, 6);
1882   2              }
1883   1              else
1884   1              {
1885   2                      MWIF_Send(IO_WEP64_KEY_READ, io_TxBuf, 1);
1886   2              }
1887   1      }       /* End of IO_Wep64KeyRW */
1888          
1889          /*
1890           * ----------------------------------------------------------------------------
1891           * Function Name: IO_Wep128KeyRW
1892           * Purpose: To ask WCPU to write WEP128 key or get the WEP128 key from WCPU
1893           * Params: U8_T  type - 0: read command 1: write command
1894           *         U8_T  index - The index of WEP128 key
1895           *         U8_T* pReg - Start pointer of the buffer to save WEP128 key
1896           * Returns: none
1897           * Note: none
1898           * ----------------------------------------------------------------------------
1899           */
1900          void IO_Wep128KeyRW(U8_T type, U8_T index, U8_T XDATA* pReg)
1901          {
1902   1              io_TxBuf[0] = index;
1903   1      
1904   1              if (type == IO_COMMAND_WRITE)
1905   1              {
1906   2                      memcpy(&io_TxBuf[1], pReg, 13);
1907   2      
1908   2                      MWIF_Send(IO_WEP128_KEY_WRITE, io_TxBuf, 14);
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 32  

1909   2              }
1910   1              else
1911   1              {
1912   2                      MWIF_Send(IO_WEP128_KEY_READ, io_TxBuf, 1);
1913   2              }
1914   1      }       /* End of IO_Wep128KeyRW */
1915          
1916          /*
1917           * ----------------------------------------------------------------------------
1918           * Function Name: IO_WepKeyIndexRW
1919           * Purpose: To ask WCPU to set WEP key index or get WEP key index from WCPU
1920           * Params: U8_T type - 0: read command 1: write command
1921           *         U8_T value - WEP key index
1922           * Returns: none
1923           * Note: none
1924           * ----------------------------------------------------------------------------
1925           */
1926          void IO_WepKeyIndexRW(U8_T type, U8_T value)
1927          {
1928   1              U8_T    len;
1929   1      
1930   1              if (type == IO_COMMAND_WRITE)
1931   1              {
1932   2                      len = 2;
1933   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
1934   2                      io_TxBuf[1] = value;
1935   2              }
1936   1              else
1937   1              {
1938   2                      len = 1;
1939   2                      io_TxBuf[0] = IO_COMMAND_READ;
1940   2              }
1941   1      
1942   1              MWIF_Send(IO_WEP_KEY_INDEX, io_TxBuf, len);
1943   1              
1944   1      }       /* End of IO_WepKeyIndexRW */
1945          
1946          /*
1947           * ----------------------------------------------------------------------------
1948           * Function Name: IO_TkipAesRW
1949           * Purpose: To ask WCPU to write TKIP/AES string or get the TKIP/AES string from WCPU
1950           * Params: U8_T  type - 0: read command 1: write command
1951           *         U8_T  len - The length of TKIP/AES string
1952           *         U8_T* pReg - Start pointer of the buffer to save TKIP/AES string
1953           * Returns: none
1954           * Note: none
1955           * ----------------------------------------------------------------------------
1956           */
1957          void IO_TkipAesRW(U8_T type, U8_T len, U8_T XDATA* pReg)
1958          {
1959   1              if (type == IO_COMMAND_WRITE)
1960   1              {
1961   2                      MWIF_Send(IO_TKIP_AES_PASSPHASE_STRING_WRITE, pReg, len);
1962   2              }
1963   1              else
1964   1              {
1965   2                      MWIF_Send(IO_TKIP_AES_PASSPHASE_STRING_READ, NULL, 0);
1966   2              }
1967   1      }       /* End of IO_TkipAesRW */
1968          
1969          /*
1970           * ----------------------------------------------------------------------------
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 33  

1971           * Function Name: IO_FragmentThresholdRW
1972           * Purpose: To ask WCPU to set fragment threshold or reply a acknowledgement to WCPU
1973           * Params: U8_T  type - 0: read command 1: write command
1974           *         U8_T* pValue - Start pointer of the buffer to save fragment threshold value
1975           * Returns: none
1976           * Note: none
1977           * ----------------------------------------------------------------------------
1978           */
1979          void IO_FragmentThresholdRW(U8_T type, U8_T XDATA* pValue)
1980          {
1981   1              if (type == IO_COMMAND_WRITE)
1982   1              {
1983   2                      io_TxBuf[0] = *pValue;
1984   2                      io_TxBuf[1] = *(pValue + 1);
1985   2      
1986   2                      MWIF_Send(IO_FRAGMENT_THRESHOLD_WRITE, io_TxBuf, 2);
1987   2              }
1988   1              else
1989   1              {
1990   2                      MWIF_Send(IO_FRAGMENT_THRESHOLD_READ, NULL, 0);
1991   2              }
1992   1      
1993   1      }       /* End of IO_FragmentThresholdRW */
1994          
1995          /*
1996           * ----------------------------------------------------------------------------
1997           * Function Name: IO_RtsThresholdRW
1998           * Purpose: To ask WCPU to set RTS threshold or reply a acknowledgement to WCPU
1999           * Params: U8_T  type - 0: read command 1: write command
2000           *         U8_T* pValue - Start pointer of the buffer to save RTS threshold value
2001           * Returns: none
2002           * Note: none
2003           * ----------------------------------------------------------------------------
2004           */
2005          void IO_RtsThresholdRW(U8_T type, U8_T XDATA* pValue)
2006          {
2007   1              if (type == IO_COMMAND_WRITE)
2008   1              {
2009   2                      io_TxBuf[0] = *pValue;
2010   2                      io_TxBuf[1] = *(pValue + 1);
2011   2      
2012   2                      MWIF_Send(IO_RTS_THRESHOLD_WRITE, io_TxBuf, 2);
2013   2              }
2014   1              else
2015   1              {
2016   2                      MWIF_Send(IO_RTS_THRESHOLD_READ, NULL, 0);
2017   2              }
2018   1      
2019   1      }       /* End of IO_RtsThresholdRW */
2020          
2021          /*
2022           * ----------------------------------------------------------------------------
2023           * Function Name: IO_PreambleRW
2024           * Purpose: To ask WCPU to set long/short preamble or get the preamble status
2025           *          from WCPU
2026           * Params: U8_T type - 0: read command 1: write command
2027           *         U8_T value - long/short preamble
2028           * Returns: none
2029           * Note: none
2030           * ----------------------------------------------------------------------------
2031           */
2032          void IO_PreambleRW(U8_T type, U8_T value)
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 34  

2033          {
2034   1              U8_T    len;
2035   1      
2036   1              if (type == IO_COMMAND_WRITE)
2037   1              {
2038   2                      len = 2;
2039   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
2040   2                      io_TxBuf[1] = value;
2041   2              }
2042   1              else
2043   1              {
2044   2                      len = 1;
2045   2                      io_TxBuf[0] = IO_COMMAND_READ;
2046   2              }
2047   1      
2048   1              MWIF_Send(IO_PREAMBLE, io_TxBuf, len);
2049   1              
2050   1      }       /* End of IO_PreambleRW */
2051          
2052          /*
2053           * ----------------------------------------------------------------------------
2054           * Function Name: IO_TxGainRW
2055           * Purpose: To ask WCPU to set Tx power gain or get Tx power gain from WCPU
2056           * Params: U8_T rw - 0: read command 1: write command
2057           *         U8_T txGain - the Tx power gain value
2058           * Returns: none
2059           * Note: none
2060           * ----------------------------------------------------------------------------
2061           */
2062          void IO_TxGainRW(U8_T rw, U8_T txGain)
2063          {
2064   1              if (rw == IO_COMMAND_WRITE)
2065   1              {
2066   2                      io_TxBuf[0] = txGain;
2067   2      
2068   2                      MWIF_Send(IO_TX_POWER_LEVEL_WRITE, io_TxBuf, 1);
2069   2              }
2070   1              else
2071   1              {
2072   2                      MWIF_Send(IO_TX_POWER_LEVEL_READ, NULL, 0);
2073   2              }
2074   1      
2075   1      }       /* End of IO_TxGainRW */
2076          
2077          /*
2078           * ----------------------------------------------------------------------------
2079           * Function Name: IO_BeaconIntervalRW
2080           * Purpose: To ask WCPU to set beacon interval or reply a acknowedgement to WCPU
2081           * Params: U8_T  type - 0: read command 1: write command
2082           *         U8_T* pValue - Start pointer of the buffer to save beacon interval value
2083           * Returns: none
2084           * Note: none
2085           * ----------------------------------------------------------------------------
2086           */
2087          void IO_BeaconIntervalRW(U8_T type, U8_T* pValue)
2088          {
2089   1              if (type == IO_COMMAND_WRITE)
2090   1              {
2091   2                      io_TxBuf[0] = *pValue;
2092   2                      io_TxBuf[1] = *(pValue + 1);
2093   2      
2094   2                      MWIF_Send(IO_BEACON_INTERVAL_WRITE, io_TxBuf, 2);
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 35  

2095   2              }
2096   1              else
2097   1              {
2098   2                      MWIF_Send(IO_BEACON_INTERVAL_READ, NULL, 0);
2099   2              }
2100   1      
2101   1      }       /* End of IO_BeaconIntervalRW */
2102          
2103          /*
2104           * ----------------------------------------------------------------------------
2105           * Function Name: IO_CountryRegionRW
2106           * Purpose: To ask WCPU to set country region or get country region from WCPU
2107           * Params: U8_T type - 0: read command 1: write command
2108           *         U8_T value - The country region value
2109           * Returns: none
2110           * Note: none
2111           * ----------------------------------------------------------------------------
2112           */
2113          void IO_CountryRegionRW(U8_T type, U16_T value)
2114          {
2115   1              U8_T    len;
2116   1      
2117   1              if (type == IO_COMMAND_WRITE)
2118   1              {
2119   2                      len = 3;
2120   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
2121   2                      io_TxBuf[1] = value >> 8;
2122   2                      io_TxBuf[2] = (U8_T)value;
2123   2              }
2124   1              else
2125   1              {
2126   2                      len = 1;
2127   2                      io_TxBuf[0] = IO_COMMAND_READ;
2128   2              }
2129   1      
2130   1              MWIF_Send(IO_COUNTRY_REGION, io_TxBuf, len);
2131   1      
2132   1      }       /* End of IO_CountryRegionRW */
2133          
2134          /*
2135           * ----------------------------------------------------------------------------
2136           * Function Name: IO_AtimIntervalRW
2137           * Purpose: To ask WCPU to set ATIM interval or reply a acknowedgement to WCPU
2138           * Params: U8_T  type - 0: read command 1: write command
2139           *         U8_T* pValue - Start pointer of the buffer to save ATIM interval value
2140           * Returns: none
2141           * Note: none
2142           * ----------------------------------------------------------------------------
2143           */
2144          void IO_AtimIntervalRW(U8_T type, U8_T XDATA* pValue)
2145          {
2146   1              if (type == IO_COMMAND_WRITE)
2147   1              {
2148   2                      io_TxBuf[0] = *pValue;
2149   2                      io_TxBuf[1] = *(pValue + 1);
2150   2      
2151   2                      MWIF_Send(IO_ATIM_INTERVAL_WRITE, io_TxBuf, 2);
2152   2              }
2153   1              else
2154   1              {
2155   2                      MWIF_Send(IO_ATIM_INTERVAL_READ, NULL, 0);
2156   2              }
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 36  

2157   1      
2158   1      }       /* End of IO_AtimIntervalRW */
2159          
2160          /*
2161           * ----------------------------------------------------------------------------
2162           * Function Name: IO_TxDataRateRW
2163           * Purpose: To ask WCPU to set Tx data rate or get Tx data rate from WCPU
2164           * Params: U8_T rw - 0: read command 1: write command
2165           *         U8_T txRate - the Tx data rate
2166           * Returns: U8_T result - 0x00: success 
2167           *                        0xFF: fail
2168           * Note: none
2169           * ----------------------------------------------------------------------------
2170           */
2171          U8_T IO_TxDataRateRW(U8_T rw, U8_T txRate)
2172          {
2173   1              U8_T XDATA result = 0xff;
2174   1              U8_T    len;
2175   1      
2176   1              if (rw == IO_COMMAND_WRITE)
2177   1              {
2178   2                      len = 2;
2179   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
2180   2                      switch (txRate)
2181   2                      {
2182   3                      case 0:
2183   3                      case 0x02:
2184   3                      case 0x04:
2185   3                      case 0x0B:
2186   3                      case 0x0C:
2187   3                      case 0x12:
2188   3                      case 0x16:
2189   3                      case 0x18:
2190   3                      case 0x24:
2191   3                      case 0x30:
2192   3                      case 0x48:
2193   3                      case 0x60:
2194   3                      case 0x6C:
2195   3                              io_TxBuf[1] = txRate;
2196   3                              break;
2197   3                      default:
2198   3                              return result;
2199   3                      }
2200   2              }
2201   1              else
2202   1              {
2203   2                      len = 1;
2204   2                      io_TxBuf[0] = IO_COMMAND_READ;
2205   2              }
2206   1              result = 0;
2207   1              
2208   1              MWIF_Send(IO_TX_DATA_RATE,io_TxBuf, len);
2209   1              
2210   1              return result;
2211   1              
2212   1      }       /* End of IO_TxDataRateRW */
2213          
2214          /*
2215           * ----------------------------------------------------------------------------
2216           * Function Name: IO_AutoPowerCtrlRW
2217           * Purpose: To ask WCPU to enable/disable "WiFi Tx auto power control" function
2218           *          or get the status from WCPU
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 37  

2219           * Params: U8_T type - 0: read command 1: write command
2220           *         U8_T OnOff - 0: Off 1: ON
2221           * Returns: none
2222           * Note: none
2223           * ----------------------------------------------------------------------------
2224           */
2225          void IO_AutoPowerCtrlRW(U8_T type, U8_T OnOff)
2226          {
2227   1              U8_T    len;
2228   1              
2229   1              if (type == IO_COMMAND_WRITE)
2230   1              {
2231   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
2232   2                      io_TxBuf[1] = OnOff;
2233   2                      switch (OnOff)
2234   2                      {
2235   3                      case 0:
2236   3                      case 1:
2237   3                              len = 2;
2238   3                              break;
2239   3                      }
2240   2              }
2241   1              else
2242   1              {
2243   2                      len = 1;
2244   2                      io_TxBuf[0] = IO_COMMAND_READ;
2245   2              }
2246   1              
2247   1              MWIF_Send(IO_AUTO_POWER_CONTROL, io_TxBuf, len);
2248   1              
2249   1      }       /* End of IO_AutoPowerCtrlRW */
2250          
2251          /*
2252           * ----------------------------------------------------------------------------
2253           * Function Name: IO_AutoPowerCtrlDetailW
2254           * Purpose: To ask WCPU to enable/disable "WiFi Tx auto power control" function
2255           *          or get the status from WCPU
2256           * Params: U8_T value - the set point value
2257           * Returns: none
2258           * Note: none
2259           * ----------------------------------------------------------------------------
2260           */
2261          void IO_AutoPowerCtrlDetailW(U8_T value)
2262          {
2263   1              U8_T    len;
2264   1              
2265   1              io_TxBuf[0] = IO_COMMAND_WRITE;
2266   1              len = 3;
2267   1              io_TxBuf[1] = 2;
2268   1              io_TxBuf[2] = value;
2269   1              
2270   1              MWIF_Send(IO_DBG_AUTO_POWER_CONTROL, io_TxBuf, len);
2271   1              
2272   1      }       /* End of IO_AutoPowerCtrlDetailW */
2273          
2274          /*
2275           * ----------------------------------------------------------------------------
2276           * Function Name: IO_Roaming
2277           * Purpose: To ask WCPU to enable/disable roaming function or get the status from WCPU
2278           * Params: U8_T type - 0: read command 1: write command
2279           *         U8_T value - 0: Off 1: ON
2280           * Returns: none
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 38  

2281           * Note: none
2282           * ----------------------------------------------------------------------------
2283           */
2284          void IO_Roaming(U8_T type, U8_T value)
2285          {
2286   1              U8_T    len;
2287   1              
2288   1              if (type == IO_COMMAND_WRITE)
2289   1              {
2290   2                      len = 2;
2291   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
2292   2                      io_TxBuf[1] = value;
2293   2              }
2294   1              else
2295   1              {
2296   2                      len = 1;
2297   2                      io_TxBuf[0] = IO_COMMAND_READ;
2298   2              }
2299   1              
2300   1              MWIF_Send(IO_WIFI_ROAMING, io_TxBuf, len);
2301   1              
2302   1      }       /* End of IO_Roaming */
2303          
2304          /*
2305           * ----------------------------------------------------------------------------
2306           * Function Name: IO_MultimediaSet
2307           * Purpose: To ask WCPU to enable/disable WiFi Multimedia (WMM) function or get
2308           *          the status from WCPU
2309           * Params: U8_T type - 0: read command 1: write command
2310           *         U8_T value - 0: Off 1: ON
2311           * Returns: none
2312           * Note: none
2313           * ----------------------------------------------------------------------------
2314           */
2315          void IO_WifiMultimediaSet(U8_T type, U8_T value)
2316          {
2317   1              U8_T    len;
2318   1              
2319   1              if (type == IO_COMMAND_WRITE)
2320   1              {
2321   2                      len = 2;
2322   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
2323   2                      io_TxBuf[1] = value;
2324   2              }
2325   1              else
2326   1              {
2327   2                      len = 1;
2328   2                      io_TxBuf[0] = IO_COMMAND_READ;
2329   2              }
2330   1              
2331   1              MWIF_Send(IO_WIFI_MULTIMEDIA_SET ,io_TxBuf, len);
2332   1              
2333   1      }       /* End of IO_MultimediaSet */
2334          
2335          /*
2336           * ----------------------------------------------------------------------------
2337           * Function Name: IO_ListenIntervalRW
2338           * Purpose: To ask WCPU to write listen interval value or get
2339           *          the it from WCPU
2340           * Params: U8_T type - 0: read command 1: write command
2341           *         U16_T value - listen interval value
2342           * Returns: none
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 39  

2343           * Note: none
2344           * ----------------------------------------------------------------------------
2345           */
2346          void IO_ListenIntervalRW(U8_T type, U16_T value)
2347          {
2348   1              U8_T    len;
2349   1      
2350   1              if (type == IO_COMMAND_WRITE)
2351   1              {
2352   2                      len = 3;
2353   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
2354   2                      *((U16_T*)&io_TxBuf[1]) = value;
2355   2              }
2356   1              else
2357   1              {
2358   2                      len = 1;
2359   2                      io_TxBuf[0] = IO_COMMAND_READ;
2360   2              }
2361   1              
2362   1              MWIF_Send(IO_LISTEN_INTERVAL, io_TxBuf, len);
2363   1              
2364   1      }       /* End of IO_ListenIntervalRW */
2365          
2366          /*
2367           * ----------------------------------------------------------------------------
2368           * Function Name: IO_MinContentWindowRW
2369           * Purpose: To ask WCPU to write minimum contention window value or get
2370           *          the it from WCPU
2371           * Params: U8_T type - 0: read command 1: write command
2372           *         U16_T value - minimum contention window value
2373           * Returns: none
2374           * Note: none
2375           * ----------------------------------------------------------------------------
2376           */
2377          void IO_MinContentWindowRW(U8_T type, U16_T value)
2378          {
2379   1              U8_T    len;
2380   1              
2381   1              if (type == IO_COMMAND_WRITE)
2382   1              {
2383   2                      len = 3;
2384   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
2385   2                      *((U16_T*)&io_TxBuf[1]) = value;
2386   2              }
2387   1              else
2388   1              {
2389   2                      len = 1;
2390   2                      io_TxBuf[0] = IO_COMMAND_READ;
2391   2              }
2392   1              
2393   1              MWIF_Send(IO_MINIMUM_CONTENTION_WINDOW, io_TxBuf, len);
2394   1              
2395   1      }       /* End of IO_MinContentWindowRW */
2396          
2397          /*
2398           * ----------------------------------------------------------------------------
2399           * Function Name: IO_MaxContentWindowRW
2400           * Purpose: To ask WCPU to write maximum contention window value or get
2401           *          the it from WCPU
2402           * Params: U8_T type - 0: read command 1: write command
2403           *         U16_T value - minimum contention window value
2404           * Returns: none
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 40  

2405           * Note: none
2406           * ----------------------------------------------------------------------------
2407           */
2408          void IO_MaxContentWindowRW(U8_T type, U16_T value)
2409          {
2410   1              U8_T    len;
2411   1      
2412   1              if (type == IO_COMMAND_WRITE)
2413   1              {
2414   2                      len = 3;
2415   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
2416   2                      *((U16_T*)&io_TxBuf[1]) = value;
2417   2              }
2418   1              else
2419   1              {
2420   2                      len = 1;
2421   2                      io_TxBuf[0] = IO_COMMAND_READ;
2422   2              }
2423   1              
2424   1              MWIF_Send(IO_MAXIMUM_CONTENTION_WINDOW, io_TxBuf, len);
2425   1              
2426   1      }       /* End of IO_MaxContentWindowRW */
2427          
2428          /*
2429           * ----------------------------------------------------------------------------
2430           * Function Name: IO_ShowRssi
2431           * Purpose: To ask WCPU the RSSI value
2432           * Params: none
2433           * Returns: none
2434           * Note: none
2435           * ----------------------------------------------------------------------------
2436           */
2437          void IO_ShowRssi(void)
2438          {
2439   1              MWIF_Send(IO_SHOW_RSSI, NULL, 0);
2440   1      
2441   1      }       /* End of IO_ShowRssi */
2442          
2443          /*
2444           * ----------------------------------------------------------------------------
2445           * Function Name: IO_PayloadLenAddInWifi
2446           * Purpose: To ask WCPU to enable/disable "Payload Length Attach in WiFi Packet"
2447           *          function or get the status from WCPU
2448           * Params: U8_T type - 0: read command 1: write command
2449           *         U8_T value - 0: Off 1: ON
2450           * Returns: none
2451           * Note: none
2452           * ----------------------------------------------------------------------------
2453           */
2454          void IO_PayloadLenAddInWifi(U8_T type, U8_T value)
2455          {
2456   1              U8_T    len;
2457   1              
2458   1              if (type == IO_COMMAND_WRITE)
2459   1              {
2460   2                      len = 2;
2461   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
2462   2                      io_TxBuf[1] = value;
2463   2              }
2464   1              else
2465   1              {
2466   2                      len = 1;
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 41  

2467   2                      io_TxBuf[0] = IO_COMMAND_READ;
2468   2              }
2469   1              
2470   1              MWIF_Send(IO_PAYLOAD_LENGTH_ATTACH_IN_WIFI_PACKET, io_TxBuf, len);
2471   1                      
2472   1      }       /* End of IO_PayloadLenAddInWifi */
2473          
2474          /*
2475           * ----------------------------------------------------------------------------
2476           * Function Name: IO_RetainLlcInWifi
2477           * Purpose: To ask WCPU to enable/disable "Retain LLC in WiFi Packet" function
2478           *          or get the status from WCPU
2479           * Params: U8_T type - 0: read command 1: write command
2480           *         U8_T value - 0: Off 1: ON
2481           * Returns: none
2482           * Note: none
2483           * ----------------------------------------------------------------------------
2484           */
2485          void IO_RetainLlcInWifi(U8_T type, U8_T value)
2486          {
2487   1              U8_T    len;
2488   1      
2489   1              if (type == IO_COMMAND_WRITE)
2490   1              {
2491   2                      len = 2;
2492   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
2493   2                      io_TxBuf[1] = value;
2494   2              }
2495   1              else
2496   1              {
2497   2                      len = 1;
2498   2                      io_TxBuf[0] = IO_COMMAND_READ;
2499   2              }
2500   1              
2501   1              MWIF_Send(IO_RETAIN_LLC_IN_WIFI_PACKET, io_TxBuf, len);
2502   1              
2503   1      }       /* End of IO_RetainLlcInWifi */
2504          
2505          /*
2506           * ----------------------------------------------------------------------------
2507           * Function Name: IO_2LlcInWifiVlan
2508           * Purpose: To ask WCPU to enable/disable "2LLC in WiFi VLAN Packet" function
2509           *          or get the status from WCPU
2510           * Params: U8_T type - 0: read command 1: write command
2511           *         U8_T value - 0: Off 1: ON
2512           * Returns: none
2513           * Note: none
2514           * ----------------------------------------------------------------------------
2515           */
2516          void IO_2LlcInWifiVlan(U8_T type, U8_T value)
2517          {
2518   1              U8_T    len;
2519   1              
2520   1              if (type == IO_COMMAND_WRITE)
2521   1              {
2522   2                      len = 2;
2523   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
2524   2                      io_TxBuf[1] = value;
2525   2              }
2526   1              else
2527   1              {
2528   2                      len = 1;
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 42  

2529   2                      io_TxBuf[0] = IO_COMMAND_READ;
2530   2              }
2531   1              
2532   1              MWIF_Send(IO_2_LLC_IN_WIFI_VLAN_PACKET, io_TxBuf, len);
2533   1              
2534   1      }       /* End of IO_2LlcInWifiVlan */
2535          
2536          /*
2537           * ----------------------------------------------------------------------------
2538           * Function Name: IO_TrafficProfile
2539           * Purpose: To ask WCPU to write traffic profile
2540           *          or get the status from WCPU
2541           * Params: U8_T type - 0: read command 1: write command
2542           *         U8_T value - 0: voice 1: video 2: best effort 3: back ground
2543           * Returns: none
2544           * Note: none
2545           * ----------------------------------------------------------------------------
2546           */
2547          void IO_TrafficProfile(U8_T type, U8_T value)
2548          {
2549   1              U8_T    len;
2550   1              
2551   1              if (type == IO_COMMAND_WRITE)
2552   1              {
2553   2                      len = 2;
2554   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
2555   2                      io_TxBuf[1] = value;
2556   2              }
2557   1              else
2558   1              {
2559   2                      len = 1;
2560   2                      io_TxBuf[0] = IO_COMMAND_READ;
2561   2              }
2562   1              
2563   1              MWIF_Send(IO_TRAFFIC_PROFILE, io_TxBuf, len);
2564   1              
2565   1      }       /* End of IO_TrafficProfile */
2566          
2567          /*
2568           * ----------------------------------------------------------------------------
2569           * Function Name: IO_TxDefaultPowerLevelRW
2570           * Purpose: To ask WCPU to set Tx default power level or get Tx default power level from WCPU
2571           * Params: U8_T rw - 0: read command 1: write command
2572           *         U8_T level - 0: 100%, 1: 50%, 2: 25%, 3: 12.5%, 4: 6.25%
2573           * Returns: none
2574           * Note: none
2575           * ----------------------------------------------------------------------------
2576           */
2577          void IO_TxDefaultPowerLevelRW(U8_T rw, U8_T level)
2578          {
2579   1              if (rw == IO_COMMAND_WRITE)
2580   1              {
2581   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
2582   2                      io_TxBuf[1] = level;
2583   2      
2584   2                      MWIF_Send(IO_TX_DEFAULT_POWER_LEVEL, io_TxBuf, 2);
2585   2              }
2586   1              else
2587   1              {
2588   2                      io_TxBuf[0] = IO_COMMAND_READ;
2589   2      
2590   2                      MWIF_Send(IO_TX_DEFAULT_POWER_LEVEL, io_TxBuf, 1);
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 43  

2591   2              }
2592   1      
2593   1      }       /* End of IO_TxDefaultPowerLevelRW */
2594          
2595          /*
2596           * ----------------------------------------------------------------------------
2597           * Function Name: IO_SelfCtsRW
2598           * Purpose: To ask WCPU to set the self-CTS from WCPU
2599           * Params: U8_T  rw - 1: write command 0: read command
2600           *         U8_T  value - 0: OFF, 1: ON
2601           * Returns: none
2602           * Note: none
2603           * ----------------------------------------------------------------------------
2604           */
2605          void IO_SelfCtsRW(U8_T rw, U8_T value)
2606          {
2607   1              U8_T    len;
2608   1              
2609   1              if (rw == IO_COMMAND_WRITE)
2610   1              {
2611   2                      len = 2;
2612   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
2613   2                      io_TxBuf[1] = value;
2614   2              }
2615   1              else
2616   1              {
2617   2                      len = 1;
2618   2                      io_TxBuf[0] = IO_COMMAND_READ;
2619   2              }
2620   1              
2621   1              MWIF_Send(IO_SELF_CTS, io_TxBuf, len);
2622   1              
2623   1      }       /* End of IO_SelfCtsRW */
2624          
2625          /*
2626           * ----------------------------------------------------------------------------
2627           * Function Name: IO_BssidR
2628           * Purpose: To query BSSID from WCPU
2629           * Params: none
2630           * Returns: none
2631           * Note: none
2632           * ----------------------------------------------------------------------------
2633           */
2634          void IO_BssidR(void)
2635          {
2636   1              io_TxBuf[0] = IO_COMMAND_READ;
2637   1              
2638   1              MWIF_Send(IO_BSSID, io_TxBuf, 1);
2639   1              
2640   1      }       /* End of IO_SelfCtsRW */
2641          
2642          /*
2643           * ----------------------------------------------------------------------------
2644           * Function Name: IO_WifiIpR
2645           * Purpose: To query Wifi IP from WCPU
2646           * Params: none
2647           * Returns: none
2648           * Note: none
2649           * ----------------------------------------------------------------------------
2650           */
2651          void IO_WifiIpR(void)
2652          {
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 44  

2653   1              MWIF_Send(IO_WIFI_IP_READ, io_TxBuf, 0);
2654   1              
2655   1      }       /* End of IO_WifiIpR */
2656          
2657          #if MASS_PRODUCTION
              /*
               * ----------------------------------------------------------------------------
               * Function Name: IO_ContinuousTx
               * Purpose: To ask WCPU to enable/disable WiFi continuous Tx function or get
               *          the status from WCPU
               * Params: U8_T mode - 0: Off, 1: CCK, 2: OFDM, 3: CW wave, 4: , 5:
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              U8_T IO_ContinuousTx(U8_T mode)
              {
                      if (mode > 5)
                              return IO_COMMAND_ERROR;
              
                      io_TxBuf[0] = mode;
              
                      MWIF_Send(IO_CONTINUOUS_TX, io_TxBuf, 1);
              
                      return IO_COMMAND_DONE;
                      
              }       /* End of IO_ContinuousTx */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: IO_SensitivityTest
               * Purpose: To ask WCPU to enable/disable WiFi sensitivity test function or get
               *          the status from WCPU
               * Params: U16_T counts - Amount of the broadcast packet to send
               *         U8_T source - The Golden Unit to send broadcast packet
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void IO_SensitivityTest(U16_T counts, U8_T source)
              {
                      io_TxBuf[0] = (U8_T)(counts >> 8);
                      io_TxBuf[1] = (U8_T)counts;
                      io_TxBuf[2] = source;
              
                      MWIF_Send(IO_SENSITIVITY_TEST, io_TxBuf, 3);
                      
              }       /* End of IO_SensitivityTest */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: IO_SensitivityTestReport
               * Purpose: To ask WCPU to report the result of WiFi sensitivity test
               * Params: none
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void IO_SensitivityTestReport(void)
              {
                      MWIF_Send(IO_SENSITIVITY_TEST_REPORT, NULL, 0);
              
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 45  

              }       /* End of IO_SensitivityTestReport */
              #endif
2717          
2718          /*
2719           * ----------------------------------------------------------------------------
2720           * Function Name: IO_SfrRW
2721           * Purpose: To ask WCPU to write SFR or get the SFR value from WCPU
2722           * Params: U8_T type - 0: read command 1: write command
2723           *         U8_T index - The index of SFR
2724           *         U8_T value - The SFR value
2725           * Returns: none
2726           * Note: none
2727           * ----------------------------------------------------------------------------
2728           */
2729          void IO_SfrRW(U8_T type, U8_T index, U8_T XDATA value)
2730          {
2731   1              if (type == IO_COMMAND_WRITE)
2732   1              {
2733   2                      io_TxBuf[0] = index;
2734   2                      io_TxBuf[1] = value;
2735   2      
2736   2                      MWIF_Send(IO_DBG_WCPU_SFR_WRITE, io_TxBuf, 2);
2737   2              }
2738   1              else
2739   1              {
2740   2                      io_TxBuf[0] = index;
2741   2      
2742   2                      MWIF_Send(IO_DBG_WCPU_SFR_READ, io_TxBuf, 1);
2743   2              }
2744   1      }       /* End of IO_SfrRW */
2745          
2746          /*
2747           * ----------------------------------------------------------------------------
2748           * Function Name: IO_WcpuIndirectRW
2749           * Purpose: To ask WCPU to write WCPU indirect register or get WCPU indirect
2750           *          register value from WCPU
2751           * Params: U8_T  type - 0: read command 1: write command
2752           *         U8_T  index - index of WCPU indirect register
2753           *         U8_T* pReg - Start pointer of the buffer to save WCPU indirect register value
2754           * Returns: U8_T - 0x00: IO_COMMAND_DONE
2755           *                 0xFF: IO_COMMAND_ERROR
2756           * Note: none
2757           * ----------------------------------------------------------------------------
2758           */
2759          U8_T IO_WcpuIndirectRW(U8_T type, U8_T index, U8_T XDATA* pReg)
2760          {
2761   1              if (type == IO_COMMAND_WRITE)
2762   1              {
2763   2                      U8_T    len;
2764   2      
2765   2                      io_TxBuf[0] = index;
2766   2                      switch (index)
2767   2                      {
2768   3                      case WCPU_MAIN_CTL_REG:                         // 0x00
2769   3                      case WCPU_WIFI_MAIN_CTL_REG:            // 0x01
2770   3                      case WCPU_DMA_BYTE_COUNT_LOW_REG:       // 0x06
2771   3                      case WCPU_DMA_BYTE_COUNT_CMD_REG:       // 0x07
2772   3                      case WCPU_DMA_CONTROL_REG:                      // 0x08
2773   3                      case WCPU_DMA_INTR_MASK:                        // 0x0B
2774   3                      case WCPU_SWTIMER_TIMER_CTRL:           // 0x0C
2775   3                      case WCPU_SYSTEM_SETTING_REG:           // 0x0D
2776   3                              len = 2;
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 46  

2777   3                              io_TxBuf[1] = *pReg;
2778   3                              break;
2779   3                      case WCPU_DMA_SOUR_ADDR_REG:            // 0x02
2780   3                      case WCPU_DMA_TARGET_ADDR_REG:          // 0x04
2781   3                      case WCPU_SWTIMER_TIMER_REG:            // 0x09
2782   3                              len = 3;
2783   3                              io_TxBuf[1] = *pReg;
2784   3                              io_TxBuf[2] = *(pReg + 1);
2785   3                              break;
2786   3                      default:
2787   3                              return IO_COMMAND_ERROR;
2788   3                      }
2789   2      
2790   2                      MWIF_Send(IO_DBG_WCPU_SUB_SYS_REG_WRITE, io_TxBuf, len);
2791   2              }
2792   1              else
2793   1              {
2794   2                      io_TxBuf[0] = index;
2795   2      
2796   2                      MWIF_Send(IO_DBG_WCPU_SUB_SYS_REG_READ, io_TxBuf, 1);
2797   2              }
2798   1      
2799   1              return IO_COMMAND_DONE;
2800   1      
2801   1      } /* End of IO_WcpuIndirectRW */
2802          
2803          /*
2804           * ----------------------------------------------------------------------------
2805           * Function Name: IO_MiibIndirectRW
2806           * Purpose: To ask WCPU to write MII indirect register or get MII indirect
2807           *          register value from WCPU
2808           * Params: U8_T  type - 0: read command 1: write command
2809           *         U8_T  index - index of MII indirect register
2810           *         U8_T* pReg - Start pointer of the buffer to save MII indirect register value
2811           * Returns: U8_T - 0x00: IO_COMMAND_DONE
2812           *                 0xFF: IO_COMMAND_ERROR
2813           * Note: none
2814           * ----------------------------------------------------------------------------
2815           */
2816          U8_T IO_MiibIndirectRW(U8_T type, U8_T index, U8_T XDATA* pReg)
2817          {
2818   1              if (type == IO_COMMAND_WRITE)
2819   1              {
2820   2                      U8_T    len;
2821   2      
2822   2                      io_TxBuf[0] = index;
2823   2                      switch (index)
2824   2                      {
2825   3                      case MIB_TXMIC_PRIORITY:        // 0x08
2826   3                      case MIB_TX_CONTROL:            // 0x0F
2827   3                      case MIB_RXMIC_PRIORITY:        // 0x18
2828   3                      case MIB_RXMIC_FAIL_CNT:        // 0x19
2829   3                      case MIB_BOUNDARY_SIZE:         // 0x1A
2830   3                              len = 2;
2831   3                              io_TxBuf[1] = *pReg;
2832   3                              break;
2833   3                      case MIB_TX_THRESHOLD:          // 0x09
2834   3                      case MIB_TX_START_ADDR:         // 0x0B
2835   3                      case MIB_TX_END_ADDR:           // 0x0D
2836   3                              len = 3;
2837   3                              io_TxBuf[1] = *pReg;
2838   3                              io_TxBuf[2] = *(pReg + 1);
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 47  

2839   3                              break;
2840   3                      case MIB_LLC_PATTERN:           // 0x1B
2841   3                              len = 7;
2842   3                              memcpy(&io_TxBuf[1], pReg, 6);
2843   3                              break;
2844   3                      case MIB_TXMIC_KEY:                     // 0x00
2845   3                      case MIB_RXMIC_KEY:                     // 0x10
2846   3                              len = 9;
2847   3                              memcpy(&io_TxBuf[1], pReg, 8);
2848   3                              break;
2849   3                      default:
2850   3                              return IO_COMMAND_ERROR;
2851   3                      }
2852   2      
2853   2                      MWIF_Send(IO_DBG_WCPU_MIIB_REG_WRITE, io_TxBuf, len);
2854   2              }
2855   1              else
2856   1              {
2857   2                      io_TxBuf[0] = index;
2858   2      
2859   2                      MWIF_Send(IO_DBG_WCPU_MIIB_REG_READ, io_TxBuf, 1);
2860   2              }
2861   1      
2862   1              return IO_COMMAND_DONE;
2863   1              
2864   1      }       /* End of IO_MiibIndirectRW */
2865          
2866          /*
2867           * ----------------------------------------------------------------------------
2868           * Function Name: IO_PcibIndirectRegRW
2869           * Purpose: To ask WCPU to write PCI indirect register or get PCI indirect
2870           *          register value from WCPU
2871           * Params: U8_T  type - 0: read command 1: write command
2872           *         U8_T  index - index of PCI indirect register
2873           *         U8_T* pReg - Start pointer of the buffer to save PCI indirect register value
2874           * Returns: U8_T - 0x00: IO_COMMAND_DONE
2875           *                 0xFF: IO_COMMAND_ERROR
2876           * Note: none
2877           * ----------------------------------------------------------------------------
2878           */
2879          U8_T IO_PcibIndirectRegRW(U8_T type, U8_T index, U8_T XDATA* pReg)
2880          {
2881   1              if (type == IO_COMMAND_WRITE)
2882   1              {
2883   2                      U8_T    len;
2884   2      
2885   2                      io_TxBuf[0] = index;
2886   2                      switch (index)
2887   2                      {
2888   3                      case PCIB_RFD_BNDRY_SIZE:       // 0x04
2889   3                      case PCIB_FILTER_CONTROL:       // 0x05
2890   3                              len = 2;
2891   3                              io_TxBuf[1] = pReg[0];
2892   3                              break;
2893   3                      case PCIB_RFD_BASE_ADDR:        // 0x00
2894   3                      case PCIB_RFD_END_ADDR:         // 0x02
2895   3                      case PCIB_FILTER_MANG_FRAME:// 0x06
2896   3                              len = 3;
2897   3                              io_TxBuf[1] = pReg[0];
2898   3                              io_TxBuf[2] = pReg[1];
2899   3                              break;
2900   3                      case PCIB_FILTER_BSSID:         // 0x08
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 48  

2901   3                              len = 7;
2902   3                              memcpy(&io_TxBuf[1], pReg, 6);
2903   3                              break;
2904   3                      default:
2905   3                              return IO_COMMAND_ERROR;
2906   3                      }
2907   2      
2908   2                      MWIF_Send(IO_DBG_WCPU_PCIB_REG_WRITE, io_TxBuf, len);
2909   2              }
2910   1              else
2911   1              {
2912   2                      io_TxBuf[0] = index;
2913   2      
2914   2                      MWIF_Send(IO_DBG_WCPU_PCIB_REG_READ, io_TxBuf, 1);
2915   2              }
2916   1      
2917   1              return IO_COMMAND_DONE;
2918   1              
2919   1      }       /* End of IO_PcibIndirectRegRW */
2920          
2921          /*
2922           * ----------------------------------------------------------------------------
2923           * Function Name: IO_PciConfigRW
2924           * Purpose: To ask WCPU to write PCI configuration value or get the PCI
2925           *          configuration value from WCPU
2926           * Params: U8_T  type - 0: read command 1: write command
2927           *         U8_T  index - The index of PCI configuration register
2928           *         U8_T* pReg - Start pointer of the buffer to save PCI configuration value
2929           * Returns: none
2930           * Note: none
2931           * ----------------------------------------------------------------------------
2932           */
2933          void IO_PciConfigRW(U8_T type, U8_T index, U8_T XDATA* pReg)
2934          {
2935   1              if (type == IO_COMMAND_WRITE)
2936   1              {
2937   2                      io_TxBuf[0] = index;
2938   2                      io_TxBuf[1] = pReg[0];
2939   2                      io_TxBuf[2] = pReg[1];
2940   2                      io_TxBuf[3] = pReg[2];
2941   2                      io_TxBuf[4] = pReg[3];
2942   2      
2943   2                      MWIF_Send(IO_DBG_PCI_CONFIGURATION_WRITE, io_TxBuf, 5);
2944   2              }
2945   1              else
2946   1              {
2947   2                      io_TxBuf[0] = index;
2948   2      
2949   2                      MWIF_Send(IO_DBG_PCI_CONFIGURATION_READ, io_TxBuf, 1);
2950   2              }
2951   1      }       /* End of IO_PciConfigRW */
2952          
2953          /*
2954           * ----------------------------------------------------------------------------
2955           * Function Name: IO_WiFiRegRW
2956           * Purpose: To ask WCPU to write WiFi register or get WiFi register value from WCPU
2957           * Params: U8_T  type - 0: read command 1: write command
2958           *         U8_T* pValue - Start pointer of the index of WiFi register
2959           *         U8_T* pReg - Start pointer of the buffer to WiFi register
2960           * Returns: none
2961           * Note: none
2962           * ----------------------------------------------------------------------------
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 49  

2963           */
2964          void IO_WiFiRegRW(U8_T type, U8_T XDATA* pValue, U8_T XDATA* pReg)
2965          {
2966   1              if (type == IO_COMMAND_WRITE)
2967   1              {
2968   2                      io_TxBuf[0] = pValue[0];
2969   2                      io_TxBuf[1] = pValue[1];
2970   2                      io_TxBuf[2] = pReg[0];
2971   2                      io_TxBuf[3] = pReg[1];
2972   2                      io_TxBuf[4] = pReg[2];
2973   2                      io_TxBuf[5] = pReg[3];
2974   2      
2975   2                      MWIF_Send(IO_DBG_WIFI_REG_WRITE, io_TxBuf, 6);
2976   2              }
2977   1              else
2978   1              {
2979   2                      io_TxBuf[0] = pValue[0];
2980   2                      io_TxBuf[1] = pValue[1];
2981   2      
2982   2                      MWIF_Send(IO_DBG_WIFI_REG_READ, io_TxBuf, 2);
2983   2              }
2984   1      }       /* End of IO_WiFiRegRW */
2985          
2986          /*
2987           * ----------------------------------------------------------------------------
2988           * Function Name: IO_WlanPktFilterRW
2989           * Purpose: To ask WCPU to set WiFi packet filtering or get WiFi packet filtering
2990           *          status from WCPU
2991           * Params: U8_T  rw - 0: read command 1: write command
2992           *         U8_T  type - The type of WiFi packet (i.e. Data frame, Managment frame, or Control frame)
2993           *         U8_T  subtype - The subtype of WiFi packet (i.e. PS-Pull, association, etc)
2994           *         U8_T* pBssid - Start pointer of the buffer to save BSSID
2995           * Returns: none
2996           * Note: none
2997           * ----------------------------------------------------------------------------
2998           */
2999          void IO_WlanPktFilterRW(U8_T rw, U8_T type, U16_T subtype, U8_T XDATA* pBssid)
3000          {
3001   1              if (rw == IO_COMMAND_WRITE)
3002   1              {
3003   2                      io_TxBuf[0] = type;
3004   2                      io_TxBuf[1] = (U8_T)(subtype >> 8);
3005   2                      io_TxBuf[2] = (U8_T)subtype;
3006   2                      io_TxBuf[3] = pBssid[0];
3007   2                      io_TxBuf[4] = pBssid[1];
3008   2                      io_TxBuf[5] = pBssid[2];
3009   2                      io_TxBuf[6] = pBssid[3];
3010   2                      io_TxBuf[7] = pBssid[4];
3011   2                      io_TxBuf[8] = pBssid[5];
3012   2      
3013   2                      MWIF_Send(IO_DBG_WIFI_PACKET_FILTERING_WRITE, io_TxBuf, 9);
3014   2              }
3015   1              else
3016   1              {
3017   2                      MWIF_Send(IO_DBG_WIFI_PACKET_FILTERING_READ, NULL, 0);
3018   2              }
3019   1      }       /* End of IO_WlanPktFilterRW */
3020          
3021          /*
3022           * ----------------------------------------------------------------------------
3023           * Function Name: IO_SynthesizerSet
3024           * Purpose: To ask WCPU to set the synthesizer
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 50  

3025           * Params: U8_T* pValue - Start pointer of the buffer to save synthesizer value
3026           * Returns: none
3027           * Note: none
3028           * ----------------------------------------------------------------------------
3029           */
3030          void IO_SynthesizerSet(U8_T XDATA* pValue)
3031          {
3032   1              io_TxBuf[0] = *pValue;
3033   1              io_TxBuf[1] = *(pValue + 1);
3034   1              io_TxBuf[2] = *(pValue + 2);
3035   1              io_TxBuf[3] = *(pValue + 3);
3036   1      
3037   1              MWIF_Send(IO_DBG_SYNTHESIZER_SET, io_TxBuf, 4);
3038   1      
3039   1      }       /* End of IO_SynthesizerSet */
3040          
3041          /*
3042           * ----------------------------------------------------------------------------
3043           * Function Name: IO_RetryRW
3044           * Purpose: To ask WCPU to set WiFi packet retry times or get the WiFi packet 
3045           *          retry times from WCPU
3046           * Params: U8_T type - 0: read command 1: write command
3047           *         U8_T value - WiFi packet retry times
3048           * Returns: none
3049           * Note: none
3050           * ----------------------------------------------------------------------------
3051           */
3052          void IO_RetryRW(U8_T type, U8_T value)
3053          {
3054   1              U8_T    len;
3055   1      
3056   1              if (type == IO_COMMAND_WRITE)
3057   1              {
3058   2                      len = 2;
3059   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
3060   2                      io_TxBuf[1] = value;
3061   2              }
3062   1              else
3063   1              {
3064   2                      len = 1;
3065   2                      io_TxBuf[0] = IO_COMMAND_READ;
3066   2              }
3067   1      
3068   1              MWIF_Send(IO_DBG_RETRY_NUMBER, io_TxBuf, len);
3069   1              
3070   1      }       /* End of IO_RetryRW */
3071          
3072          /*
3073           * ----------------------------------------------------------------------------
3074           * Function Name: IO_Gpio0RW
3075           * Purpose: To ask WCPU to set GPIO 0 or get the value of GPIO 0
3076           * Params: U8_T type - 0: read command 1: write command
3077           *         U8_T value - value of GPIO 0
3078           * Returns: none
3079           * Note: none
3080           * ----------------------------------------------------------------------------
3081           */
3082          void IO_Gpio0RW(U8_T type, U8_T value)
3083          {
3084   1              U8_T    len;
3085   1      
3086   1              if (type == IO_COMMAND_WRITE)
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 51  

3087   1              {
3088   2                      len = 2;
3089   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
3090   2                      io_TxBuf[1] = value;
3091   2              }
3092   1              else
3093   1              {
3094   2                      len = 1;
3095   2                      io_TxBuf[0] = IO_COMMAND_READ;
3096   2              }
3097   1      
3098   1              MWIF_Send(IO_GPIO_ZERO, io_TxBuf, len);
3099   1              
3100   1      }       /* End of IO_Gpio0RW */
3101          
3102          /*
3103           * ----------------------------------------------------------------------------
3104           * Function Name: IO_Gpio1RW
3105           * Purpose: To ask WCPU to set GPIO 1 or get the value of GPIO 1
3106           * Params: U8_T type - 0: read command 1: write command
3107           *         U8_T value - value of GPIO 1
3108           * Returns: none
3109           * Note: none
3110           * ----------------------------------------------------------------------------
3111           */
3112          void IO_Gpio1RW(U8_T type, U8_T value)
3113          {
3114   1              U8_T    len;
3115   1      
3116   1              if (type == IO_COMMAND_WRITE)
3117   1              {
3118   2                      len = 2;
3119   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
3120   2                      io_TxBuf[1] = value;
3121   2              }
3122   1              else
3123   1              {
3124   2                      len = 1;
3125   2                      io_TxBuf[0] = IO_COMMAND_READ;
3126   2              }
3127   1      
3128   1              MWIF_Send(IO_GPIO_ONE , io_TxBuf, len);
3129   1              
3130   1      }       /* End of IO_Gpio1RW */
3131          
3132          /*
3133           * ----------------------------------------------------------------------------
3134           * Function Name: IO_Gpio2RW
3135           * Purpose: To ask WCPU to set GPIO 2 or get the value of GPIO 2
3136           * Params: U8_T type - 0: read command 1: write command
3137           *         U8_T value - value of GPIO 2
3138           * Returns: none
3139           * Note: none
3140           * ----------------------------------------------------------------------------
3141           */
3142          void IO_Gpio2RW(U8_T type, U8_T value)
3143          {
3144   1              U8_T    len;
3145   1      
3146   1              if (type == IO_COMMAND_WRITE)
3147   1              {
3148   2                      len = 2;
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 52  

3149   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
3150   2                      io_TxBuf[1] = value;
3151   2              }
3152   1              else
3153   1              {
3154   2                      len = 1;
3155   2                      io_TxBuf[0] = IO_COMMAND_READ;
3156   2              }
3157   1      
3158   1              MWIF_Send(IO_GPIO_TWO, io_TxBuf, len);
3159   1              
3160   1      }       /* End of IO_Gpio2RW */
3161          
3162          /*
3163           * ----------------------------------------------------------------------------
3164           * Function Name: IO_Gpio3RW
3165           * Purpose: To ask WCPU to set GPIO 3 or get the value of GPIO 3
3166           * Params: U8_T type - 0: read command 1: write command
3167           *         U8_T value - value of GPIO 3
3168           * Returns: none
3169           * Note: none
3170           * ----------------------------------------------------------------------------
3171           */
3172          void IO_Gpio3RW(U8_T type, U8_T value)
3173          {
3174   1              U8_T    len;
3175   1      
3176   1              if (type == IO_COMMAND_WRITE)
3177   1              {
3178   2                      len = 2;
3179   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
3180   2                      io_TxBuf[1] = value;
3181   2              }
3182   1              else
3183   1              {
3184   2                      len = 1;
3185   2                      io_TxBuf[0] = IO_COMMAND_READ;
3186   2              }
3187   1      
3188   1              MWIF_Send(IO_GPIO_THREE, io_TxBuf, len);
3189   1              
3190   1      }       /* End of IO_Gpio3RW */
3191          
3192          void IO_ZPHYTestW(void)
3193          {
3194   1              MWIF_Send(0x6d, NULL, 0);
3195   1      }
3196          
3197          void IO_WMIBTestW(U8_T XDATA enable)
3198          {
3199   1              MWIF_Send(0x6e, &enable, 1);
3200   1      }
3201          
3202          void IO_APNFTW(void)
3203          {
3204   1              MWIF_Send(0x6f, NULL, 0);
3205   1      }
3206          
3207          void IO_ENCTW(void)
3208          {
3209   1              io_TxBuf[0] = 0x01;
3210   1      
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 53  

3211   1              MWIF_Send(0x6f, io_TxBuf, 1);
3212   1      }
3213          
3214          /*
3215           * ----------------------------------------------------------------------------
3216           * Function Name: IO_WifiDriverVer
3217           * Purpose: To read the WCPU firmware version
3218           * Params: none
3219           * Returns: none
3220           * Note: none
3221           * ----------------------------------------------------------------------------
3222           */
3223          void IO_WifiDriverVer(void)
3224          {
3225   1              MWIF_Send(IO_WIFI_DRIVER_VER_READ, NULL, 0);
3226   1              
3227   1      }       /* End of IO_WifiDriverVer */
3228          
3229          /*
3230           * ----------------------------------------------------------------------------
3231           * Function Name: io_ScanReportAck
3232           * Purpose: To reply a scan report acknowedgement to WCPU
3233           * Params: none
3234           * Returns: none
3235           * Note: none
3236           * ----------------------------------------------------------------------------
3237           */
3238          void io_ScanReportAck(void)
3239          {
3240   1              MWIF_Send(IO_SCAN_REPORT_ACK, NULL, 0);
3241   1              
3242   1      }       /* End of io_ScanReportAck */
3243          
3244          /*
3245           * ----------------------------------------------------------------------------
3246           * Function Name: IO_SiteSurveyReportAck
3247           * Purpose: To reply a site survey acknowedgement to WCPU
3248           * Params: none
3249           * Returns: none
3250           * Note: none
3251           * ----------------------------------------------------------------------------
3252           */
3253          void IO_SiteSurveyReportAck(void)
3254          {
3255   1              MWIF_Send(IO_SITE_SURVEY_REPORT_ACK, NULL, 0);
3256   1      
3257   1      }       /* End of IO_SiteSurveyReportAck */
3258          
3259          /*
3260           * ----------------------------------------------------------------------------
3261           * Function Name: io_SensitivityTestReportACK
3262           * Purpose: To reply a sensitivity test report acknowedgement to WCPU
3263           * Params: none
3264           * Returns: none
3265           * Note: none
3266           * ----------------------------------------------------------------------------
3267           */
3268          void io_SensitivityTestReportACK(void)
3269          {
3270   1              MWIF_Send(IO_SENSITIVITY_TEST_REPORT_ACK, NULL, 0);
3271   1      
3272   1      }       /* End of io_SensitivityTestReportACK */
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 54  

3273          
3274          /*
3275           * ----------------------------------------------------------------------------
3276           * Function Name: IO_SetTimerCharCmd
3277           * Purpose: 
3278           * Params:
3279           * Returns:
3280           * Note: Should be removed after debugging.
3281           * ----------------------------------------------------------------------------
3282           */
3283          void IO_SetTimerCharCmd(U8_T num, U8_T mode, U16_T range, U8_T divider)
3284          {
3285   1              io_TxBuf[0] = num;
3286   1              io_TxBuf[1] = mode;
3287   1              io_TxBuf[2] = (U8_T)(range >> 8);
3288   1              io_TxBuf[3] = (U8_T)range;
3289   1              io_TxBuf[4] = divider;
3290   1      
3291   1              MWIF_Send(0x67, io_TxBuf, 5);
3292   1      }
3293          
3294          /*
3295           * ----------------------------------------------------------------------------
3296           * Function Name: IO_SetTimer2CharCmd
3297           * Purpose: 
3298           * Params:
3299           * Returns:
3300           * Note: Should be removed after debugging.
3301           * ----------------------------------------------------------------------------
3302           */
3303          void IO_SetTimer2CharCmd(U8_T mode, U16_T range, U8_T divider)
3304          {
3305   1              io_TxBuf[0] = mode;
3306   1              io_TxBuf[1] = (U8_T)(range >> 8);
3307   1              io_TxBuf[2] = (U8_T)range;
3308   1              io_TxBuf[3] = divider;
3309   1      
3310   1              MWIF_Send(0x68, io_TxBuf, 4);
3311   1      }
3312          
3313          /*
3314           * ----------------------------------------------------------------------------
3315           * Function Name: IO_SetTimerRunCmd
3316           * Purpose: 
3317           * Params:
3318           * Returns:
3319           * Note: Should be removed after debugging.
3320           * ----------------------------------------------------------------------------
3321           */
3322          void IO_SetTimerRunCmd(U8_T timer, U8_T sw)
3323          {
3324   1              io_TxBuf[0] = timer;
3325   1              io_TxBuf[1] = sw;
3326   1      
3327   1              MWIF_Send(0x69, io_TxBuf, 2);
3328   1      }
3329          
3330          /*
3331           * ----------------------------------------------------------------------------
3332           * Function Name: IO_SetTimerInterruptCmd
3333           * Purpose: 
3334           * Params:
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 55  

3335           * Returns:
3336           * Note: Should be removed after debugging.
3337           * ----------------------------------------------------------------------------
3338           */
3339          void IO_SetTimerInterruptCmd(U8_T timer, U8_T run)
3340          {
3341   1              io_TxBuf[0] = timer;
3342   1              io_TxBuf[1] = run;
3343   1      
3344   1              MWIF_Send(0x6a, io_TxBuf, 2);
3345   1      }
3346          
3347          /*
3348           * ----------------------------------------------------------------------------
3349           * Function Name: IO_SetUartCharCmd
3350           * Purpose: 
3351           * Params:
3352           * Returns:
3353           * Note: Should be removed after debugging.
3354           * ----------------------------------------------------------------------------
3355           */
3356          void IO_SetUartCharCmd(U8_T uart, U8_T mode, U8_T timer, U8_T baud, U8_T db, U8_T clkdiv)
3357          {
3358   1              io_TxBuf[0] = uart;
3359   1              io_TxBuf[1] = mode;
3360   1              io_TxBuf[2] = timer;
3361   1              io_TxBuf[3] = baud;
3362   1              io_TxBuf[4] = db;
3363   1              io_TxBuf[5] = clkdiv;
3364   1      
3365   1              MWIF_Send(0x6b, io_TxBuf, 6);
3366   1      }
3367          
3368          /*
3369           * ----------------------------------------------------------------------------
3370           * Function Name: IO_SetUartInterruptCmd
3371           * Purpose: 
3372           * Params:
3373           * Returns:
3374           * Note: Should be removed after debugging.
3375           * ----------------------------------------------------------------------------
3376           */
3377          void IO_SetUartInterruptCmd(U8_T uart, U8_T sw)
3378          {
3379   1              io_TxBuf[0] = uart;
3380   1              io_TxBuf[1] = sw;
3381   1      
3382   1              MWIF_Send(0x6c, io_TxBuf, 2);
3383   1      }
3384          
3385            #endif /* (MAC_ARBIT_MODE & MAC_ARBIT_WIFI) */
3386          /*****************************************************************/
3387          #else   /***** Middle of IO_CPU_TYPE, Below are for WCPU use *****/
              
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: 
               * Purpose: 
               * Params:
               * Returns:
               * Note:
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 56  

               * ----------------------------------------------------------------------------
               */
              U8_T IO_CmdParsing(U8_T* pbuf)
              {
                      U8_T XDATA len, value8;
                      U8_T XDATA reg[64];
                      U16_T value16;
                      U32_T value32;
                      
              #if IO_SHOWCMD
                      io_ShowCmd(0, pbuf);
              #endif
              
                      if ((pbuf[0] | pbuf[1]) != 0xFF)
                              return IO_COMMAND_ERROR;
                      {
                              switch (pbuf[0])
                              {
                              case IO_MCPU_WCPU_READY:
                                      WCPU_McpuReady = 1;
                                      IO_NoticeMcpu(IO_MCPU_WCPU_READY_ACK, NULL, 0);
                                      printf ("Rcv MCPU Ready Command.\n\r");
                                      break;
                              case IO_MCPU_WCPU_READY_ACK:
                                      WCPU_McpuReady = 1;
                                      printf ("Rcv WCPU Ready ACK Command.\n\r");
                                      break;
                              case IO_WCPU_RESET:
                                      io_ResetAck();
                                      printf ("Rcv MCPU Reset Command.\n\r");
                                      break;
                              case IO_MCPU_WCPU_CONNECT_ACK:
                                      printf ("Rcv WiFi Connect Command Ack.\n\r");
                                      break;
                              case IO_MCPU_WCPU_DISCONNECT_RESP:
                                      printf ("Rcv WiFi Disconnect Command Response.\n\r");
                                      break;
                              case IO_SCAN:
                                      if (pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      IO_ScanFromMcpu = 1;
                                      MGR_IOScan();
                                      io_ScanAck();
                                      break;
                              case IO_SCAN_REPORT_ACK:
                                      if (pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_SITE_SURVEY:
                                      if (pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      io_SiteSurveyAck();
                                      IO_SiteSurveyFromMcpu = 1;
                                      MGR_IOSiteSurvey();
                                      break;
                              case IO_SITE_SURVEY_REPORT_ACK:
                                      if (pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_JOIN_BSS:
                                      if (pbuf[2] != 1)
                                              return IO_COMMAND_ERROR;
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 57  

                                      printf ("Join BSS index: %bd\n\r", pbuf[3]);
                                      io_JoinBssAck();
                                      MGR_IOJoinBss(pbuf[3]);
                                      break;
                              case IO_SSID_READ:
                                      if (pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      MGR_IOSsid(IO_COMMAND_READ, reg, &len);
                                      io_SsidAckRW(IO_COMMAND_READ, len, reg);
                                      break;
                              case IO_SSID_WRITE:
                                      if (pbuf[2] > 32)
                                              return IO_COMMAND_ERROR;
                                      io_SsidAckRW(IO_COMMAND_WRITE, len, reg);
                                      MGR_IOSsid(IO_COMMAND_WRITE, &pbuf[3], &pbuf[2]);
                                      break;
                              case IO_OPERATE_MODE:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              io_OperateModeAckRW(IO_COMMAND_WRITE, value8);
                                              MGR_IOBBMode(IO_COMMAND_WRITE, &pbuf[4]);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IOBBMode(IO_COMMAND_READ, &value8);
                                              io_OperateModeAckRW(IO_COMMAND_READ, value8);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_CHANNEL:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IOChannel(IO_COMMAND_WRITE, &pbuf[4]);
                                              io_ChannelAckRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IOChannel(IO_COMMAND_READ, &value8);
                                              io_ChannelAckRW(IO_COMMAND_READ, value8);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_NETWORK_MODE:
                                      if (pbuf[3] == IO_COMMAND_WRITE)        // write
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IONetWorkType(IO_COMMAND_WRITE, &pbuf[4]);
                                              io_NetworkModeAckRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 58  

                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IONetWorkType(IO_COMMAND_READ, &value8);
                                              io_NetworkModeAckRW(IO_COMMAND_READ, value8);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_MULTICAST_SET:
                                      if (pbuf[2] != 6)
                                              return IO_COMMAND_ERROR;
                                      WIFI_SetMultiFilter(1, &pbuf[3]);
                                      io_SetMulticastMacAck();
                                      break;
                              case IO_WIFI_MAC_ADDR_SET:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 7)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IOMacAddr(IO_COMMAND_WRITE, &pbuf[4]);
                                              io_WiFiMacAckRW(IO_COMMAND_WRITE, reg);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              MGR_IOMacAddr(IO_COMMAND_READ, reg);
                                              io_WiFiMacAckRW(IO_COMMAND_READ, reg);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_WIFI_RADIO_ON_OFF:
                                      if (pbuf[2] != 1)
                                              return IO_COMMAND_ERROR;
                                      if (pbuf[3] == 0)
                                      {
                                              io_RadioOnOffAck(HW_RadioOnOff(1, 0));
              #if POWER_SAVING
                                              PS_BusyTimeout = 0xFF;
              #endif
                                              IO_NoticeMcpu(IO_MCPU_WCPU_DISCONNECT, NULL, 0);
                                              MGR_ChangeSetting();
                                              WCPU_LedCtl(LED_UNLINK);
                                      }
                                      else if (pbuf[3] == 1)
                                      {
                                              io_RadioOnOffAck(HW_RadioOnOff(1, 1));
                                              if (MAC_Inform.Mode == MAC_MODE_IBSS_STA)
                                              {
                                                      WCPU_LedCtl(LED_SCAN);
                                              }
                                      }
                                      else if (pbuf[3] == 2)
                                      {
                                              if (HW_RadioOnOff(0, 0))
                                                      io_RadioOnOffAck(2);
                                              else
                                                      io_RadioOnOffAck(3);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_WIFI_B_G_PROTECTION:
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 59  

                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IOBGProtection(1, &pbuf[4]);
                                              io_BgProtectionRespRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IOBGProtection(0, &value8);
                                              io_BgProtectionRespRW(IO_COMMAND_READ, value8);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_ENCRYPTION_TYPE:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IOEncryptType(IO_COMMAND_WRITE, &pbuf[4]);
                                              io_EncryptionAckRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IOEncryptType(IO_COMMAND_READ, &value8);
                                              io_EncryptionAckRW(IO_COMMAND_READ, value8);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_OPEN_SYSTEM:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IOAuthenAlgorithm(IO_COMMAND_WRITE, &pbuf[4]);
                                              io_OpenSysAckRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IOAuthenAlgorithm(IO_COMMAND_READ, &value8);
                                              io_OpenSysAckRW(IO_COMMAND_READ, value8);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_WEP64_KEY_READ:
                                      if (pbuf[2] != 1)
                                              return IO_COMMAND_ERROR;
                                      MGR_IOWep64(IO_COMMAND_READ, pbuf[3], reg);
                                      io_Wep64KeyAckRW(IO_COMMAND_READ, reg);
                                      break;
                              case IO_WEP64_KEY_WRITE:
                                      if (pbuf[2] != 6)
                                              return IO_COMMAND_ERROR;
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 60  

                                      MGR_IOWep64(IO_COMMAND_WRITE, pbuf[3], &pbuf[4]);
                                      io_Wep64KeyAckRW(IO_COMMAND_WRITE, reg);
                                      break;
                              case IO_WEP128_KEY_READ:
                                      if (pbuf[2] != 1)
                                              return IO_COMMAND_ERROR;
                                      MGR_IOWep128(IO_COMMAND_READ, pbuf[3], reg);
                                      io_Wep128KeyAckRW(IO_COMMAND_READ, reg);
                                      break;
                              case IO_WEP128_KEY_WRITE:
                                      if (pbuf[2] != 14)
                                              return IO_COMMAND_ERROR;
                                      MGR_IOWep128(IO_COMMAND_WRITE, pbuf[3], &pbuf[4]);
                                      io_Wep128KeyAckRW(IO_COMMAND_WRITE, reg);
                                      break;
                              case IO_WEP_KEY_INDEX:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IOKeyId(IO_COMMAND_WRITE, &pbuf[4]);
                                              io_WepKeyIndexKeyRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IOKeyId(IO_COMMAND_READ, &value8);
                                              io_WepKeyIndexKeyRW(IO_COMMAND_READ, value8);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
              #if SUPPLICANT_SUPPORT
                              case IO_TKIP_AES_PASSPHASE_STRING_READ:
                                      if (pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      MGR_IOPassphrase(IO_COMMAND_READ, reg, &len);
                                      io_TkipAesAckRW(IO_COMMAND_READ, len, reg);
                                      break;
                              case IO_TKIP_AES_PASSPHASE_STRING_WRITE:
                                      if (!pbuf[2] || pbuf[2] > 64)
                                              return IO_COMMAND_ERROR;
                                      MGR_IOPassphrase(IO_COMMAND_WRITE, &pbuf[3], &pbuf[2]);
                                      io_TkipAesAckRW(IO_COMMAND_WRITE, len, reg);
                                      break;
              #endif
                              case IO_ERROR_COMMAND:
                                      if (pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      printf("Drop bad command\n\r");
                                      break;
                              case IO_FRAGMENT_THRESHOLD_READ:
                                      if (pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      MGR_IOFragSize(IO_COMMAND_READ, &value16);
                                      io_FragmentThresholdAckRW(IO_COMMAND_READ, (U8_T XDATA*)&value16);
                                      break;
                              case IO_FRAGMENT_THRESHOLD_WRITE:
                                      if (pbuf[2] != 2)
                                              return IO_COMMAND_ERROR;
                                      MGR_IOFragSize(IO_COMMAND_WRITE, (U16_T XDATA*)&pbuf[3]);
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 61  

                                      io_FragmentThresholdAckRW(IO_COMMAND_WRITE, (U8_T XDATA*)&value16);
                                      break;
                              case IO_RTS_THRESHOLD_READ:
                                      if (pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      MGR_IORtsThreshold(IO_COMMAND_READ, &value16);
                                      io_RtsIntervalAckRW(IO_COMMAND_READ, (U8_T XDATA*)&value16);
                                      break;
                              case IO_RTS_THRESHOLD_WRITE:
                                      if (pbuf[2] != 2)
                                              return IO_COMMAND_ERROR;
                                      MGR_IORtsThreshold(IO_COMMAND_WRITE, (U16_T XDATA*)&pbuf[3]);
                                      io_RtsIntervalAckRW(IO_COMMAND_WRITE, (U8_T XDATA*)&value16);
                                      break;
                              case IO_PREAMBLE:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IOPreamble(IO_COMMAND_WRITE, &pbuf[4]);
                                              io_PreambleAckRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IOPreamble(IO_COMMAND_READ, &value8);
                                              io_PreambleAckRW(IO_COMMAND_READ, value8);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_TX_POWER_LEVEL_READ:
                                      if (pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      io_TxGainRW(IO_COMMAND_READ, HW_Read_TxGain());
                                      break;
                              case IO_TX_POWER_LEVEL_WRITE:
                                      if (pbuf[2] != 1)
                                              return IO_COMMAND_ERROR;
                                      HW_Write_TxGain(pbuf[3]);
                                      io_TxGainRW(IO_COMMAND_WRITE, 0);
                                      break;
                              case IO_BEACON_INTERVAL_READ:
                                      if (pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      MGR_IOBcnInterval(IO_COMMAND_READ, &value16);
                                      io_BeaconIntervalAckRW(IO_COMMAND_READ, (U8_T XDATA*)&value16);
                                      break;
                              case IO_BEACON_INTERVAL_WRITE:
                                      if (pbuf[2] != 2)
                                              return IO_COMMAND_ERROR;
                                      MGR_IOBcnInterval(IO_COMMAND_WRITE, (U16_T XDATA*)&pbuf[3]);
                                      io_BeaconIntervalAckRW(IO_COMMAND_WRITE, (U8_T XDATA*)&value16);
                                      break;
                              case IO_COUNTRY_REGION:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] == 3)
                                              {
                                                      MGR_IOCountryRegion(IO_COMMAND_WRITE, (U16_T XDATA*)(&pbuf[4]));
                                                      io_CountryRegionAckRW(IO_COMMAND_WRITE, value16);
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 62  

                                              }
                                              else
                                              {
                                                      return IO_COMMAND_ERROR;
                                              }
                                      }
                                      else if (pbuf[3] == IO_COMMAND_READ)
                                      {
                                              if (pbuf[2] == 1)
                                              {
                                                      MGR_IOCountryRegion(IO_COMMAND_READ, &value16);
                                                      io_CountryRegionAckRW(IO_COMMAND_READ, value16);
                                              }
                                              else
                                              {
                                                      return IO_COMMAND_ERROR;
                                              }
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_ATIM_INTERVAL_READ:
                                      if (pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      MGR_IOAtimInterval(IO_COMMAND_READ, &value16);
                                      io_AtimIntervalAckRW(IO_COMMAND_READ, (U8_T XDATA*)&value16);
                                      break;
                              case IO_ATIM_INTERVAL_WRITE:
                                      if (pbuf[2] != 2)
                                              return IO_COMMAND_ERROR;
                                      MGR_IOAtimInterval(IO_COMMAND_WRITE, (U16_T XDATA*)&pbuf[3]);
                                      io_AtimIntervalAckRW(IO_COMMAND_WRITE, (U8_T XDATA*)&value16);
                                      break;
                              case IO_TX_DATA_RATE:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              if (0xff == HW_SetTxRate(pbuf[4]))
                                                      return IO_COMMAND_ERROR;
                                              io_TxDataRateRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              io_TxDataRateRW(IO_COMMAND_READ, HW_Inform.FixSpeed);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_AUTO_POWER_CONTROL:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] < 2)
                                                      return IO_COMMAND_ERROR;
                                              switch (pbuf[4])
                                              {
                                                      case 0:
                                                              MAC_CurSet.SwProfile[MAC_UserProfile].AutoPowerContol = 0;
                                                              WIFI_apcNeed = 0;
                                                              WIFI_AutoPowerControl(0, 0, 0, 0);
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 63  

                                                              break;
                                                      case 1:
                                                              MAC_CurSet.SwProfile[MAC_UserProfile].AutoPowerContol = 1;
                                                              WIFI_apcNeed = 1;
                                                              break;
                                                      default:
                                                              return IO_COMMAND_ERROR;
                                              }
                                              io_AutoPowerCtrlRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              io_AutoPowerCtrlRW(IO_COMMAND_READ, MAC_CurSet.SwProfile[MAC_UserProfile].AutoPowerContol);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_WIFI_ROAMING:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              //need roaming function...
                                              io_RoamingRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              //need roaming function...
                                              io_RoamingRW(IO_COMMAND_READ, value8);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_WIFI_MULTIMEDIA_SET:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              //need WMM function...
                                              io_WifiMultimediaSetRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              //need WMM function...
                                              io_WifiMultimediaSetRW(IO_COMMAND_READ, value8);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_LISTEN_INTERVAL:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 3)
                                                      return IO_COMMAND_ERROR;
                                              //need listen interval function...
                                              io_ListenIntervalRW(IO_COMMAND_WRITE, value16);
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 64  

                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              //need listen interval function...
                                              io_ListenIntervalRW(IO_COMMAND_READ, value16);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                      case IO_MINIMUM_CONTENTION_WINDOW:
                          if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 3)
                                                      return IO_COMMAND_ERROR;
                                              //need contention window function...
                                              io_MinContentionWindowRW(IO_COMMAND_WRITE, value16);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              //need contention window function...
                                              io_MinContentionWindowRW(IO_COMMAND_READ, value16);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_MAXIMUM_CONTENTION_WINDOW:
                          if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 3)
                                                      return IO_COMMAND_ERROR;
                                              //need contention window function...
                                              io_MaxContentionWindowRW(IO_COMMAND_WRITE, value16);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              //need contention window function...
                                              io_MaxContentionWindowRW(IO_COMMAND_READ, value16);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_SHOW_RSSI:
                                      if (pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      value8 = MGR_IORssi();
                                      io_ShowRssiResp(value8);
                                      break;
                              case IO_PAYLOAD_LENGTH_ATTACH_IN_WIFI_PACKET:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              //need payload length in WiFi function...
                                              io_PayloadLenAddInWifiRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 65  

                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              //need payload length in WiFi function...
                                              io_PayloadLenAddInWifiRW(IO_COMMAND_READ, value8);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_RETAIN_LLC_IN_WIFI_PACKET:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              //need retain LLC in WiFi function...
                                              io_RetainLlcInWifiRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              //need retain LLC in WiFi function...
                                              io_RetainLlcInWifiRW(IO_COMMAND_READ, value8);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_2_LLC_IN_WIFI_VLAN_PACKET:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              //need to add 2 LLC in WiFi VLAN function...
                                              io_2LlcInWiFiVlanPacketRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              //need to add 2 LLC in WiFi VLAN function...
                                              io_2LlcInWiFiVlanPacketRW(IO_COMMAND_READ, value8);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_TRAFFIC_PROFILE:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
              
                                              if (pbuf[4] == MAC_CurSet.SwProfile[MAC_UserProfile].TrafficProfile)
                                              {
                                                      printf("Same as current traffic profile.\n\r");
                                              }
                                              else if (MAC_Inform.State >= MAC_STATE_JOINED)
                                              {
                                                      MAC_SetTrafficProfile(pbuf[4]);
                                              }
                                              else
                                              {
                                                      if (pbuf[4] <= AC_DF)
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 66  

                                                      {
                                                              MAC_CurSet.SwProfile[MAC_UserProfile].TrafficProfile = pbuf[4];
                                                      }
                                                      else
                                                      {
                                                              printf("Incorrect profile number !!\n\r");
                                                      }
                                              }
                                              io_TrafficProfileRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              io_TrafficProfileRW(IO_COMMAND_READ, MAC_CurSet.SwProfile[MAC_UserProfile].TrafficProfile);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_TX_DEFAULT_POWER_LEVEL:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              if (pbuf[4] == MAC_CurSet.SwProfile[MAC_UserProfile].PowerLevel)
                                              {
                                                      io_TxDefaultPowerLevelRW(IO_COMMAND_WRITE, 0xff);
                                              }
                                              else
                                              {
                                                      MAC_IOTxPowerLevel(1, pbuf[4]);
                                                      io_TxDefaultPowerLevelRW(IO_COMMAND_WRITE, MAC_CurSet.SwProfile[MAC_UserProfile].PowerLevel);
                                              }
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              io_TxDefaultPowerLevelRW(IO_COMMAND_READ, MAC_CurSet.SwProfile[MAC_UserProfile].PowerLevel);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_QUEUE_PRIORITY_SET:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              // please modify the code you need and call "io_QueuePrioritySetRW(U8_T rw, U8_T index, U8_T priority)
             -" function
              #if (QOS_SUPPORT - QOS_ONE_QUEUE)
                                              io_QueuePrioritySetRW(IO_COMMAND_WRITE, MAC_ExchangePriority(1, pbuf[4]));
              #else
                                              io_QueuePrioritySetRW(IO_COMMAND_WRITE, 0xFE);
              #endif
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              // please modify the code you need and call "io_QueuePrioritySetRW(U8_T rw, U8_T index, U8_T priority)
             -" function
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 67  

              #if (QOS_SUPPORT - QOS_ONE_QUEUE)
                                              io_QueuePrioritySetRW(IO_COMMAND_READ, MAC_ExchangePriority(0, 0));
              #else
                                              io_QueuePrioritySetRW(IO_COMMAND_READ, 0xFE);
              #endif
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_SELF_CTS:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              MAC_CurSet.SwProfile[MAC_UserProfile].SelfCTS = pbuf[4];
                                              io_SelfCtsRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              io_SelfCtsRW(IO_COMMAND_READ, MAC_CurSet.SwProfile[MAC_UserProfile].SelfCTS);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_BSSID:
                                      if (pbuf[3] == IO_COMMAND_READ)
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IOGetBssid(reg);
                                              io_BssidR(reg);
                                      }
                                      break;
                              case IO_WIFI_IP_READ:
                                      if (pbuf[2] != 0)
                                              return IO_COMMAND_ERROR;
                                      io_WifiIpR(MAC_IOGetSecIp());
                                      break;
                              case IO_WIFI_DRIVER_VER_READ:
                                      if (pbuf[2] != 0)
                                              return IO_COMMAND_ERROR;
                                      io_WifiDriverVerR(MAC_IOGetDriverVer());
                                      break;
              #if MASS_PRODUCTION
                              case IO_CONTINUOUS_TX:
                                      if (pbuf[2] != 1)
                                              return IO_COMMAND_ERROR;
                                      DBG_ContinuousTx(pbuf[3]);
                                      io_ContinuousTxAck(pbuf[3]);
                                      break;
                              case IO_SENSITIVITY_TEST:
                                      if (!pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      
                                      if (pbuf[5] == 1)
                                      {
                                              dbg_senTestSource = 0; //Inspire
                                      }
                                      else if (pbuf[5] == 2)
                                      {
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 68  

                                              dbg_senTestSource = 1; //N4010A
                                      }
                                      else
                                      {
                                              dbg_senTestSource = 0; //Inspire
                                      }
              
                                      DBG_SensitivityTest(1, *((U16_T *)&pbuf[3]));
                                      io_SensitivityTestAck(&pbuf[3]);
                                      break;
                              case IO_SENSITIVITY_TEST_REPORT:
                                      if (pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      DBG_SensitivityTest(0, *((U16_T *)&pbuf[3]));
                                      io_SensitivityTestReportAck();
                                      break;
              #endif
                              case IO_DBG_WCPU_SFR_READ:
                                      if (pbuf[2] != 1)
                                              return IO_COMMAND_ERROR;
                                      if (0xff == io_SfrIO(IO_COMMAND_READ, pbuf[3], &value8))
                                              return IO_COMMAND_ERROR;
                                      io_SfrAckRW(IO_COMMAND_READ, value8);
                                      break;
                              case IO_DBG_WCPU_SFR_WRITE:
                                      if (pbuf[2] != 2)
                                              return IO_COMMAND_ERROR;
                                      if (0xff == io_SfrIO(IO_COMMAND_WRITE, pbuf[3], &pbuf[4]))
                                              return IO_COMMAND_ERROR;
                                      io_SfrAckRW(IO_COMMAND_WRITE, value8);
                                      break;
                              case IO_DBG_WCPU_SUB_SYS_REG_READ:
                                      if (pbuf[2] != 1)
                                              return IO_COMMAND_ERROR;
                                      len = WCPU_IndirectIO(IO_COMMAND_READ, pbuf[3], reg);
                                      if (0xff == len)
                                              return IO_COMMAND_ERROR;
                                      io_WcpuIndirectAckRW(IO_COMMAND_READ, len, reg);
                                      break;
                              case IO_DBG_WCPU_SUB_SYS_REG_WRITE:
                                      if (pbuf[2] < 2)
                                              return IO_COMMAND_ERROR;
                                      len = WCPU_IndirectIO(IO_COMMAND_WRITE, pbuf[3], &pbuf[4]);
                                      if (0xff == len)
                                              return IO_COMMAND_ERROR;
                                      io_WcpuIndirectAckRW(IO_COMMAND_WRITE, len, reg);
                                      break;
                              case IO_DBG_WCPU_MIIB_REG_READ:
                                      if (pbuf[2] != 1)
                                              return IO_COMMAND_ERROR;
                                      len = MIB_IndirectIO(IO_COMMAND_READ, pbuf[3], reg);
                                      if (0xff == len)
                                              return IO_COMMAND_ERROR;
                                      io_MiibIndirectAckRW(IO_COMMAND_READ, len, reg);
                                      break;
                              case IO_DBG_WCPU_MIIB_REG_WRITE:
                                      if (pbuf[2] < 2)
                                              return IO_COMMAND_ERROR;
                                      len = MIB_IndirectIO(IO_COMMAND_WRITE, pbuf[3], &pbuf[4]);
                                      if (0xff == len)
                                              return IO_COMMAND_ERROR;
                                      io_MiibIndirectAckRW(IO_COMMAND_WRITE, len, reg);
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 69  

                                      break;
                              case IO_DBG_WCPU_PCIB_REG_READ:
                                      if (pbuf[2] != 1)
                                              return IO_COMMAND_ERROR;
                                      len = PCIB_IndirectIO(IO_COMMAND_READ, pbuf[3], reg);
                                      if (0xff == len)
                                      return IO_COMMAND_ERROR;
                                      io_PcibIndirectRegAckRW(IO_COMMAND_READ, len, reg);
                                      break;
                              case IO_DBG_WCPU_PCIB_REG_WRITE:
                                      if (pbuf[2] < 2)
                                              return IO_COMMAND_ERROR;
                                      len = PCIB_IndirectIO(IO_COMMAND_WRITE, pbuf[3], &pbuf[4]);
                                      if (0xff == len)
                                      return IO_COMMAND_ERROR;
                                      io_PcibIndirectRegAckRW(IO_COMMAND_WRITE, len, reg);
                                      break;
                              case IO_DBG_PCI_CONFIGURATION_READ:
                                      if (pbuf[2] != 1)
                                              return IO_COMMAND_ERROR;
                                      PCIB_PciRead(PCIB_CONFIG_MODE, pbuf[3], reg);
                                      io_PciConfigAckRW(IO_COMMAND_READ, reg);
                                      break;
                              case IO_DBG_PCI_CONFIGURATION_WRITE:
                                      if (pbuf[2] < 2)
                                              return IO_COMMAND_ERROR;
                                      PCIB_PciWrite(PCIB_CONFIG_MODE, pbuf[3], &pbuf[4]);
                                      io_PciConfigAckRW(IO_COMMAND_WRITE, reg);
                                      break;
                              case IO_DBG_WIFI_REG_READ:
                                      if (pbuf[2] != 2)
                                              return IO_COMMAND_ERROR;
                                      if (0xff == io_WifiRegIO(IO_COMMAND_READ, *((U16_T*)&pbuf[3]), &value32))
                                              return IO_COMMAND_ERROR;
                                      io_WiFiRegAckRW(IO_COMMAND_READ, (U8_T XDATA*)&value32);
                                      break;
                              case IO_DBG_WIFI_REG_WRITE:
                                      if (pbuf[2] != 6)
                                              return IO_COMMAND_ERROR;
                                      if (0xff == io_WifiRegIO(IO_COMMAND_WRITE, *((U16_T*)&pbuf[3]), (U32_T XDATA*)&pbuf[5]))
                                              return IO_COMMAND_ERROR;
                                      io_WiFiRegAckRW(IO_COMMAND_WRITE, (U8_T XDATA*)&value32);
                                      break;
                              case IO_DBG_WIFI_PACKET_FILTERING_WRITE:
                                      if (pbuf[2] != 9)
                                              return IO_COMMAND_ERROR;
                                      PCIB_WlanPktFilterIO(IO_COMMAND_WRITE, &pbuf[3], (U16_T XDATA*)&pbuf[4], &pbuf[6]);
                                      io_WlanPktFilterAckRW(IO_COMMAND_WRITE, value8, value16, reg);
                                      break;
                              case IO_DBG_WIFI_PACKET_FILTERING_READ:
                                      if (pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      PCIB_WlanPktFilterIO(IO_COMMAND_READ, &value8, &value16, reg);
                                      io_WlanPktFilterAckRW(IO_COMMAND_READ, value8, value16, reg);
                                      break;
                              case IO_DBG_SYNTHESIZER_SET:
                                      if (pbuf[2] != 4)
                                              return IO_COMMAND_ERROR;
              
                                      HW_3W_IF_Synthesizer(dbg_SYNBitReverse(*((U32_T XDATA*)&pbuf[3])));
                                      io_SynthesizerSetAck();
                                      break;
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 70  

                              case IO_DBG_RETRY_NUMBER:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IORetry(IO_COMMAND_WRITE, &pbuf[4]);
                                              io_RetryAckRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IORetry(IO_COMMAND_READ, &value8);
                                              io_RetryAckRW(IO_COMMAND_READ, value8);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_GPIO_ZERO:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              P0 = pbuf[4];
                                              io_Gpio0RW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              io_Gpio0RW(IO_COMMAND_READ, P0);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_GPIO_ONE:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              P1 = pbuf[4];
                                              io_Gpio1RW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              io_Gpio1RW(IO_COMMAND_READ, P1);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_GPIO_TWO:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              P2 = pbuf[4];
                                              io_Gpio2RW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 71  

                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              io_Gpio2RW(IO_COMMAND_READ, P2);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_GPIO_THREE:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              P3 = pbuf[4];
                                              io_Gpio3RW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              io_Gpio3RW(IO_COMMAND_READ, P3);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_DBG_AUTO_POWER_CONTROL:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if ((pbuf[2] != 3) && (pbuf[4] != 2))
                                                      return IO_COMMAND_ERROR;
                                              if (MAC_Inform.State >= MAC_STATE_JOINED)
                                              {
                                                      MAC_CurSet.SwProfile[MAC_UserProfile].AutoPowerContol = 1;
                                                      WIFI_AutoPowerControl(0, 0, 0, 1);
                                                      value32 = (U32_T)pbuf[5];
                                                      if (0xff == io_WifiRegIO(IO_COMMAND_WRITE, 0x007c, &value32))
                                                              return IO_COMMAND_ERROR;
                                              }
                                              io_AutoPowerCtrlDetailW();
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_WLAN_DEBUG1_RESP:
                                      break;
                              default:
                                      return IO_COMMAND_ERROR;
                              }
                      }
              
                      return IO_COMMAND_DONE;
              }
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: IO_NoticeMcpu
               * Purpose: To management CPU connect, disconnect, and ready commands
               * Params: U8_T  type - The type of the command
               *         U8_T* pbuf - The start pointer of the payload buffer
               *         U8_T  len  - Length of the payload
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 72  

               */
              void IO_NoticeMcpu(U8_T type, U8_T* pbuf, U8_T len)
              {
                      U8_T XDATA                      i;
                      static U8_T XDATA       avoidRepeat = 0;
              
                      if (type == IO_MCPU_WCPU_CONNECT)
                      {
              #if SUPPLICANT_SUPPORT
                              SUP_notice = 0;
              #endif
              #if QOS_SUPPORT
                              if (MAC_Inform.CurWmmMode)
                              {
                                      HW_QosSetting();
                              }
              #endif
                              /* Check out if need to set custom traffic profile */
                              {
                                      MAC_SetTrafficProfile(MAC_CurSet.SwProfile[MAC_UserProfile].TrafficProfile);
                              }
                              
                              if (avoidRepeat == 1)
                              {
                                      return;
                              }
                              
                              /* Enable receiving PKT of MIB */
                              MIB_IndirectIO(0, MIB_TX_CONTROL, &i);
                              i |= MIB_RCV_ENABLE;
                              MIB_IndirectIO(1, MIB_TX_CONTROL, &i);
              
                              avoidRepeat = 1;
                      }
                      else if (type == IO_MCPU_WCPU_DISCONNECT)
                      {
              #if SUPPLICANT_SUPPORT
                              SUP_notice = 1;
              #endif
                              if (avoidRepeat == 2)
                              {
                                      return;
                              }
                              
                              /* Disable receiving PKT of MIB */
                              MIB_IndirectIO(0, MIB_TX_CONTROL, &i);
                              i &= ~(MIB_RCV_ENABLE);
                              MIB_IndirectIO(1, MIB_TX_CONTROL, &i);
                              
                              avoidRepeat = 2;
                      }
              
                      if (WCPU_McpuReady || type == IO_MCPU_WCPU_READY)
                      {
                              MWIF_Send(type, pbuf, len);
                      }
              
              } /* End of IO_NoticeMcpu() */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: IO_ScanReport
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 73  

               * Purpose: To reply the scanning result to MCPU
               * Params: U8_T result - 1: no find any BSS, generate itself
               *                       2: no find any BSS, rescan
               *                       3: find a BSS
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void IO_ScanReport(U8_T result)
              {
                      U8_T    len = 0;
              
                      switch (result)
                      {
                      case 1: // Not found any BSS, generate a new IBSS
                      case 2: // Not found any BSS, rescan
                              len = 1;
                              io_TxBuf[0] = result;
                              break;
                      case 3: // BSS is found
                              io_TxBuf[0] = result;
                              len = sizeof (MGR_KNOWN_BSS);
                              memcpy(&io_TxBuf[1], &MGR_Inform.BssList[0], len);
                              len += 1;
                              break;
                      }
              
                      MWIF_Send(IO_SCAN_REPORT, io_TxBuf, len);
                      
              }       /* End of IO_ScanReport */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: IO_SiteSurveyReport
               * Purpose: To reply site survey result to MCPU
               * Params: U8_T BssNum - The order of BSS
               *         U8_T IsTheLast - 0: Not the last BSS
               *                          1: Is the last BSS
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void IO_SiteSurveyReport(U8_T BssNum, U8_T IsTheLast)
              {
                      MGR_BSSID XDATA*        pBSS = &MGR_Inform.BssInform[BssNum];
                      U8_T                            i, len;
                      U8_T XDATA*                     ptr;
                      
                      if (IsTheLast != 2)     // find a BSS at least
                      {
                              io_TxBuf[0] = BssNum;
                              io_TxBuf[1] = pBSS->MacAddr[0];
                              io_TxBuf[2] = pBSS->MacAddr[1];
                              io_TxBuf[3] = pBSS->MacAddr[2];
                              io_TxBuf[4] = pBSS->MacAddr[3];
                              io_TxBuf[5] = pBSS->MacAddr[4];
                              io_TxBuf[6] = pBSS->MacAddr[5];
                              io_TxBuf[7] = pBSS->InfrastructureMode;
                              io_TxBuf[8] = pBSS->Config.Channel;
                              io_TxBuf[9] = pBSS->Rssi;
                              io_TxBuf[10] = pBSS->EncryptMode;
                              io_TxBuf[11] = IsTheLast;
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 74  

                              ptr = &io_TxBuf[12];
                              len = pBSS->Ssid.SsidLength;
                              for (i = 0; i < len; i++)
                              {
                                      ptr[i] = pBSS->Ssid.Ssid[i];
                              }
                              len = len + 12;
                      }
                      else    // can't find any BSS
                      {
                              len = 1;
                              io_TxBuf[0] = 0;
                      }       
              
                      MWIF_Send(IO_SITE_SURVEY_REPORT, io_TxBuf, len);
              
              }       /* End of IO_SiteSurveyReport */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_ResetAck
               * Purpose: To reply a acknowedgement to MCPU
               * Params: none
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_ResetAck(void)
              {
                      MWIF_Send(IO_WCPU_RESET_ACK, NULL, 0);
                      
              }       /* End of io_ResetAck */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_ScanAck
               * Purpose: To reply a acknowedgement to MCPU
               * Params: none
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_ScanAck(void)
              {
                      MWIF_Send(IO_SCAN_ACK, NULL, 0);
                      
              }       /* End of io_ScanAck */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_SiteSurveyAck
               * Purpose: To reply a acknowedgement to MCPU
               * Params: none
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_SiteSurveyAck(void)
              {
                      MWIF_Send(IO_SITE_SURVEY_ACK, NULL, 0);
                      
              }       /* End of io_SiteSurveyAck */
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 75  

              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_JoinBssAck
               * Purpose: To reply a acknowedgement to MCPU
               * Params: none
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_JoinBssAck(void)
              {
                      MWIF_Send(IO_JOIN_BSS_ACK, NULL, 0);
                      
              }       /* End of io_JoinBssAck */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_SsidAckRW
               * Purpose: To reply a writing acknowedgement or the SSID to MCPU
               * Params: U8_T  type - 0: read 1: write
               *         U8_T  len - The SSID length
               *         U8_T* pReg - Start pointer of the buffer to save SSID
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_SsidAckRW(U8_T type, U8_T len, U8_T XDATA* pReg)
              {
                      if (type == IO_COMMAND_WRITE)
                      {
                              MWIF_Send(IO_SSID_WRITE_ACK, NULL, 0);
                      }
                      else
                      {
                              memcpy(&io_TxBuf[0], pReg, len);
              
                              MWIF_Send(IO_SSID_READ_RESP, io_TxBuf, len);
                      }
              }       /* End of io_SsidRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_OperateModeAckRW
               * Purpose: To reply a writing acknowledgement or the WiFi operating mode to MCPU
               * Params: U8_T type - 1: write command 0: read command
               *         U8_T value - WiFi operating mode
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_OperateModeAckRW(U8_T type, U8_T value)
              {
                      U8_T    len;
              
                      if (type == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 76  

                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = value;
                      }
              
                      MWIF_Send(IO_OPERATE_MODE_RESP, io_TxBuf, len);
                      
              }       /* End of io_OperateModeAckRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_ChannelAckRW
               * Purpose: To reply a writing acknowledgement or the WiFi channel to MCPU
               * Params: U8_T type - 1: write command 0: read command
               *         U8_T value - WiFi channel value
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_ChannelAckRW(U8_T type, U8_T value)
              {
                      U8_T    len;
              
                      if (type == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = value;
                      }
              
                      MWIF_Send(IO_CHANNEL_RESP, io_TxBuf, len);
                      
              }       /* End of io_ChannelAckRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_NetworkModeAckRW
               * Purpose: To reply a writing acknowledgement or the WiFi network mode to MCPU
               * Params: U8_T type - 1: write command 0: read command
               *         U8_T value - WiFi network mode
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_NetworkModeAckRW(U8_T type, U8_T value)
              {
                      U8_T    len;
              
                      if (type == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 77  

                              io_TxBuf[1] = value;
                      }
              
                      MWIF_Send(IO_NETWORK_MODE_RESP, io_TxBuf, len);
                      
              }       /* End of io_NetworkModeAckRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_SetMulticastMacAck
               * Purpose: To reply a writing acknowledgement or the WiFi multicast MAC address to MCPU
               * Params: none
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_SetMulticastMacAck(void)
              {
                      MWIF_Send(IO_MULTICAST_SET_ACK, NULL, 0);
                      
              }       /* End of io_SetMulticastMacAck */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_WiFiMacAckRW
               * Purpose: To reply a writing acknowledgement or the WiFi MAC address to MCPU
               * Params: U8_T  type - 1: write command 0: read command
               *         U8_T* pReg - Start pointer of the WiFi MAC buffer
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_WiFiMacAckRW(U8_T type, U8_T XDATA* pReg)
              {
                      U8_T    len;
              
                      if (type == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = 1;
                      }
                      else
                      {
                              len = 7;
                              io_TxBuf[0] = 0;
                              memcpy(&io_TxBuf[1], pReg, 6);
                      }
              
                      MWIF_Send(IO_WIFI_MAC_ADDR_SET_RESP, io_TxBuf, len);
                      
              }       /* End of io_WiFiMacRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_RadioOnOffAck
               * Purpose: To reply a writing acknowledgement or the WiFi RF state to MCPU
               * Params: U8_T state - The state of WiFi RF
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_RadioOnOffAck(U8_T state)
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 78  

              {
                      io_TxBuf[0] = state;
              
                      MWIF_Send(IO_WIFI_RADIO_ON_OFF_ACK, io_TxBuf, 1);
              
              }       /* End of io_RadioOnOffAck */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_BgProtectionRespRW
               * Purpose: To reply a writing acknowledgement or the WiFi data rate to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  state - The state of bg protection mode
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_BgProtectionRespRW(U8_T rw, U8_T state)
              {
                      U8_T    len;
              
                      if (rw == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = state;
                      }
                      
                      MWIF_Send(IO_WIFI_B_G_PROTECTION_RESP, io_TxBuf, len);
              
              }       /* End of io_BgProtectionRespRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_EncryptionAckRW
               * Purpose: To reply a writing acknowledgement or the WiFi encryption type to MCPU
               * Params: U8_T type - 1: write command 0: read command
               *         U8_T value - WiFi encryption type
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_EncryptionAckRW(U8_T type, U8_T value)
              {
                      U8_T    len;
              
                      if (type == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = value;
                      }
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 79  

              
                      MWIF_Send(IO_ENCRYPTION_TYPE_RESP, io_TxBuf, len);
                      
              }       /* End of io_EncryptionAckRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_OpenSysAckRW
               * Purpose: To reply a writing acknowledgement or the open system mode to MCPU
               * Params: U8_T type - 1: write command 0: read command
               *         U8_T value - WiFi open system mode
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_OpenSysAckRW(U8_T type, U8_T value)
              {
                      U8_T    len;
              
                      if (type == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = value;
                      }
              
                      MWIF_Send(IO_OPEN_SYSTEM_RESP, io_TxBuf, len);
                      
              }       /* End of io_OpenSysAckRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_Wep64KeyRW
               * Purpose: To reply a writing acknowedgement or the WEP64 key to MCPU
               * Params: U8_T  type - 0: read 1: write
               *         U8_T* pReg - Start pointer of the buffer to save WEP64 key
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_Wep64KeyAckRW(U8_T type, U8_T XDATA* pReg)
              {
                      if (type)// write
                      {
                              MWIF_Send(IO_WEP64_KEY_WRITE_ACK, NULL, 0);
                      }
                      else
                      {
                              memcpy(&io_TxBuf[0], pReg, 5);
              
                              MWIF_Send(IO_WEP64_KEY_READ_RESP, io_TxBuf, 5);
                      }
              }       /* End of io_Wep64KeyRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_Wep128KeyAckRW
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 80  

               * Purpose: To reply a writing acknowedgement or the WEP128 key to MCPU
               * Params: U8_T  type - 0: read 1: write
               *         U8_T* pReg - Start pointer of the buffer to save WEP128 key
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_Wep128KeyAckRW(U8_T type, U8_T XDATA* pReg)
              {
                      if (type == IO_COMMAND_WRITE)
                      {
                              MWIF_Send(IO_WEP128_KEY_WRITE_ACK, NULL, 0);
                      }
                      else
                      {
                              memcpy(&io_TxBuf[0], pReg, 13);
              
                              MWIF_Send(IO_WEP128_KEY_READ_RESP, io_TxBuf, 13);
                      }
              }       /* End of io_Wep128KeyRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_WepKeyIndexKeyRW
               * Purpose: To reply a writing acknowledgement or the WEP key index to MCPU
               * Params: U8_T type - 1: write command 0: read command
               *         U8_T value - WEP key index
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_WepKeyIndexKeyRW(U8_T type, U8_T value)
              {
                      U8_T    len;
              
                      if (type == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = value;
                      }
              
                      MWIF_Send(IO_WEP_KEY_INDEX_RESP, io_TxBuf, len);
                      
              }       /* End of io_WepKeyIndexKeyRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_TkipAesAckRW
               * Purpose: To reply a writing acknowedgement or the TKIP/AES key to MCPU
               * Params: U8_T  type - 0: read 1: write
               *         U8_T  len - The TKIP/AES key length
               *         U8_T* pReg - Start pointer of the buffer to save TKIP/AES key
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 81  

              void io_TkipAesAckRW(U8_T type, U8_T len, U8_T XDATA* pReg)
              {
                      if (type == IO_COMMAND_WRITE)
                      {
                              MWIF_Send(IO_TKIP_AES_PASSPHASE_STRING_WRITE_ACK, NULL, 0);
                      }
                      else
                      {
                              memcpy(&io_TxBuf[0], pReg, len);
              
                              MWIF_Send(IO_TKIP_AES_PASSPHASE_STRING_READ_RESP, io_TxBuf, len);
                      }
              }       /* End of io_TkipAesRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_FragmentThresholdRW
               * Purpose: To reply a writing acknowedgement or the fragment threshold value to MCPU
               * Params: U8_T  type - 0: read 1: write
               *         U8_T* pValue - Start pointer of the butter to save fragment threshold value
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_FragmentThresholdAckRW(U8_T type, U8_T XDATA* pValue)
              {
                      if (type == IO_COMMAND_WRITE)
                      {
                              MWIF_Send(IO_FRAGMENT_THRESHOLD_WRITE_ACK, NULL, 0);
                      }
                      else
                      {
                              io_TxBuf[0] = *pValue;
                              io_TxBuf[1] = *(pValue + 1);
              
                              MWIF_Send(IO_FRAGMENT_THRESHOLD_READ_RESP, io_TxBuf, 2);
                      }
              }       /* End of io_FragmentThresholdRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_RtsThresholdRW
               * Purpose: To reply a writing acknowedgement or the RTS threshold value to MCPU
               * Params: U8_T  type - 0: read 1: write
               *         U8_T* pValue - Start pointer of the butter to save RTS threshold value
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_RtsIntervalAckRW(U8_T type, U8_T XDATA* pValue)
              {
                      if (type == IO_COMMAND_WRITE)
                      {
                              MWIF_Send(IO_RTS_THRESHOLD_WRITE_ACK, NULL, 0);
                      }
                      else
                      {
                              io_TxBuf[0] = *pValue;
                              io_TxBuf[1] = *(pValue + 1);
              
                              MWIF_Send(IO_RTS_THRESHOLD_READ_RESP, io_TxBuf, 2);
                      }
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 82  

              }       /* End of io_RtsThresholdRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_PreambleAckRW
               * Purpose: To reply a writing acknowledgement or the preamble mode to MCPU
               * Params: U8_T type - 1: write command 0: read command
               *         U8_T value - WiFi preamble mode
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_PreambleAckRW(U8_T type, U8_T value)
              {
                      U8_T    len;
              
                      if (type == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = value;
                      }
              
                      MWIF_Send(IO_PREAMBLE_RESP, io_TxBuf, len);
                      
              }       /* End of io_PreambleAckRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_TxGainRW
               * Purpose: To reply a writing acknowledgement or the WiFi Tx power gain to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  txGain - The value of WiFi Tx power gain
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_TxGainRW(U8_T rw, U8_T txGain)
              {
                      if (rw == IO_COMMAND_WRITE)
                      {
                              MWIF_Send(IO_TX_POWER_LEVEL_WRITE_ACK, NULL, 0);
                      }
                      else
                      {
                              io_TxBuf[0] = txGain;
              
                              MWIF_Send(IO_TX_POWER_LEVEL_READ_RESP, io_TxBuf, 1);
                      }
              }       /* End of io_TxGainRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_BeaconIntervalRW
               * Purpose: To reply a writing acknowedgement or the beacon interval value to MCPU
               * Params: U8_T  type - 0: read 1: write
               *         U8_T* pValue - Start pointer of the butter to save beacon interval value
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 83  

               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_BeaconIntervalAckRW(U8_T type, U8_T* pValue)
              {
                      if (type == IO_COMMAND_WRITE)
                      {
                              MWIF_Send(IO_BEACON_INTERVAL_WRITE_ACK, NULL, 0);
                      }
                      else
                      {
                              io_TxBuf[0] = *pValue;
                              io_TxBuf[1] = *(pValue + 1);
              
                              MWIF_Send(IO_BEACON_INTERVAL_READ_RESP, io_TxBuf, 2);
                      }
              }       /* End of io_BeaconIntervalRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_CountryRegionAckRW
               * Purpose: To reply a writing acknowledgement or the WiFi country region to MCPU
               * Params: U8_T type - 1: write command 0: read command
               *         U8_T value - WiFi country region
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_CountryRegionAckRW(U8_T type, U16_T value)
              {
                      U8_T    len;
              
                      if (type == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 3;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              *((U16_T XDATA *)(&io_TxBuf[1])) = value;
                      }
              
                      MWIF_Send(IO_COUNTRY_REGION_RESP, io_TxBuf, len);
                      
              }       /* End of io_CountryRegionAckRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_AtimIntervalRW
               * Purpose: To reply a writing acknowedgement or the ATIM interval value to MCPU
               * Params: U8_T  type - 0: read 1: write
               *         U8_T* pValue - Start pointer of the butter to save ATIM interval value
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_AtimIntervalAckRW(U8_T type, U8_T XDATA* pValue)
              {
                      if (type == IO_COMMAND_WRITE)
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 84  

                      {
                              MWIF_Send(IO_ATIM_INTERVAL_WRITE_ACK, NULL, 0);
                      }
                      else
                      {
                              io_TxBuf[0] = *pValue;
                              io_TxBuf[1] = *(pValue + 1);
              
                              MWIF_Send(IO_ATIM_INTERVAL_READ_RESP, io_TxBuf, 2);
                      }
              }       /* End of io_AtimIntervalRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_TxDataRateRW
               * Purpose: To reply a writing acknowledgement or the WiFi data rate to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  txRate - The value of WiFi data rate
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_TxDataRateRW(U8_T rw, U8_T txRate)
              {
                      U8_T    len;    
              
                      if (rw == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = txRate;
                      }
              
                      MWIF_Send(IO_TX_DATA_RATE_RESP, io_TxBuf, len);
                      
              }       /* End of io_TxDataRateRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_AutoPowerCtrlRW
               * Purpose: To reply a writing acknowledgement or the auto power control state to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  state - The state of auto power control
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_AutoPowerCtrlRW(U8_T rw, U8_T state)
              {
                      U8_T    len;
              
                      if (rw == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 85  

                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = state;
                      }
                      
                      MWIF_Send(IO_AUTO_POWER_CONTROL_RESP, io_TxBuf, len);
              
              }       /* End of io_AutoPowerCtrlRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_AutoPowerCtrlDetailW
               * Purpose: To reply a writing acknowledgement or the auto power control state to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  state - The state of auto power control
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_AutoPowerCtrlDetailW(void)
              {
                      U8_T    len;
              
                      len = 1;
                      io_TxBuf[0] = IO_COMMAND_WRITE;
                      
                      MWIF_Send(IO_DBG_AUTO_POWER_CONTROL_RESP, io_TxBuf, len);
              
              }       /* End of io_AutoPowerCtrlDetailW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_RoamingRW
               * Purpose: To reply a writing acknowledgement or the roaming state to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  state - The state of roaming
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_RoamingRW(U8_T rw, U8_T state)
              {
                      U8_T    len;
              
                      if (rw == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = state;
                      }
                      
                      MWIF_Send(IO_WIFI_ROAMING_RESP, io_TxBuf, len);
              
              }       /* End of io_RoamingRW */
              
              /*
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 86  

               * ----------------------------------------------------------------------------
               * Function Name: io_WifiMultimediaSetRW
               * Purpose: To reply a writing acknowledgement or the WMM state to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  state - The state of WMM
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_WifiMultimediaSetRW(U8_T rw, U8_T state)
              {
                      U8_T    len;
              
                      if (rw == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = state;
                      }
                      
                      MWIF_Send(IO_WIFI_MULTIMEDIA_SET_RESP, io_TxBuf, len);
              
              }       /* End of io_WifiMultimediaSetRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_ListenIntervalRW
               * Purpose: To reply a writing acknowledgement or the listen interval to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  value - The value of listen interval
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_ListenIntervalRW(U8_T rw, U16_T value)
              {
                      U8_T    len;
              
                      if (rw == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 3;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              *((U16_T*)&io_TxBuf[1]) = value;
                      }
                      
                      MWIF_Send(IO_LISTEN_INTERVAL_RESP, io_TxBuf, len);
              
              }       /* End of io_ListenIntervalRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_MinContentionWindowRW
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 87  

               * Purpose: To reply a writing acknowledgement or the minimum contention window to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  value - The value of minimum contention window
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_MinContentionWindowRW(U8_T rw, U16_T value)
              {
                      U8_T    len;
              
                      if (rw == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 3;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              *((U16_T*)&io_TxBuf[1]) = value;
                      }
                      
                      MWIF_Send(IO_MINIMUM_CONTENTION_WINDOW_RESP, io_TxBuf, len);
              
              }       /* End of io_MinContentionWindowRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_MaxContentionWindowRW
               * Purpose: To reply a writing acknowledgement or the maximum contention window to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  value - The value of minimum contention window
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_MaxContentionWindowRW(U8_T rw, U16_T value)
              {
                      U8_T    len;
              
                      if (rw == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 3;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              *((U16_T*)&io_TxBuf[1]) = value;
                      }
                      
                      MWIF_Send(IO_MAXIMUM_CONTENTION_WINDOW_RESP, io_TxBuf, len);
              
              }       /* End of io_MaxContentionWindowRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_ShowRssiResp
               * Purpose: To reply RSSI value to MCPU
               * Params: U8_T rssi - Input of the RSSI value
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 88  

               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_ShowRssiResp(U8_T rssi)
              {
                      io_TxBuf[0] = rssi;
              
                      MWIF_Send(IO_SHOW_RSSI_RESP, io_TxBuf, 1);
                      
              }       /* End of io_ShowRssiResp */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_PayloadLenAddInWifiRW
               * Purpose: To reply a writing acknowledgement or the payload length in WiFi packet to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  value - 0: Disable payload length in WiFi packet
               *                       1: Enable payload length in WiFi packet
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_PayloadLenAddInWifiRW(U8_T rw, U8_T state)
              {
                      U8_T    len;
              
                      if (rw == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = state;
                      }
                      
                      MWIF_Send(IO_PAYLOAD_LENGTH_ATTACH_IN_WIFI_PACKET_RESP, io_TxBuf, len);
                      
              }       /* End of io_PayloadLenAddInWifiRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_RetainLlcInWifiRW
               * Purpose: To reply a writing acknowledgement or the retain LLC in WiFi packet to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  value - 0: Disable retain LLC in WiFi packet
               *                       1: Enable retain LLC in WiFi packet
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_RetainLlcInWifiRW(U8_T rw, U8_T state)
              {
                      U8_T    len;
              
                      if (rw == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 89  

                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[1] = IO_COMMAND_READ;
                              io_TxBuf[2] = state;
                      }
                      
                      MWIF_Send(IO_RETAIN_LLC_IN_WIFI_PACKET_RESP, io_TxBuf, len);
                      
              }       /* End of io_RetainLlcInWifiRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_2LlcInWiFiVlanPacketRW
               * Purpose: To reply a writing acknowledgement or add 2 LLC in WiFi VLAN packet to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  value - 0: Disable 2 LLC in WiFi VLAN packet
               *                       1: Enable 2 LLC in WiFi VLAN packet
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_2LlcInWiFiVlanPacketRW(U8_T rw, U8_T state)
              {
                      U8_T    len;
              
                      if (rw == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = state;
                      }
                      
                      MWIF_Send(IO_2_LLC_IN_WIFI_VLAN_PACKET, io_TxBuf, len);
                      
              }       /* End of io_2LlcInWiFiVlanPacketRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_TrafficProfileRW
               * Purpose: To reply a writing acknowledgement or send the traffic profile value to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  state - 0: voice        1: vedio
               *                       2: best effort  3: back ground
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_TrafficProfileRW(U8_T rw, U8_T state)
              {
                      U8_T    len;
              
                      if (rw == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 90  

                      }
                      else
                      {
                              len= 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = state;
                      }
                      
                      MWIF_Send(IO_TRAFFIC_PROFILE_RESP, io_TxBuf, len);
                      
              }       /* End of io_TrafficProfileRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_TxDefaultPowerLevelRW
               * Purpose: To reply a writing acknowledgement or current Tx default power level to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  level - 0: 100%, 1: 50%, 2: 25%, 3: 12.5%, 4: 6.25%
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_TxDefaultPowerLevelRW(U8_T rw, U8_T level)
              {
                      if (rw == IO_COMMAND_WRITE)
                      {
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                              io_TxBuf[1] = level;
                      }
                      else
                      {
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = level;
                      }
                      
                      MWIF_Send(IO_TX_DEFAULT_POWER_LEVEL_RESP, io_TxBuf, 2);
                      
              }       /* End of io_TxDefaultPowerLevelRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_QueuePrioritySetRW
               * Purpose: To reply a queue priority to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  index - 0~3: Queue index
               *         U8_T  priority - 0~3: voice, vedio, best effort, background
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_QueuePrioritySetRW(U8_T rw, U8_T priority)
              {
                      U8_T    len;
                      
                      if (rw == IO_COMMAND_WRITE)
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                              io_TxBuf[1] = priority;
                      }
                      else
                      {
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 91  

                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = priority;
                      }
                      
                      MWIF_Send(IO_QUEUE_PRIORITY_SET_RESP, io_TxBuf, len);
                      
              }       /* End of io_TxDefaultPowerLevelRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_SelfCtsRW
               * Purpose: To reply the self-CTS from MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  value - 0: OFF, 1: ON
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_SelfCtsRW(U8_T rw, U8_T value)
              {
                      U8_T    len;
                      
                      if (rw == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = value;
                      }
                      
                      MWIF_Send(IO_SELF_CTS_RESP, io_TxBuf, len);
                      
              }       /* End of io_SelfCtsRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_BssidR
               * Purpose: To reply the BSSID to MCPU
               * Params: U8_T  *bssid
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_BssidR(U8_T *bssid)
              {
                      io_TxBuf[0] = IO_COMMAND_READ;
                      memcpy(&io_TxBuf[1], bssid, 6);
                      
                      MWIF_Send(IO_BSSID_RESP, io_TxBuf, 7);
                      
              }       /* End of io_BssidR */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_WifiIpR
               * Purpose: To reply the Wifi IP address to MCPU
               * Params: U8_T  *wifiIp
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 92  

               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_WifiIpR(U8_T *wifiIp)
              {
                      memcpy(&io_TxBuf[0], wifiIp, 4);
                      
                      MWIF_Send(IO_WIFI_IP_READ_RESP, io_TxBuf, 4);
                      
              }       /* End of io_WifiIpR */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_WifiDriverR
               * Purpose: To reply the Wifi driver version to MCPU
               * Params: U8_T  *pVer
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_WifiDriverVerR(U8_T *pVer)
              {
                      memcpy(&io_TxBuf[0], pVer, (U8_T)strlen(pVer));
              
                      MWIF_Send(IO_WIFI_DRIVER_VER_READ_RESP, io_TxBuf, (U8_T)strlen(pVer));
                      
              }       /* End of io_WifiDriverVerR */
              
              #if MASS_PRODUCTION
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_ContinuousTxAck
               * Purpose: To reply a writing acknowledgement to MCPU
               * Params: none
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_ContinuousTxAck(U8_T mode)
              {
                      io_TxBuf[0] = mode;
              
                      MWIF_Send(IO_CONTINUOUS_TX_ACK, io_TxBuf, 1);
              
              }       /* End of io_ContinuousTxAck */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_SensitivityTestAck
               * Purpose: To reply a acknowledgement to MCPU
               * Params: none
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_SensitivityTestAck(U8_T *ptr)
              {
                      io_TxBuf[0] = ptr[0];
                      io_TxBuf[1] = ptr[1];
                      
                      MWIF_Send(IO_SENSITIVITY_TEST_ACK, io_TxBuf, 2);
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 93  

              
              }       /* End of io_SensitivityTestAck */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_SensitivityTestReportAck
               * Purpose: To reply a acknowledgement to MCPU
               * Params: none
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_SensitivityTestReportAck(void)
              {
                      U8_T    i, j;
              
                      j = (U8_T)strlen(DBG_senTestResult);
              
                      for (i = 0; i < j; i++)
                      {
                              io_TxBuf[i] = DBG_senTestResult[i];
                      }
              
                      MWIF_Send(IO_SENSITIVITY_TEST_REPORT_ACK, io_TxBuf, j);
                      
              }       /* End of io_SensitivityTestReportAck */
              #endif
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_SfrIO
               * Purpose: To write the value into specific SFR or to read the value from specific SFR
               * Params: U8_T  rw - 0: read 1: write
               *         U8_T  index - The index of the specific SFR
               *         U8_T* pValue - The pointer of the buffer to save SFR value
               * Returns: 0x00: success 0xFF: fault
               * Note: none
               * ----------------------------------------------------------------------------
               */
              U8_T io_SfrIO(U8_T rw, U8_T index, U8_T XDATA* pValue)
              {
                      if (rw == IO_COMMAND_READ)
                      {
                              switch(index)
                              {
                              case 0x80:
                                      *pValue = P0;
                                      break;
                              case 0x81:
                                      *pValue = SP;
                                      break;
                              case 0x82:
                                      *pValue = DPL0;
                                      break;
                              case 0x83:
                                      *pValue = DPH0;
                                      break;
                              case 0x84:
                                      *pValue = DPL1;
                                      break;
                              case 0x85:
                                      *pValue = DPH1;
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 94  

                                      break;
                              case 0x86:
                                      *pValue = DPS;
                                      break;
                              case 0x87:
                                      *pValue = PCON;
                                      break;
                              case 0x88:
                                      *pValue = TCON;
                                      break;
                              case 0x89:
                                      *pValue = TMOD;
                                      break;
                              case 0x8a:
                                      *pValue = TL0;
                                      break;
                              case 0x8b:
                                      *pValue = TL1;
                                      break;
                              case 0x8c:
                                      *pValue = TH0;
                                      break;
                              case 0x8d:
                                      *pValue = TH1;
                                      break;
                              case 0x8e:
                                      *pValue = CKCON;
                                      break;
                              case 0x90:
                                      *pValue = P1;
                                      break;
                              case 0x91:
                                      *pValue = EIF;
                                      break;
                              case 0x92:
                                      *pValue = WTST;
                                      break;
                              case 0x93:
                                      *pValue = DPX0;
                                      break;
                              case 0x95:
                                      *pValue = DPX1;
                                      break;
                              case 0x98:
                                      *pValue = SCON0;
                                      break;
                              case 0x99:
                                      *pValue = SBUF0;
                                      break;
                              case 0x9d:
                                      *pValue = ACON;
                                      break;
                          case 0xa0:
                                      *pValue = P2;
                                      break;
                              case 0xa1:
                                      *pValue = PMALR;
                                      break;
                          case 0xa2:
                                      *pValue = PMAHR;
                                      break;
                              case 0xa3:
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 95  

                                      *pValue = PMDR0;
                                      break;
                              case 0xa4:
                                      *pValue = PMDR1;
                                      break;
                              case 0xa5:
                                      *pValue = PMDR2;
                                      break;
                              case 0xa6:
                                      *pValue = PMDR3;
                                      break;
                              case 0xa7:
                                      *pValue = PBIER;
                                      break;
                              case 0xa8:
                                      *pValue = IE;
                                      break;
                              case 0xa9:
                                      *pValue = RHPLR;
                                      break;
                              case 0xaa:
                                      *pValue = RHPHR;
                                      break;
                              case 0xab:
                                      *pValue = RSPLR;
                                      break;
                              case 0xac:
                                      *pValue = RSPHR;
                                      break;
                              case 0xae:
                                      *pValue = PBSR;
                                      break;
                              case 0xaf:
                                      *pValue = PBISR;
                                      break;
                              case 0xb0:
                                      *pValue = P3;
                                      break;
                              case 0xb1:
                                      *pValue = MTWPL;
                                      break;
                              case 0xb2:
                                      *pValue = MTWPH;
                                      break;
                              case 0xb3:
                                      *pValue = CTRPL;
                                      break;
                              case 0xb4:
                                      *pValue = CTRPH;
                                      break;
                              case 0xb5:
                                      *pValue = TXBS;
                                      break;
                              case 0xb8:
                                      *pValue = IP;
                                      break;
                              case 0xb9:
                                      *pValue = MRPLL;
                                      break;
                              case 0xba:
                                      *pValue = MRPLH;
                                      break;
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 96  

                              case 0xbb:
                                      *pValue = MRBLL;
                                      break;
                              case 0xbc:
                                      *pValue = MRBLH;
                                      break;
                              case 0xbd:
                                      *pValue = MRBSAL;
                                      break;
                              case 0xbe:
                                      *pValue = MRBSAH;
                                      break;
                              case 0xbf:
                                      *pValue = MRCR;
                                      break;
                              case 0xc0:
                                      *pValue = SCON1;
                                      break;
                              case 0xc1:
                                      *pValue = SBUF1;
                                      break;
                              case 0xc2:
                                      *pValue = MISR;
                                      break;
                              case 0xc3:
                                      *pValue = MIMR;
                                      break;
                              case 0xc8:
                                      *pValue = T2CON;
                                      break;
                              case 0xc9:
                                      *pValue = T2IF;
                                      break;
                              case 0xca:
                                      *pValue = RLDL;
                                      break;
                              case 0xcb:
                                      *pValue = RLDH;
                                      break;
                              case 0xcc:
                                      *pValue = TL2;
                                      break;
                              case 0xcd:
                                      *pValue = TH2;
                                      break;
                              case 0xce:
                                      *pValue = WI2CCIR;
                                      break;
                              case 0xcf:
                                      *pValue = WI2CDR;
                                      break;
                              case 0xd0:
                                      *pValue = PSW;
                                      break;
                              case 0xd8:
                                      *pValue = WDCON;
                                      break;
                              case 0xd9:
                                      *pValue = SINTMR;
                                      break;
                              case 0xda:
                                      *pValue = HASHCR;
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 97  

                                      break;
                              case 0xdb:
                                      *pValue = HASHDR;
                                      break;
                              case 0xe0:
                                      *pValue = ACC;
                                      break;
                              case 0xe1:
                                      *pValue = SINTSR;
                                      break;
                              case 0xe2:
                                      *pValue = SSCIR;
                                      break;
                              case 0xe3:
                                      *pValue = SSDR;
                                      break;
                              case 0xe4:
                                      *pValue = MBCIR;
                                      break;
                              case 0xe5:
                                      *pValue = MBDR;
                                      break;
                              case 0xe6:
                                      *pValue = PBCIR;
                                      break;
                              case 0xe7:
                                      *pValue = PBDR;
                                      break;
                              case 0xe8:
                                      *pValue = EIE;
                                      break;
                              case 0xe9:
                                      *pValue = STATUS;
                                      break;
                              case 0xea:
                                      *pValue = MXAX;
                                      break;
                              case 0xeb:
                                      *pValue = TA;
                                      break;
              //              case 0xec:
              //                      *pValue = SHACIR;
              //                      break;
              //              case 0xed:
              //                      *pValue = SHADR;
              //                      break;
                              case 0xee:
                                      *pValue = RNO;
                                      break;
                              case 0xef:
                                      *pValue = RNDP;
                                      break;
                              case 0xf0:
                                      *pValue = B;
                                      break;
                              case 0xf1:
                                      *pValue = RC0;
                                      break;
                              case 0xf2:
                                      *pValue = RC1;
                                      break;
                              case 0xf3:
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 98  

                                      *pValue = RC2;
                                      break;
                              case 0xf4:
                                      *pValue = RC3;
                                      break;
                              case 0xf5:
                                      *pValue = RC4;
                                      break;
                              case 0xf6:
                                      *pValue = MOP;
                                      break;
                              case 0xf7:
                                      *pValue = MD;
                                      break;
                              case 0xf8:
                                      *pValue = EIP;
                                      break;
                              case 0xf9:
                                      *pValue = WC0;
                                      break;
                              case 0xfa:
                                      *pValue = WC1;
                                      break;
                              case 0xfb:
                                      *pValue = WC2;
                                      break;
                              case 0xfc:
                                      *pValue = WC3;
                                      break;
                              case 0xfd:
                                      *pValue = WC4;
                                      break;
                              case 0xfe:
                                      *pValue = CCTRL;
                                      break;
                              case 0xff:
                                      *pValue = CSSR;
                                      break;
                              default:
                                      return IO_COMMAND_ERROR;
                              }
                      }
                      else if (rw == 1) // write sfr
                      {
                              switch(index)
                              {
                              case 0x80:
                                      P0 = *pValue;
                                      break;
                              case 0x81:
                                      SP = *pValue;
                                      break;
                              case 0x82:
                                      DPL0 = *pValue;
                                      break;
                              case 0x83:
                                      DPH0 = *pValue;
                                      break;
                              case 0x84:
                                      DPL1 = *pValue;
                                      break;
                              case 0x85:
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 99  

                                      DPH1 = *pValue;
                                      break;
                              case 0x86:
                                      DPS = *pValue;
                                      break;
                              case 0x87:
                                      PCON = *pValue;
                                      break;
                              case 0x88:
                                      TCON = *pValue;
                                      break;
                              case 0x89:
                                      TMOD = *pValue;
                                      break;
                              case 0x8a:
                                      TL0 = *pValue;
                                      break;
                              case 0x8b:
                                      TL1 = *pValue;
                                      break;
                              case 0x8c:
                                      TH0 = *pValue;
                                      break;
                              case 0x8d:
                                      TH1 = *pValue;
                                      break;
                              case 0x8e:
                                      CKCON = *pValue;
                                      break;
                              case 0x90:
                                      P1 = *pValue;
                                      break;
                              case 0x91:
                                      EIF = *pValue;
                                      break;
                              case 0x92:
                                      WTST = *pValue;
                                      break;
                              case 0x93:
                                      DPX0 = *pValue;
                                      break;
                              case 0x95:
                                      DPX1 = *pValue;
                                      break;
                              case 0x98:
                                      SCON0 = *pValue;
                                      break;
                              case 0x99:
                                      SBUF0 = *pValue;
                                      break;
                              case 0x9d:
                                      ACON = *pValue;
                                      break;
                          case 0xa0:
                                      P2 = *pValue;
                                      break;
                              case 0xa1:
                                      PMALR = *pValue;
                                      break;
                          case 0xa2:
                                      PMAHR = *pValue;
                                      break;
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 100 

                              case 0xa3:
                                      PMDR0 = *pValue;
                                      break;
                              case 0xa4:
                                      PMDR1 = *pValue;
                                      break;
                              case 0xa5:
                                      PMDR2 = *pValue;
                                      break;
                              case 0xa6:
                                      PMDR3 = *pValue;
                                      break;
                              case 0xa7:
                                      PBIER = *pValue;
                                      break;
                              case 0xa8:
                                      IE = *pValue;
                                      break;
                              case 0xa9:
                                      RHPLR = *pValue;
                                      break;
                              case 0xaa:
                                      RHPHR = *pValue;
                                      break;
                              case 0xab:
                                      RSPLR = *pValue;
                                      break;
                              case 0xac:
                                      RSPHR = *pValue;
                                      break;
                              case 0xae:
                                      PBSR = *pValue;
                                      break;
                              case 0xaf:
                                      PBISR = *pValue;
                                      break;
                              case 0xb0:
                                      P3 = *pValue;
                                      break;
                              case 0xb1:
                                      MTWPL = *pValue;
                                      break;
                              case 0xb2:
                                      MTWPH = *pValue;
                                      break;
                              case 0xb3:
                                      CTRPL = *pValue;
                                      break;
                              case 0xb4:
                                      CTRPH = *pValue;
                                      break;
                              case 0xb5:
                                      TXBS = *pValue;
                                      break;
                              case 0xb8:
                                      IP = *pValue;
                                      break;
                              case 0xb9:
                                      MRPLL = *pValue;
                                      break;
                              case 0xba:
                                      MRPLH = *pValue;
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 101 

                                      break;
                              case 0xbb:
                                      MRBLL = *pValue;
                                      break;
                              case 0xbc:
                                      MRBLH = *pValue;
                                      break;
                              case 0xbd:
                                      MRBSAL = *pValue;
                                      break;
                              case 0xbe:
                                      MRBSAH = *pValue;
                                      break;
                              case 0xbf:
                                      MRCR = *pValue;
                                      break;
                              case 0xc0:
                                      SCON1 = *pValue;
                                      break;
                              case 0xc1:
                                      SBUF1 = *pValue;
                                      break;
                              case 0xc2:
                                      MISR = *pValue;
                                      break;
                              case 0xc3:
                                      MIMR = *pValue;
                                      break;
                              case 0xc8:
                                      T2CON = *pValue;
                                      break;
                              case 0xc9:
                                      T2IF = *pValue;
                                      break;
                              case 0xca:
                                      RLDL = *pValue;
                                      break;
                              case 0xcb:
                                      RLDH = *pValue;
                                      break;
                              case 0xcc:
                                      TL2 = *pValue;
                                      break;
                              case 0xcd:
                                      TH2 = *pValue;
                                      break;
                              case 0xce:
                                      WI2CCIR = *pValue;
                                      break;
                              case 0xcf:
                                      WI2CDR = *pValue;
                                      break;
                              case 0xd0:
                                      PSW = *pValue;
                                      break;
                              case 0xd8:
                                      WDCON = *pValue;
                                      break;
                              case 0xd9:
                                      SINTMR = *pValue;
                                      break;
                              case 0xda:
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 102 

                                      HASHCR = *pValue;
                                      break;
                              case 0xdb:
                                      HASHDR = *pValue;
                                      break;
                              case 0xe0:
                                      ACC = *pValue;
                                      break;
                              case 0xe1:
                                      SINTSR = *pValue;
                                      break;
                              case 0xe2:
                                      SSCIR = *pValue;
                                      break;
                              case 0xe3:
                                      SSDR = *pValue;
                                      break;
                              case 0xe4:
                                      MBCIR = *pValue;
                                      break;
                              case 0xe5:
                                      MBDR = *pValue;
                                      break;
                              case 0xe6:
                                      PBCIR = *pValue;
                                      break;
                              case 0xe7:
                                      PBDR = *pValue;
                                      break;
                              case 0xe8:
                                      EIE = *pValue;
                                      break;
                              case 0xe9:
                                      STATUS = *pValue;
                                      break;
                              case 0xea:
                                      MXAX = *pValue;
                                      break;
                              case 0xeb:
                                      TA = *pValue;
                                      break;
                              case 0xee:
                                      RNO = *pValue;
                                      break;
                              case 0xef:
                                      RNDP = *pValue;
                                      break;
                              case 0xf0:
                                      B = *pValue;
                                      break;
                              case 0xf1:
                                      RC0 = *pValue;
                                      break;
                              case 0xf2:
                                      RC1 = *pValue;
                                      break;
                              case 0xf3:
                                      RC2 = *pValue;
                                      break;
                              case 0xf4:
                                      RC3 = *pValue;
                                      break;
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 103 

                              case 0xf5:
                                      RC4 = *pValue;
                                      break;
                              case 0xf6:
                                      MOP = *pValue;
                                      break;
                              case 0xf7:
                                      MD = *pValue;
                                      break;
                              case 0xf8:
                                      EIP = *pValue;
                                      break;
                              case 0xf9:
                                      WC0 = *pValue;
                                      break;
                              case 0xfa:
                                      WC1 = *pValue;
                                      break;
                              case 0xfb:
                                      WC2 = *pValue;
                                      break;
                              case 0xfc:
                                      WC3 = *pValue;
                                      break;
                              case 0xfd:
                                      WC4 = *pValue;
                                      break;
                              case 0xfe:
                                      CCTRL = *pValue;
                                      break;
                              case 0xff:
                                      CSSR = *pValue;
                                      break;
                              default:
                                      return IO_COMMAND_ERROR;
                              }
                      }
                      else // command error
                              return IO_COMMAND_ERROR;
              
                      return IO_COMMAND_DONE;
              
              }       /* End of io_SfrIO */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_SfrAckRW
               * Purpose: To reply a writing acknowedgement or the SFR value to MCPU
               * Params: U8_T type - 0: read 1: write
               *         U8_T value - The value of specific SFR
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_SfrAckRW(U8_T type, U8_T value)
              {
                      if (type == IO_COMMAND_WRITE)
                      {
                              MWIF_Send(IO_DBG_WCPU_SFR_WRITE_ACK, NULL, 0);
                      }
                      else
                      {
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 104 

                              io_TxBuf[0] = value;
              
                              MWIF_Send(IO_DBG_WCPU_SFR_READ_RESP, io_TxBuf, 1);
                      }
              }       /* End of io_SfrRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_WcpuIndirectAckRW
               * Purpose: To reply a writing acknowledgement or the WCPU system register value to MCPU
               * Params: U8_T  type - 1: write command 0: read command
               *         U8_T  len - The buffer length of WCPU system register
               *         U8_T* pReg - The start pointer of the buffer to save WCPU system register value
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_WcpuIndirectAckRW(U8_T type, U8_T len, U8_T XDATA* pReg)
              {
                      if (type == IO_COMMAND_WRITE)
                      {
                              MWIF_Send(IO_DBG_WCPU_SUB_SYS_REG_WRITE_RESP, NULL, 0);
                      }
                      else
                      {
                              memcpy(&io_TxBuf[0], pReg, len);
              
                              MWIF_Send(IO_DBG_WCPU_SUB_SYS_REG_READ_RESP, io_TxBuf, len);
                      }
              }       /* End of io_WcpuIndirectAckRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_MiibIndirectAckRW
               * Purpose: To reply a writing acknowledgement or the MII bridge register value to MCPU
               * Params: U8_T  type - 1: write command 0: read command
               *         U8_T  len - The buffer length of MII bridge register
               *         U8_T* pReg - The start pointer of the buffer to save MII bridge register value
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_MiibIndirectAckRW(U8_T type, U8_T len, U8_T XDATA* pReg)
              {
                      if (type== IO_COMMAND_WRITE)
                      {
                              MWIF_Send(IO_DBG_WCPU_MIIB_REG_WRITE_ACK, NULL, 0);
                      }
                      else
                      {
                              memcpy(&io_TxBuf[0], pReg, len);
              
                              MWIF_Send(IO_DBG_WCPU_MIIB_REG_READ_RESP, io_TxBuf, len);
                      }
              }       /* End of io_MiibIndirectAckRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_PcibIndirectRegAckRW
               * Purpose: To reply a writing acknowledgement or the PCI bridge register value to MCPU
               * Params: U8_T  type - 1: write command 0: read command
               *         U8_T  len - The buffer length of PCI bridge register
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 105 

               *         U8_T* pReg - The start pointer of the buffer to save PCI bridge register value
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_PcibIndirectRegAckRW(U8_T type, U8_T len, U8_T XDATA* pReg)
              {
                      if (type == IO_COMMAND_WRITE)
                      {
                              MWIF_Send(IO_DBG_WCPU_PCIB_REG_WRITE_ACK, NULL, 0);
                      }
                      else
                      {
                              memcpy(&io_TxBuf[0], pReg, len);
              
                              MWIF_Send(IO_DBG_WCPU_PCIB_REG_READ_RESP, io_TxBuf, len);
                      }
              }       /* End of io_PcibIndirectRegAckRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_PciConfigRW
               * Purpose: To reply a writing acknowedgement or the PCI configuration value to MCPU
               * Params: U8_T  type - 0: read 1: write
               *         U8_T* pValue - Start pointer of the butter to save PCI configuration value
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_PciConfigAckRW(U8_T type, U8_T XDATA* pReg)
              {
                      if (type == IO_COMMAND_WRITE)
                      {
                              MWIF_Send(IO_DBG_PCI_CONFIGURATION_WRITE_ACK, NULL, 0);
                      }
                      else
                      {
                              memcpy(&io_TxBuf[0], pReg, 4);
              
                              MWIF_Send(IO_DBG_PCI_CONFIGURATION_READ_RESP, io_TxBuf, 4);
                      }
              }       /* End of io_PciConfigRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_WiFiRegRW
               * Purpose: To reply a writing acknowedgement or the WiFi register value to MCPU
               * Params: U8_T  type - 0: read 1: write
               *         U8_T* pValue - Start pointer of the buffer to save register value
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_WiFiRegAckRW(U8_T type, U8_T XDATA* pValue)
              {
                      if (type == IO_COMMAND_WRITE)
                      {
                              MWIF_Send(IO_DBG_WIFI_REG_WRITE_ACK, NULL, 0);
                      }
                      else
                      {
                              memcpy(&io_TxBuf[0], pValue, 4);
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 106 

              
                              MWIF_Send(IO_DBG_WIFI_REG_READ_RESP, io_TxBuf, 4);
                      }
              }       /* End of io_WiFiRegRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_WlanPktFilterAckRW
               * Purpose: To reply a writing acknowledgement or the WiFi packet filtering result to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  type - the type of WiFi packet
               *         U8_T  subtype - The subtype of WiFi packet
               *         U8_T* pBssid - The start pointer of the buffer to save BSSID
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_WlanPktFilterAckRW(U8_T rw, U8_T type, U16_T subtype, U8_T XDATA* pBssid)
              {
                      if (rw == IO_COMMAND_WRITE)
                      {
                              MWIF_Send(IO_DBG_WIFI_PACKET_FILTERING_WRITE_ACK, NULL, 0);
                      }
                      else
                      {
                              io_TxBuf[0] = type;
                              io_TxBuf[1] = *((U8_T XDATA *)&subtype);
                              io_TxBuf[2] = (U8_T)subtype;
                              io_TxBuf[3] = pBssid[0];
                              io_TxBuf[4] = pBssid[1];
                              io_TxBuf[5] = pBssid[2];
                              io_TxBuf[6] = pBssid[3];
                              io_TxBuf[7] = pBssid[4];
                              io_TxBuf[8] = pBssid[5];
              
                              MWIF_Send(IO_DBG_WIFI_PACKET_FILTERING_READ_RESP, io_TxBuf, 9);
                      }
              
              }       /* End of io_WlanPktFilterAckRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_SynthesizerSetAck
               * Purpose: To reply a acknowedgement to MCPU
               * Params: none
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_SynthesizerSetAck(void)
              {
                      MWIF_Send(IO_DBG_SYNTHESIZER_SET_ACK, NULL, 0);
                      
              }       /* End of io_SynthesizerSetAck */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_RetryAckRW
               * Purpose: To reply a writing acknowledgement or the retry count to MCPU
               * Params: U8_T type - 1: write command 0: read command
               *         U8_T value - WiFi packet retry count
               * Returns: none
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 107 

               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_RetryAckRW(U8_T type, U8_T value)
              {
                      U8_T    len;
              
                      if (type == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = value;
                      }
              
                      MWIF_Send(IO_DBG_RETRY_NUMBER_RESP, io_TxBuf, len);
                      
              }       /* End of io_RetryAckRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_Gpio0RW
               * Purpose: To reply a writing acknowledgement or the P0 value to MCPU
               * Params: U8_T type - 1: write command 0: read command
               *         U8_T value - value of P0
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_Gpio0RW(U8_T type, U8_T value)
              {
                      U8_T    len;
              
                      if (type == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = value;
                      }
              
                      MWIF_Send(IO_GPIO_ZERO_RESP, io_TxBuf, len);
                      
              }       /* End of io_Gpio0RW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_Gpio1RW
               * Purpose: To reply a writing acknowledgement or the P1 value to MCPU
               * Params: U8_T type - 1: write command 0: read command
               *         U8_T value - value of P1
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 108 

               */
              void io_Gpio1RW(U8_T type, U8_T value)
              {
                      U8_T    len;
              
                      if (type == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = value;
                      }
              
                      MWIF_Send(IO_GPIO_ONE_RESP, io_TxBuf, len);
                      
              }       /* End of io_Gpio1RW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_Gpio2RW
               * Purpose: To reply a writing acknowledgement or the P2 value to MCPU
               * Params: U8_T type - 1: write command 0: read command
               *         U8_T value - value of P2
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_Gpio2RW(U8_T type, U8_T value)
              {
                      U8_T    len;
              
                      if (type == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = value;
                      }
              
                      MWIF_Send(IO_GPIO_TWO_RESP, io_TxBuf, len);
                      
              }       /* End of io_Gpio2RW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_Gpio3RW
               * Purpose: To reply a writing acknowledgement or the P3 value to MCPU
               * Params: U8_T type - 1: write command 0: read command
               *         U8_T value - value of P3
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_Gpio3RW(U8_T type, U8_T value)
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 109 

              {
                      U8_T    len;
              
                      if (type == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = value;
                      }
              
                      MWIF_Send(IO_GPIO_THREE_RESP, io_TxBuf, len);
                      
              }       /* End of io_Gpio3RW */
              
              #if ALLEN_DBG
              void IO_WlanDebug1(U8_T value)
              {
                      MWIF_Send(IO_WLAN_DEBUG1, &value, 1);
              
              } /* End of IO_WlanDebug1 */
              #endif
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_WifiRegIO
               * Purpose: To read or to write the value into specific WiFi register
               * Params: U8_T  rw - 0: read 1: write
               *         U8_T  index - The index of the specific WiFi register
               *         U8_T* pValue - Start pointer of the WiFi value buffer
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              U8_T io_WifiRegIO(U8_T rw, U16_T index, U32_T XDATA* pValue)
              {
                      if ((index > 0xeff) || (index % 4))
                              return IO_COMMAND_ERROR;
              
                      if (index < 0x400)
                      {
                              LockPhyReg();
                      }
              
                      if (rw == 0)
                      {
                              *pValue = ZD_Readl(index);
                      }
                      else if (rw == 1)
                      {
                              ZD_Writel(*pValue, index);
                      }
                      else
                      {
                              if (index < 0x400)
                              {
                                      UnLockPhyReg();
                              }
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 110 

                              return IO_COMMAND_ERROR;
                      }
              
                      if (index < 0x400)
                      {
                              UnLockPhyReg();
                      }
                      return IO_COMMAND_DONE;
              
              } /* End of dbg_WifiRegIO */
              
              /*******************************************************************/
              #endif  /**************** End of IO_CPU_TYPE macro *****************/
6756          
6757          #if IO_SHOWCMD
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_ShowCmd
               * Purpose: To list the contents of the MCPU/WCPU communication command 
               * Params: U8_T  TxRx - 1: To send command to the other CPU
               *                      0: To receive command from the other CPU
               *         U8_T* pReg - Start pointer of the buffer to save the command
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_ShowCmd(U8_T TxRx, U8_T XDATA* pReg)
              {
                      U8_T i, len;
              
              
                      len = pReg[2] + 3;
                      printd ("\n\r*------------------------------------*\n\r");
                      if (TxRx)
                              printd ("| Sent IO Cmd.. ==>\n\r");
                      else
                              printd ("| Received IO Cmd.. <==\n\r");
                      printd ("| Len: %bd\n\r", len);
                      printd ("| header: %02bx %02bx %02bx\n\r", pReg[0], pReg[1], pReg[2]);
                      printd ("| payload:");
                      for (i = 3; i < len; i++)
                      {
                              printd(" %02bx", pReg[i]);
                              if (!((i + 1) % 16))
                                      printd("\n\r|         ");
                      }
                      printd ("\n\r*------------------------------------*\n\r");
              }
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  15159    ----
   CONSTANT SIZE    =   3904    ----
   XDATA SIZE       =   1695      72
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
C51 COMPILER V9.05   MWIOCTL                                                               04/11/2012 16:46:56 PAGE 111 

   FAR CONST SIZE   =     34    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
